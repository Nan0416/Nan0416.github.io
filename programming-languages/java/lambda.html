<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Java&nbsp;Lambda</title>
<meta charset="utf-8">
<meta name="date" content="2018-03-10">
<meta name="keywords" content="anonymous">
<meta name="keywords" content="class">
<meta name="keywords" content="java">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<!--<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>-->
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>Java&nbsp;-&nbsp;Lambda</strong>
</div>
<p class="date"><span class="created-date">Created:2018-03-10</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2020-03-12 [First modification after working.]</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#lambdaIntro">Lambda</a></li>
<li><a href="#methodreference">Method Reference</a></li>
<li><a href="#lambdaExample">Examples</a></li>

</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="lambdaIntro">
<h3>Lambda</h3>
<p>Lambda is a new feature since Java 8: functionality as an argument. e.g. Runnable</p>
<div class="featureList">
<ol>
<li>It is a simplified anonymous class.</li>
<li>It is like a function argument, but internally is implemented by Java interface.</li>
<li>Lambda expression return an object of an interface.</li>
<li><strong>It can only be used when for implementing an interface that only has one method.</strong></li>
</ol>
</div>
</div>
</li>

<li>
<div class="content" id="lambdaExample">
<h3>Examples</h3>
<div class="featureList">
<ol>
<li>


<h4>Use lambda</h4>
<pre class="brush: java">
public class Lambda {

    public static void main(String [] args){
        // Print p = ()-> System.out.println("hello");
        Printable p2 = ()->System.out.println("Hello");
        p2.print();
        // Print2 p3 = ()->System.out.println("ss");
    }
}

class Print{
    public void print(){
        System.out.println("Print");
    }
}
// only the following can be used for lambda
interface Printable{
    public void print();
}
abstract class Print2{
    public abstract void print();
}
</pre>
</li>
<li>
<h4>Lambda with arguments and multi-statement</h4>
<p>Don't forget the semicolon at the end of the }. <strong>The semicolon is for the assignment statement.</strong></p>
<pre class="brush:java">
public class Lambda2 {
    public static void main(String [] args){
        Printable2 t = (text)->{
            System.out.println(text + text);
            System.out.println("end");
        };
        t.print("qinnan");

    }
}
interface Printable2{
    void print(String text);
}
</pre>
</li>
<li>
<h4>Function as a parameter</h4>
<pre class="brush:java">
public class Lambda3{
    private String value;
    public void operate(Operator op){
        value = op.operate(value);
    }
    public Lambda3(String text){
        value = text;
    }
    public String getValue(){
        return value;
    }
    public static void main(String [] args){
        Lambda3 lb = new Lambda3("");
        lb.operate((s)->"First");
        lb.operate((s)-> s+ "Second");
        System.out.println(lb.getValue());
    }
}
interface Operator{
    public String operate(String str);
}
</pre>
</li>
<li>
<h4>With return value</h4>
<pre class="brush:java">
public class Lambda3{
    private String value;
    public void operate(Operator op){
        value = op.operate(value);
    }
    public Lambda3(String text){
        value = text;
    }
    public String getValue(){
        return value;
    }
    public static void main(String [] args){
        Lambda3 lb = new Lambda3("");
        lb.operate((s)->"First");
        lb.operate(
                (s)-> {s += "Second";
                return s;
                } // here no ; 
        );
        System.out.println(lb.getValue());
    }
}
interface Operator{
    public String operate(String str);
}
</pre>
</li>
</ol>
</div>
</div>
</li>
<li>
    <div class="content" id="methodreference">
        <h3>Method Reference</h3>
        <p>Method reference is syntax helper to map a class (static/instance/constructor) method to a functional interface. So there are two ways for creating an instance of functional interface, 1) using lambda, 2) using method reference from existing classes.</p>
        <div class="featureList">
            <ol>
                <li>
                    <h4>Instance/Static Method Reference</h4>
                    <p>Suppose defining a Op interface:</p>
                    <pre class="brush:java">
                        public interface Op{
                            double operate(double x, double y);
                        }
                    </pre>
                    <p>And you have a class method, either static or instance, has the same argument and return type as the functional interface defined method. Then you can assign the class method to the functional interface's variable.</p>
                    <pre class="brush:java">
                        public class MethodReference {
                            public static double add(double x, double y){
                                return x + y;
                            }
                            public double subtract(double x, double y){
                                return x - y;
                            }
                        }
                    </pre>
                    <pre class="brush:java">
                        public class StaticMethodReferenceTest {
                            public static void main(String [] args){
                                Op add = MethodReference::add; // static method using the class name
                                MethodReference mr = new MethodReference(); // instance method using the instance.
                                Op sub = mr::subtract;
                            }
                        }
                        
                    </pre>
                    <p>In addition, the modifiers, public,private,protected and default, are stilling working as expected.</p>
                </li>
                <li>
                    <h4>Constructor Method Reference</h4>
                    <p>Constructor method doesn't have a return type. But it also actually return itself.</p>
                    <pre class="brush:java">
                        public interface GetObjectX{
                            X acquire(String arg1, String arg2);
                        }
                        public X{
                            public X(String arg1, String arg2);
                        }
                        public class Test{
                            public static void main(String [] args){
                                GetObjectX gx = X::new;
                                X xObject = gx.acquire("xxx", "yyy");
                            }
                        }
                    </pre>
                </li>
            </ol>
        </div>
    </div>
</li>

</ol>
</div>
    
</body>
</html>
