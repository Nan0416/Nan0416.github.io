<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Java&nbsp;Generic</title>
<meta charset="utf-8">
<meta name="date" content="2018-03-15">
<meta name="keywords" content="java">
<meta name="keywords" content="generic">
<meta name="keywords" content="programming">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>Java&nbsp;-&nbsp;Generic</strong>
</div>
<p class="date"><span class="created-date">Created:2018-03-15</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-07-24</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#genericIntro">Introduction</a></li>
<li><a href="#genericClass">Generic Class</a></li>
<li><a href="#genericMethod">Generic Method</a></li>
<li><a href="#genericRestriction">Restriction on Type parameters (extends interface)</a></li>
<li><a href="#wildcard">Wildcard Generic</a></li>
<li><a href="#genericLimitation">Limitation</a></li>
<li><a href="#genericReference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="genericIntro">
<h3>Introduction</h3>
<p>Generic: type (class, interface, enum) as variable.</p>
<p>A generic class/interface can have several type variables.</p>
<p>Compared to use Object class as a "generic" class, we don't need to <span style="color:red">cast</span>.</p>
<h4>Java Generics vs. C# Generics</h4>
<p>
    Both of Java and C# support generics, and they have similar syntax. But their implementations are quite different. Java's generics is much like a compile time behavior, 
    it replaces Generics by Object and casting at compile time. In contrast, C# compiles generics into MSIL bytecode, it's a runtime behavior.
</p>
<p><span style="color:red">Generic provides a way to easily define new class.</span> Now we have two ways to define new class, the first is <span class="inline-code">public class X [extends] [implements]{}</span>, the second approach is directly doing <span class="inline-code">Generic&lt;String></span></p>
</div>
</li>
<li>
<div class="content" id="genericClass">
<h3>Generic Class</h3>
<div class="featureList">
    <ol>
        <li>
                <h4>Example</h4>
                <pre class="brush:java">
                public class Generic1 &lt;T, V> {
                    private T key;
                    private V value;
                
                    public void print(){
                        System.out.println("Key: " + key + ",Value: " + value);
                    }
                
                    public Generic1(T t, V v){
                        key = t;
                        value = v;
                    }
                    public V getValue(){
                        return value;
                    }
                    public static void main(String [] args){
                        Generic1&lt;String, String> g = new Generic1&lt;>("one","yi");
                        g.print();
                        String v = g.getValue();
                        System.out.println("value : " + v);
                    }
                }
                </pre>
                <p>After creating an instance with type variables setting to String, then we actually get a new class's object.</p>
                <p>The class is</p>
                <pre class="brush:java">
                public class Generic1 {
                    private String key;
                    private String value;
                
                    public void print(){
                        System.out.println("Key: " + key + ",Value: " + value);
                    }
                
                    public Generic1(String t, String v){
                        key = t;
                        value = v;
                    }
                    public String getValue(){
                        return value;
                    }
                    public static void main(String [] args){
                        Generic1 g = new Generic1("one","yi");
                        g.print();
                        String v = g.getValue();
                        System.out.println("value : " + v);
                    }
                }
                </pre>
        </li>
        <li>One generic class can have multiple type variables, they are declared at the first line.</li>
        <li>In the constructor, no type variable is needed. Use them as a regular type.</li>
        <li><strong>Cannot directly instantiate type parameter. e.g. Cannot T t = new T();</strong></li>
    </ol>
</div>
</div>
</li>
<li>
<div class="content" id="genericMethod">
<h3>Generic Method</h3>
<p>The class is not a generic class, but one of the methods can be a generic method.</p>
<pre class="brush:java">
public class GenericMethod {
    public static &lt;T> void print(T v, T x){
        System.out.println(v + " " + x);
        System.out.println(v.getClass().getName()); // dynamic binding print the actual class, not the infered generic type
        System.out.println(x.getClass().getName());
    }
    public static void main(String [] args){
        print("x", "y"); // auto inference
        print(12, 2.01);
        print(13, "u");
        GenericMethod.&lt;String>print("s", "w");
    }
}

</pre>
<h4>Auto inference</h4>
<p>We can directly use the print function, because the compiler can automatically inference the value's type.</p>
<p>Inference rule: e.g. print(13, "u"). <br>
1. wrap the primary type with Integer <br>
2. find the Integer and String's common parent, which is Object <br>
3. Call .toString inside the println.
</p>

</div>
</li>
<li>
<div class="content" id="genericRestriction">
<h3>Restriction on Type parameters with bounding types</h3>
<p>In above example, the type parameter can be any types. But sometimes, we need guarantee that the supplied type parameters have some common features, such as has a common function.</p>
<h4>Solution</h4>
<pre class="brush:java">
public class GenericBound&lt;T extends InterFace>
</pre>
<p>The InterFace is called bounding types.</p>
<h4>Generic Interface</h4>
<pre class="brush:java">
interface Numeric&lt;T>{
    T init();
    T Sum(T v);
    void print();
}
</pre>
<h4>Implement a generic interface</h4>
<pre class="brush:java">
class F implements Numeric&lt;F>{
    private int x;
    public F(int x){
        this.x =x;
    }
    @Override
    public F init(){
        return new F(0);
    }
    @Override
    public void print(){
        System.out.println(x);
    }
    }
    @Override
    public F Sum(F x){
        return new F(this.x + x.x);
    }
}
</pre>
<h4>The interface becomes</h4>
<pre class="brush:java">
interface Numeric{
    F init();
    F Sum(F v);
    void print();
}
</pre>
<h4>Use this interface</h4>
<pre class="brush:java">
public class GenericBound&lt;T extends Numeric&lt;T>> 
</pre>
</div>
</li>
<li>
<div class="content" id="wildcard">
<h3>Wildcard Generic</h3>
<p style="color:red">Employee is a super class of Manager, but Generic&lt;Employee> is not a super class of Generic&lt;Manager> becuase Generic&lt;Manager> does not have Generic&lt;Employee>'s members.</p>
<div class="featureList">
    <ol>
        <li>
            <h4>Wildcard</h4>
            <p>With wildcard generic, a generic class can be assigned to another generic class according to the inheritance of the type parameters.</p>
            <pre class="brush:java">
                GenericClass&lt;? super Manager> gm = new GenericClass&lt;Employee>();
                GenericClass&lt;? extends Manager> gm2 = new GenericClass&lt;CEO>();
            </pre>
        </li>
        <li>
            <h4>Compared with C# covariance & contraviance</h4>
            <p>C# covariance & contraviance is defined on interface & delegate. It allows an implementations of a "specific generic interface or delegate" to be assigned to another "sepcific generic interface or delegate"</p>
            <pre class="brush:java">
                # what is a specific generic interface.
                interface IGreeting&lt;T>{
                    T Greet();
                }
                IGreeting&lt;Employee> // is a specific generic interface.
                IGreeting&lt;Manager> // is another specific generic interface.
            </pre>
            <p>Java's wildcard is similar but different from C# covariance and contraviance. Java's wildcard allows to assign an object of a generic class to a wildcard generic class type.</p>
        </li>
        <li>
            <h4>How to use?</h4>
            <p>Wildcard generic is usually used as parameters of a function.</p>
            <pre class="brush:java">
                public class Operation{
                    //  this method only works with GenericClass&lt;Employee>
                    public void Operate(GenericClass&lt;Employee> value){}
                    //  this method works with GenericClass&lt;Employee> GenericClass&lt;Manager> GenericClass&lt;CEO>
                    public void Operate(GenericClass&lt;? extends Employee> value){}
                }
            </pre>
            <p>Wildcard generic cannot be assigned to generic class.</p>
        </li>
        <li>
            <h4>unbound wildcard</h4>
            <p>GenericClass&lt;?> is same as GenericClass&lt;? extends Object></p>
        </li>
    </ol>
</div>
</div>
</li>
<li>
<div class="content" id="genericLimitation">
<h3>Limitation</h3>
<p>The generic feature is achieved by the compiler replacing generic type with Object, and insert type parameter for casting. Because of it's not runtime, this can cause following limitations:</p>
<div class="featureList">
<ol>
<li>
    <p>Cannot instantiate a type variable: because the <span class="inline-code">T t = new T()</span> is translated to <span class="inline-code">(T) t = (T) new Object()</span>. In contrast, C# allows to do that only if we guarantee the type parameter has a parameterless constructor.</p>
    <span style="color:red">Create type parameter's object</span>: give a type's Class from outside, and call newInstance.
    
    <pre class="brush:java">
        public static &lt;T> Pair&lt;T> makePair(Class&lt;T> cl)
        {
            try { return new Pair&lt;>(cl.newInstance(), cl.newInstance()) }
            catch (Exception ex) { return null; }
        }
    </pre>
</li>
<li>
    <p>Cannot access T.class. Same reason as above.</p>
</li>
<li>
    <p>Cannot do new T[10]</p>
</li>
</ol>
</div>
</div>
</li>

<li>
<div class="content" id="genericReference">
<h3>References</h3>
<div class="featureList">
<ol>
<li><a href="http://proquestcombo.safaribooksonline.com.ezp3.lib.umn.edu/9780137082346?uicode=umntc">Core Java Volume I. Ch12. Generic Programming.</a></li>
</ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
