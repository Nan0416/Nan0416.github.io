<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Java&nbsp;Introduction</title>
<meta charset="utf-8">
<meta name="date" content="2018-08-30">
<meta name="keywords" content="java">
<meta name="keywords" content="introduction">
<meta name="keywords" content="programming">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>

</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>Java&nbsp;-&nbsp;Introduction</strong>
</div>
<p class="date"><span class="created-date">Created:2018-08-30</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-08-02</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#introduction">Java Introduction</a></li>
<li><a href="#structure">Java Project Structure</a></li>
<li><a href="#command-line">Command lines</a></li>
<li><a href="#rule">Rules</a></li>
<li><a href="#reference">Reference</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
    <li>
        <div class="content" id="introduction">
            <h3>Java Introduction</h3>
            <p>Java: Object-Oriented Programming, Write-Once-Run-Anywhere</p>
            <p>.java code -> (javac) -> .class bytecode -> (java) -> JVM run</p>
            <p>Born in 1995, James Gosling, Sun Microsystems</p>
            <h4>JDK (Java Development Kit): A tool sets include JVM, and programming tools, standard packages.</h4>

            <p>one feature released every 6 months. (6月一小更）</p>
            <p>
                <img src="./img/javaversion.png" width="600" height="500">
            </p>
            <h4>JIT (Just in Time compilation)</h4>
            <p>Java code is compiled into bytecode, and the bytecode is interperted by JVM. It is slower than running machine code directly in a CPU. So JIT comes in. 
                JIT will compile the most frequently used bytecode (-XX:CompileThreshold=5 set the frequency to 5) and compile it to machine code.</p>
            <p>The name of Java JIT is HotSpot, JIT is part of the JVM</p>
            <p>Granularity of JIT is in function level.</p>
            <pre class="brush:bash">
                java -client -Xbatch -XX:+PrintCompilation ClassName
                #print the info if JIT is involved.
                #-client: make sure to run in client mode.
                #-XX:+PrintComiplation: print compile info
                #-Xbatch: make output serially, not concurrently. In other words, JIT compilation will block the program execution.
            </pre>
            <div class="featureList">
                <ol>
                    <li>JDK1.1: Inner class, limited reflection, JavaBean, rmi, JDBC</li>
                    <li>J2SE 1.2: strictfp, Swing, JIT compiler, collections package</li>
                    <li>J2SE 1.3: modified RMI</li>
                    <li>J2SE 1.4: exception chain, IPv6, assertion(断言）</li>
                    <li>J2SE 5 (2004, 09, 30): generics, annotation, autoboxing, enumeration, for each loop, static import
                        <br> 5 is product version, 1.5 is developer version
                    </li>
                    <li>J2SE 6:</li>
                    <li>J2SE 7: lambda expression</li>
                    <li>J2SE 8 (2014, 03, 18)</li>
                    <li>J2SE 9: AOT (ahead-of-time compilation); modularity.</li>
                    <li>Java SE 10: local var keyword;</li>
                    <li>Java SE 11: the current long term support Java.</li>
                </ol>
            </div>
            <div class="featureList">
                <h4>Java EE</h4>
                <ol>
                    <li>Java SE is for small scale development, e.g. a desktop application. Java EE is for server-side large scale programming, which defines more standard (Interface) e.g. servlet</li>
                    <li>JSR-369 (Java Specification Requests, A Java Community Process) defines the standard of Servlet container and Servlet. Including lifecycle, common APIs.</li>
                </ol>
                <h4>Java Language Specification</h4>
                <p>Java language specification is a standard. It can have multiple implementations, e.g. Oracle JRE (HotSpot), JDK and OpenJDK.</p>
            </div>
        </div>
    </li>
<li>
<div class="content" id="structure">
    <h3>Java Project Structure</h3>
    <p>Java uses "package" to organize code, it's a logic organization, like C# and C++'s namespace. The difference is that the "package" is not only expressed with 
        <span class="inline-code">package com.company.feature</span> but also the physical directory hierarchy.</p>
    <p>A java's code is compiled into Bytecode .class, and then compiled into a library .jar file.<span style="color:red">Different from C# that a namespace can cross multiple .dll assembly, Java package cannot cross multiple .jars.</span>/p>
    <div class="featureList">
        <ol>
            <li>
        <h4>Package example</h4>
        <pre>
        /directory1
            /directory2
                /directory3
                    Xxxx.java
        </pre>
        <pre class="brush:java">
            package directory1.directory2.directory3;
            import ....;
            // java.lang.* is imported by default.
            /* Common class defined by java.lang,
                String, Boolean, ....
                Math, Object, Thread, Void,
                Exception, ArithmeticException
            */ 
            public class Xxxx{
                public static void main(String [] args){

                }
            }
        </pre>
            </li>
        </ol>
    </div>
    
</div>
</li>
<li>
    <div class="content" id="command-line">
        <h3>Command lines</h3>
        <p>
            javac: compile .java to .class<br>
            jar: package .clas to .jar and unpackage .jar<br>
            java: run 
        </p>
        <div class="featureList">
            <ol>
                <li>
                        <h4>Compiling with external .jars, multiple sources, and a desginated output.</h4>
                        <p>-cp or -classpath: 3rd party jars<br>
                           -d: output location
                        </p>
                        <pre class="brush:bash">
                            javac -cp ".:../../jars/*" 
                            ../src/umn/dcsg/wieralocalserver/*.java 
                            ../src/umn/dcsg/wieralocalserver/datadistribution/*.java 
                            ../src/umn/dcsg/wieralocalserver/storageinterfaces/*.java 
                            -d ../../out/production/wieraLocal
                        </pre>
                </li>
                <li>
                    <h4>jar packaging</h4>
                    <p>When packaging a project to a .jar, a manifest will be included into the jar. If the package is a library, then we can let jar generate the manifest file. 
                        But if the project has the main entry, we have to indicate the entry in the manifest file.</p>
                    <p>The manifest file (MAINFEST.MF) should at least include the following line to indicate the main entry.</p>
                    <pre class="brush:bash">
                        Main-Class: classname
                    </pre>
                    <pre class="brush:bash">
                        # jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files ...
                        # -c create new archieve
                        # -m include a manifest file
                        # -v verbose mode 
                        # -f output name
                        jar cmvf MANIFEST.MF output.jar -C output/ ./Nan/Review/Program.class

                        # -C the directory that contains compiled packages.
                    </pre>
                </li>
                <li>
                    <h4>jar unpacking</h4>
                    <p>Unpacking is useful because some 3rd party libraries also include their documentation inside the .jar file. Download some source code from Maven repo. Unpack it with jar to look through source code and read documents</p>
                    <p>Two versions of jars are available in the maven repo, .jar and javadoc.jar.
                        <br><span style="color:red">The javadoc.jar contains the generated java doc.</span>
                    </p>
                    <pre class="brush:bash">
                        #unpack
                        jar -xf javadoc.jar 
                        # -x extract files from the archive. 
                        # -f give the archive .jar name.
                    </pre>
                </li>
                <li>
                    <h4>java start program</h4>
                    <pre class="brush:java">
                        # start a .class file
                        java -cp "../../jars/*:../../out/production/wieraLocal/"  umn.dcsg.wieralocalserver.LocalServer
                        # start a jar file that has a manifest
                        java -jar output.jar
                    </pre>
                </li>
            </ol>
        </div>
    </div>
</li>
<li>
    <div class="content" id="rule">
        <h3>Rules</h3>
        <div class="featureList">
            <ol>
                <li>
                    <h4>Package</h4>
                    <p>Java organizes code as packages. Packages are not only the logic partition of code functionalities, but also physical partition on code distribution. Multiple packages can be compiled into a single .jar. But a single package cannot exist in multiple jars.
                            In contrast, C# uses namespace as a logic partition, and .dll assembly for code distribution. A namespace can cross multiple .dll, a .dll can have multiple namespaces.</p>
                </li>
                <li>
                    <h4>.java file</h4>
                    <p>Each .java file must have and only have one public class, or enum, or interface definition. And the type name must same as the filename. A .java can have multiple non-public class definition.</p>
                </li>
            </ol>
        </div>
        
    </div>
</li>
<li>
<div class="content" id="reference">
    <h3>References</h3>
    <div class="featureList">
        <ol>
            <li><a href="https://en.wikipedia.org/wiki/Java_(programming_language)" target="_blank">Java Wiki</a></li>
            <li><a href="https://en.wikipedia.org/wiki/Java_version_history" target="_blank">Java Version History</a></li>
            <li><a href="https://docs.oracle.com/javase/tutorial/deployment/jar/manifestindex.html" target="_blank">Working with Mainfest files</a></li>
        </ol>
    </div>
   
</div>
</li>

</ol>
</div>
    
</body>
</html>
