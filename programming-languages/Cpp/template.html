<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>C++&nbsp;Template</title>
<meta name="date" content="2019-03-19">
<meta name="keywords" content="template">
<meta name="keywords" content="call&nbsp;by&nbsp;reference">
<meta name="keywords" content="C++">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>C++&nbsp;-&nbsp;Template</strong>
</div>
<p class="date"><span class="created-date">Created:2019-03-26</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-11-29</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#intro">Comparison: C++, Java, C#</a></li>
<li><a href="#examples">C++ Template</a></li>
<li><a href="#collection">Collections</a></li>
<li><a href="#reference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="rvIntro">
<h3>Comparison</h3>
<p>Reusable code: function provides value/reference as parameter, generics provides type as parameter.</p>
<h4>Implementation</h4>
<div class="featureList">
    <ol>
        <li>C++ [compile time feature] compiler generates separate source code for each declared types.</li>
        <li>Java [compile time feature] compiler provide compile-time syntax checking and insert necessary casting.</li>
        <li>C# [runtime feature]</li>
    </ol>
</div>
</div>
</li>
<li>
    <div class="content" id="examples">
        <h3>C++ Template</h3>
        <div class="featureList">
            <ol>
                <li>
                    <h4>Auto inference</h4>
                    <p>C++ can automatically infer the type from the given input. But type should be provided if the compiler cannot infer.</p>
                    <pre class="brush:cpp">
template &lt;class T>
T sum (T a, T b)
{
  return a + b;
}
int main () {
    int r1 =sum&lt;int>(10,10);
    int r2 = sum(10, 10); // auto inference.
    double r3 = sum&lt;double>(10.2, 10); // since the right argument 10 is int, compiler cannot interpret the right type.
    return 0;
}
                    </pre>
                    <p>If the explicit type is given, then it always uses the template function even if there is a regular function with the corresponding type. (see below).</p>
                </li>
                <li><h4>native function vs. generic function</h4>
                <p>
                    Generic function and regular function with the same name can co-exist. When invoking the function with the right type, the regular function has a higher priority.<br>
                    using "nm a.out" to check the symbol table
                </p>
                <pre class="brush:cpp">
template &lt;class T>
void swap_values(T & var1, T & var2){
    T temp = var2;
    var2 = var1;
    var1 = temp;
}
void swap_values(char & s1, char & s2){ }
int main(){
    int x = 1, y = 10; double dx = 0.3, dy = 3.4; 
    char letter = 'q';
    swap_values(x, y);           // __Z11swap_valuesIiEvRT_S1_
    swap_values(dx, dy);         // __Z11swap_valuesIdEvRT_S1_
    swap_values(letter, letter); // __Z11swap_valuesRcS_ (native function has the highest priority)
    return 0;
}
                </pre>
                </li>
                <li>
                    <h4>Principle 2</h4>
                    <p>After convert template source code to source code without template, C++ do the default casting.</p>
                    <pre class="brush:cpp">

#include &lt;string>
using namespace std;

int inc(int i) {return i+1;}; // c++ cast double to int, c++ cannot cast string to int. So it cause error.

template &lt;class T>
void swap_values(T & var1, T & var2){
    T temp = inc(var2);
    var2 = var1;
    var1 = temp;
}

int main(){
    double dx = 0.3, dy = 3.4; 
    string name = "qinnan";
    swap_values(dx, dy);     
    //swap_values(name, name);
    return 0;
}
                    </pre>
                </li>
                <li>
                    <h4>Class Template</h4>
                    <p>Template class need explicitly supply type parameter, but template function does not need to supply the used class.</p>
                    <pre class="brush:cpp">
#include &lt;string>
template &lt;class K, class V>
class Pair{
private:
    K key; V value;
public:
    Pair(K key, V value){
        this->key = key; 
        this->value = value;
    }
    template&lt;class T>
    void add(T t){}
};

int main(){
    // type has to be supplied here. template function does not need to supply the used class.
    Pair&lt;std::string, int> p("one", 1);
    p.add('q');
}
                    </pre>
                </li>
                <li>
                    <h4>Nested Template</h4>
                    <p>Nested template happens when the type parameter also be a type with template</p>
                    <pre class="brush:cpp">
template &lt;template &lt;typename , typename > class P, typename T>
void add(P&lt;int, int> p, T t){
    p.add(t);
}
                    </pre>
                    <p>1). typename and class can interchangable in most cases.<br>
                    2). The outter layer template defined two type parameter, P and T<br>
                    3). The type parameter, P, is a template class that has two type parameters.<br>
                    <span style="color:red">4). the outter layer function "add" cannot access and infer inner type parameters</span></p>
                    <pre class="brush:cpp">
int main(){
    // type has to be supplied here. template function does not need to supply the used class.
    Pair&lt;int, int> p(100, 100);
    add(p, "string");
}
                    </pre>
                </li>
                <li>
                    <h4>Type member</h4>
                    <p>C++ standard template library collections have a convention to use a "style" to define type member, which use "typedef" inside a class.</p>
                    <pre class="brush:cpp">
                    class unordered_map
                    {
                    public:
                        typedef typename std::pair&lt;_Key, _Tp> value_type;
                        // ...
                    }
                    unordered_map&lt;std::string, int>::value_type // same as
                    pair&lt;std::string, int>
                    </pre>
                </li>
                <li>
                    <h4>Template specialization</h4>
                </li>
            </ol>
        </div>
    </div>
</li>
<li>
    <div class="content" id="collection">
        <h3>Collections (STL)</h3>
        <p>C++ STL (standard template library) is a set of C++ template classes that provide common programming data structures and functions. It contains 4 components<br>
            containers: vector, list, queue, set, unordered_set, map, unordered_map
            algorithms: sort, search
            iterators:
            higher order functions:
        </p>
        <p>Each collection is defined in a separate header file.</p>
        <div class="featureList">
            <ol>
                <li>
                    <h4>pair & unordered_map</h4>
                    <p>C++ unordered_map is the hashmap in Java. unordered_map uses a pair to represent the relationship with a key and its associated value.</p>
                    <p>pair class is defined in utility header, unordered_map in unordered_map header. both of them under the "std" namespace.</p>
                    <h4>hash function</h4>
                    <p>Different from Java that the key object has a hash function, C++ map has to build its own hash function for each key type.</p>

                    <pre class="brush:cpp">
                        #include &lt;functional>
                        template &lt;class Key>
                        struct hash
                        {
                            size_t operator()(const Key& p) const = 0; // overload () operator.
                        }
                        
                        // define a template specialization in the same namespace, where the unordered_map can automatically find this hash.
                        namespace std{
                            template&lt;>
                            struct hash&lt;Point>
                            {
                                size_t operator()(const Point& p) const
                                {
                                    return p.x + p.y;
                                }
                            };
                        }
                        namespace myspace{
                            struct MyPointHash
                            {
                                size_t operator()(const Point& p) const
                                {
                                    return p.x + p.y;
                                }
                            };
                        }
                        std::unordered_map&lt;Point, int> po; // use the std namespace defined hash by default.
                        std::unordered_map&lt;Point, int, myspace::MyPointHash> po2; // specify a new hash.
                    </pre>
                    <p>
                        The hash function are not guarantee by convention instead of language syntax. For example, there is no syntax err even if the () operator is not overloaded. 
                        <span style="color:red">But the unordered_map has a "assert" to throw a compile error.</span>
                    </p>
                    <pre class="brush:cpp">
    std::unordered_map&lt;std::string, int> numbers;
    std::unordered_map&lt;std::string, int>::hasher fn = numbers.hash_function(); // each map type has a type member called hasher.
    std::cout &lt;&lt; fn("qinnan") &lt;&lt; std::endl; // 15450536227608294505
                    </pre>
                    <p>C++ standard library provides hash function for primitive types and address type, different string, thread::id, and so on. <a href="http://www.cplusplus.com/reference/functional/hash/" target="_blank">http://www.cplusplus.com/reference/functional/hash/</a></p>
                    <h4>functions & loop</h4>
                    <pre class="brush:cpp">
                        std::unordered_map&lt;std::string, int> numbers;
                        .insert(std::pair&lt;std::string, int>("one", 1)); // insert a pair.
                        []; // read,update,insert *** return a reference *** mapped_type& operator[] ( key_type&& k );
                        .at(key) // throw error if not exist.
                        .empty(); // return bool, check if the map is empty
                        .size(); // return size_type, size_t
                        .count(key); // return number of value associated with the key, 0 or 1. same as java containsKey
                        .clear();

                        for(auto it = numbers.begin(); it != numbers.end(); it++){
                            std::cout &lt;&lt; it->first &lt;&lt; ":" &lt;&lt; it->second &lt;&lt; std::endl;
                        }
                        // c++11
                        for(std::pair&lt;std::string, int> p: numbers){
                            std::cout &lt;&lt; p.first &lt;&lt; p.second &lt;&lt; std::endl;
                        }
                        // c++17
                        for(auto & [key, val]: numbers){
                            std::cout &lt;&lt; key &lt;&lt; val &lt;&lt; std::endl;
                            val = 10; //mutable reference
                        }
                    </pre>
                </li>
                <li><h4>Vector: (Java ArrayList)</h4>
                    <p>vecots use contiguous storage locations but with dynamic size. O(1) access, amortized O(1) for insertion.</p>
                    <p>When using value type, the default constructor and copy constructor are implicitly invoked.</p>
                    <pre class="brush:cpp">
#include &lt;iostream>
#include &lt;vector>
using namespace std;
class P{
public:
    P(){cout &lt;&lt; "Default P constructor" &lt;&lt; endl;}
    P(const P& p) {cout &lt;&lt; "Copy constructor" &lt;&lt; endl;}
    P & operator = (const P & p) { 
        cout &lt;&lt; "Assignment operator" &lt;&lt; endl ; 
        return *this;
    }
    void print(){ cout &lt;&lt; "print()" &lt;&lt; endl;}
};
int main(){
    vector&lt;P> vp;
    vp.resize(10); // resize the container. Default P constructor * 10.
    P p1;
    vp.push_back(p1); // Copy constructor * 5
    vp.push_back(p1);
    vp.push_back(p1);
    vp.push_back(p1);
    vp.push_back(p1);
}
                    </pre>
                    <h4>functions</h4>
                    <pre class="brush:cpp">
                        .size()
                        .capacity()
                        .push_back()
                        .pop_back()
                        .insert()
                        .clear()

                        // iterators
                        .begin(); .end()  // ::iterator
                        .cbegin() .cend()
                    </pre>

                    <h4>Sorting</h4>
                    <p>Sorting in C++ is done by a generic "sort" function defined in "algorithm" header.</p>
                    <p>There are two versions of sorting, using object's "&lt;" operator to compare or using a dedicated function to compare.</p>
                    <pre class="brush:cpp">
                        template&lt;class RandomAccessIterator>
                        void sort(RandomAccessIterator first, RandomAccessIterator last); // using &lt; operator.

                        template&lt;class RandomAccessIterator>
                        void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp); 
                        // Compare is an object/function takes two argument, return a bool.

                        // sort function use iterator to do in-place sort.
                        std::sort(numbers.begin(), numbers.end());
                        // sort with a lambda (-std=c++11), the final state makes (a, b) -> true, which results in descending order.
                        std::sort(numbers.begin(), numbers.end(), [](const int &a, const int &b) -> bool { return a > b;});
                    </pre>
                </li>
                <li>
                    <h4>unordered_set</h4>
                    <p>Same as unordered_map, unordered_set utilizes the default hasher function.</p>
                    <pre class="brush:cpp">
                        // constructor.
                        std::unordered_set&lt;std::string> first;
                        std::unordered_set&lt;std::string> second = {"alpha","beta","gamma"};
                        std::unordered_set&lt;std::string> third ( {"red","green","blue"} ); 
                        std::unordered_set&lt;std::string> fourth ( third ); 

                        .empty() // return bool indicates if the set is empty.
                        .size()  // return size_type (size_t)

                        .find(const key_type & key); // return iterator of the given key, if not found, return the iterator of end.
                        .count(const key_type & key); // return size_type 1 or 0.

                        .insert(const value_type & value); 
                        .erase(const key_type& k) ; // return number of elements ereased, either 1 or 0.
                        .clear(); 

                        .begin()
                        .end()
                        .cbegin()
                        .cend()

                    </pre>
                </li>
                <li>
                    <h4>list & deque</h4>
                    
                </li>
                <li>
                    <h4>queue & priority_queue</h4>
                    <p>std's queue header defines "queue" and "priority_queue"</p>
                    <h4>queue</h4>
                    <p>queue is a FIFO queue. Different from Java, C++ queue is a container adaptor, meaning C++ queue doesn't define how to store data, it only define the FIFO operation.</p>
                    <p>The default container is deque, but can be replaced by list. <span style="color:red">the containe type must define function of "pop_front" & "pop_back". For example, vector class cannot be used here.</span></p>
                    <p><span style="color:red">C++'s pop doesn't return the value, it only removes the value.</span></p>
                    <pre class="brush:cpp">
                        #include &lt;queue>
                        // template &lt;class T, class Container = deque&lt;T>> class queue;
                        .push(T t);
                        .pop();

                        .front(); // retrieve the first value "reference";
                        .back(); // retrieve the last value "reference";

                        .size();
                    </pre>
                    <h4>priority_queue</h4>
                    <p>priority queue's comparator less&lt;T></p>
                    <p>less is a template (generic) struct defined in "functional" header, internally, it uses the &lt; operator. Other classes have "greater", "plus", ... 
                        This kind of classes is called operator class, which basically wrap an operator to a struct. The goal of this struct is to give as a template parameter.
                    </p>
                    <pre class="brush:cpp">
                        template &lt;class T> 
                        struct less : binary_function &lt;T,T,bool> {
                            bool operator() (const T& x, const T& y) const {return x &lt; y;}
                        };
                    </pre>
                    <pre class="brush:cpp">
                        #include &lt;queue>
                        // template &lt;class T, class Container = vector&lt;T>, class Compare = less&lt;typename Container::value_type>> 
                        // class priority_queue;
                        std::priority_queue&lt;int> first;

                        // greater makes the greatest value be the last one to pop.
                        std::priority_queue&lt;int, vector&lt;int>, greater&lt;int>> b_queue;

                        struct myless{
                            bool operator()(const int & a, const int & b){
                                return a &lt; b;
                            }
                        };
                        std::priority_queue&lt;int, std::vector&lt;int>, myless> q;
                    </pre>
                </li>
            </ol>
        </div>
    </div>
</li>
<li>
    <div class="content" id="reference">
        <h3>References</h3>
        <div class="featureList">
            <ol>
                <li><a href="http://www.cplusplus.com/reference/" target="_blank">Standard C++ Library Reference</a></li>
                <li><a href="https://stackoverflow.com/questions/2023977/difference-of-keywords-typename-and-class-in-templates" target="_blank">Difference of keywords typename and class in templates?</a></li>
                <li><a href="https://www.geeksforgeeks.org/the-c-standard-template-library-stl/" target="_blank">The C++ Standard Template Library (STL)</a></li>
            </ol>
        </div>
        
    </div>
</li>
</ol>
</div>
</body>
</html>
