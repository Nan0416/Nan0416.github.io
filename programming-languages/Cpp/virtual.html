<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>C++&nbsp;Virtual & Abstract & Inheritance</title>
<meta charset="utf-8">
<meta name="date" content="2017-12-28">
<meta name="keywords" content="c++">
<meta name="keywords" content="virtual function">
<meta name="keywords" content="abstract">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>C++&nbsp;-&nbsp;Virtual functions & Abstract class</strong>
</div>
<p class="date"><span class="created-date">Created:2018-01-19</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-03-19</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#virtual">Virtual Functions</a></li>
<li><a href="#abstract">Abstract Class (Interface)</a></li>
<!--<li><a href="#virtualReferences">References</a></li>-->
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="virtual">
<h3>Virtual Functions</h3>
<p>Virtual function (A special override) achieved a runtime polymorphism instead of compile-time. [late binding]</p>
<p>It allowes a child class object but is declared as parent class to call the child functions.</p>
<p>Only accessing via <span style="color:red">pointer or reference</span> of parent type can achieve the runtime polymorphism.</p>
<p> for deconstructor</p>
<div class="featureList">
<h4>Features</h4>
<ol>
<li>Only parent class need the virtual keyword</li>
<li>No virtual member variables</li>
<li>Private/Protected modifier is static, but virtual function is dynamic.</li>
<li>virtual functions can be defined as public, protected or private in the Parent class. But Attention: modifier is static even with a pointer or reference type</li>
</ol>
<h4>Examples</h4>
<ol>
<li>
    <h4>Basic</h4>
<pre class="brush: cpp">
        #include &lt;iostream>
        using namespace std;

        class Parent{
        public:
            Parent() {
                cout &lt;&lt; "Parent constructor" &lt;&lt; endl;
            }
            void display() {
                cout &lt;&lt; "Parent display" &lt;&lt; endl;
            }
            virtual void virtualDisplay() {
                cout &lt;&lt; "Parent virtual display "  &lt;&lt; endl;
            }
        };
        
        class Child: public Parent{
        public:
            Child() {
                cout &lt;&lt; "Child Constructor" &lt;&lt; endl;
            }
            void display() {
                cout &lt;&lt; "Child display" &lt;&lt; endl;
            }
            void virtualDisplay() {
                cout &lt;&lt; "Child virtual display "  &lt;&lt; endl;
            }
        };

        void callByReference(Parent &amp; p){
            p.virtualDisplay();
        }
        void callByValue(Parent p){
            p.virtualDisplay();
        }
        int main(){
            Child c; // "Parent constructor /n Child constructor"
            Parent p2 = c; /* it is just an assignment, but p2 is staticly bind to c's inherited parent method*/
            Parent * p = &amp;c;
            p->display(); // Parent display
            p->virtualDisplay(); // Child virtual display
            p2.virtualDisplay(); // Parent virtual display
            
            callByReference(c); //Child virtual display
            callByValue(c); //Parent virtual display
            return 0;
        }
</pre>
</li>
<li>
<h4>Protected virtual function: provide an encapsulation</h4>
<pre class="brush: cpp">
        #include &lt;iostream>
        using namespace std;
        class Parent{
        public:
            Parent();
            void display();
        protected:
            virtual void virtualDisplay();
        };
        Parent::Parent(){
            cout &lt;&lt; "Parent constructor" &lt;&lt; endl;
        }
        void Parent::display(){
            // do something
            virtualDisplay();
            // do something
        }
        void Parent::virtualDisplay(){
            cout &lt;&lt; "Parent virutal display" &lt;&lt; endl;
        }
        //========
        class Child: public Parent{
        public:
            Child();
        protected:
            void virtualDisplay();
        };
        Child::Child(){
            cout &lt;&lt; "Child Constructor" &lt;&lt; endl;
        }
        
        void Child::virtualDisplay(){
            cout &lt;&lt; "Child virtual display "  &lt;&lt; endl;
        }
        void callByReference(Parent &amp; p){
            p.display();
        }
        void callByValue(Parent p){
            p.display();
        }
        int main(){
            Child c; // Parent constructor /n Child constructor
            Parent p2 = c;
            Parent * p = &c;
            p->display(); // Child virtual display
            callByReference(c); //Child virtual display
            callByValue(c); //Parent virtual display
            return 0;
        }
</pre>
</li>
<li>
<h4>Static binded modifier</h4>
<p><a href="./program/virtualPrivate.cpp">Source code</a></p>
<pre class="brush: cpp">
#include &lt;iostream>
using namespace std;
class F{
private:
    virtual void func(){cout &lt;&lt; "Parent Private virtual function" &lt;&lt; endl;}

};
class E: public F{
public:
    void func(){cout &lt;&lt; "Child Public virtual function" &lt;&lt; endl;}

};
int main(){
    E e;
    F * f = &amp;e;
    e.func();
    //f->func(); private modifer static bind
}
</pre>
</li>
</ol>
</div>
</div>
</li>


<li>
<div class="content" id="abstract">
<h3>Abstract Class (Interface)</h3>
<p>Abstract class in C++ is similar to Java but without using abstract keyword. In C++, abstract class is achieved throught the virtual function. (C++ does not have interface)</p>
<pre class="brush: cpp">
    virtual void abstractFunction() = 0; // pure virtual function
</pre>
<h4>Pure virtual function</h4>
<p>In the parent declaration, we add a "= 0" after the virtual function, then the virtual function becomes a pure virtual function</p>
<p>Pure virtual function is like java's abstract function, where we don't need to implement the function inside the parent class, and the 
    parent class is not instantiatable. Subclass may implement this function if they want to be instantiated.</p>
<pre class="brush: cpp">
class Parent{
    public:
        virtual void func() = 0;
        virtual void func2() const = 0; // virtual function cannot modify the value of this object
}
class Child{
    public:
        void func() override; // keyword comes from -suggest-override
        void func2() const override;
}
// In the .cc file, the "override" is not required, but const is still needed.
// override is a mark, const is part of the signature.
</pre>
<div class="featureList">
<h4>Abstract class features</h4>
<ol>
<li>An abstract class: a class has at least one pure virtual function</li>
<li><span style="color:red">It is a compilation error to create an object of an abtract class.</span></li>
<li>The drived class must implement parent pure virtual function, otherwise it is still an abstract class. <span style="color:red">
Even if the virtual function is defined as a private function and it is not visible to the child class, the child class also has to implement it.
</span></li>
</ol>
</div>


</div>
</li>
</ol>
</div>
    
</body>
</html>
