<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>C++&nbsp;Const</title>
<meta charset="utf-8">
<meta name="date" content="2018-01-30">
<meta name="keywords" content="const">
<meta name="keywords" content="C++">
<meta name="keywords" content="keyword">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>System&nbsp;-&nbsp;System&nbsp;control</strong>
</div>
<p class="date"><span class="created-date">Created:2018-01-30</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-03-19</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#ref">Reference Variables</a></li>
<li><a href="#constExample">Const</a></li>
<li><a href="#constCascade">Const Cascade</a></li>
<li><a href="#constArgument">Const as arguments</a></li>
<li><a href="#constReference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
    <div class="content" id="ref">
        <h3>Reference Variables</h3>
        <p>Call by value is the common suition. When encountering a function call, the argument is copyied onto the stack. Even if the function modifies the value, it will
        not reflect to the variable that is outside the function. So the original value is isolated. The disadvantage of call-by-value is that it requires <mark>more memory and time</mark> to copy the value.</p>
        <p>Call by reference is like an alias of the original variable. Usually it is used in the function argument, but it can be used to declare variable. It is just like a pointer in C. (C does not have reference variable.)
        Because of its nature, it does not isolate the original value. Just like a pointer, all modification made inside a function would reflect into the original variable. Its advantage is <mark>faster and less memory</mark>.
        </p>
        <p><span style="color:red">Same as pointer, it also can invoke the virtual functions.</span></p>
        <div class="featureList">
            <ol>
                <li>
                    <h4>Reference Variables In Function Arguments</h4>
                        <a href="./program/callByVR.cpp">Source code</a>
                        <pre class="brush: cpp">
                        #include &lt;iostream&gt;
                        using namespace std;
                        //////// an example class ////////
                        class Testing{
                        private:
                            int x;
                        public:
                            int get() { return x; }
                            void set(int x) {this->x = x;}
                        };
                        
                        //call by reference
                        void incByRef(Testing &amp; t){
                            t.set(t.get()+1);
                        }
                        //call by value
                        void incByVal(Testing t){
                            t.set(t.get()+1);
                        }
                        int main(){
                            Testing t;
                            t.set(1);
                            cout &lt;&lt; "before call incByRef " &lt;&lt; t.get() &lt;&lt; endl; // 1
                            incByRef(t);
                            cout &lt;&lt; "after call incByRef " &lt;&lt; t.get() &lt;&lt; endl; // 2
                            incByVal(t);
                            cout &lt;&lt; "after call incByVal " &lt;&lt; t.get() &lt;&lt; endl; // 2
                            Testing &amp; reft = t; // declare an alias. Usually it is not meaningful
                            cout &lt;&lt; "before call incByRef(reft) " &lt;&lt; t.get() &lt;&lt; endl; // 2
                            incByRef(reft);
                            cout &lt;&lt; "after call incByRef(reft) " &lt;&lt; t.get() &lt;&lt; endl; // 3
                            return 0;
                        }
                        </pre>
                </li>
                <li>
                    <h4>Return a reference variables</h4>
                    <p>Return a reference of an object to the scope that the object does not exist would cause warning but not error.</p>
<p class="starMark">* The effect is same as returning a pointer from a stack object.</p>
<p>However, if the scope of the object is allowed, then it is ok. For example, return *this in a class member function because the object itself is outside its member function.</p>
<p><a href="./program/return_reference.cpp">Source code</a></p>
<pre class="brush: cpp;">
#include &lt;iostream>
using namespace std;

class F{
public:
    int x = 0;
};
//warning: reference to stack memory associated with local variable 'f' returned [-Wreturn-stack-address]
F&amp; return_reference(){
    F f;
    f.x = 1;
    return f;
}
//warning: address of stack memory associated with local variable 'f' returned [-Wreturn-stack-address]
F* return_address(){
    F f;
    f.x = 1;
    return &f;
}
//allowed 
F* return_out(F&amp; f){
    return &f;
}
int main(){
    F *fa = return_address();
    cout &lt;&lt; fa->x &lt;&lt; endl;
    F fr = return_reference();
    cout &lt;&lt; fr.x &lt;&lt; endl;
}
</pre>
                </li>
            </ol>
        </div>
    </div>
</li>
<li>
<div class="content" id="constExample">
<h3>Const</h3>
<div class="featureList">
<h4>Advantages</h4>
<ol>
<li>Safety: avoid unintentionally to modify variables.</li>
<li>Performance: compiler can optimze the code with const because compiler do not need to worry about multi-thread.</li>
</ol>
</div>
<div class="featureList">
<h4>Usage cases</h4>
<ol>
<li>const reference of static/non-static non-member function arguments e.g. void print(const string &amp; s); It help to enforce string s cannot be modified inside the function.</li>
<li>const non-static member function [<i>see example 2</i>]</li>
<li><del>const static member function</del> [<i>see example 3</i>]</li>
<li><span style="color:red">const static/non-static member/non-member variables must be set a value when declaring.</span>e.g. const int t = 5;</li>
<li>const pointer [<i>see example 1</i>]</li>
</ol>
</div>

<div class="featureList">
<ol>
<li>
<h4>Const pointer</h4>
<p>There are two type of const pointers. 1) cannot modify the data that is pointed by the pointer; 2) cannot modify where the pointer is pointing.<br>
The first case is just like a reference, program can modify the pointer's value (address) but not the content pointed by pointer. (type const *)<br>
The second case treats the pointer as a regular variable that stored an address, and the address cannot be modified. (type * const)</p>
<p>
<h4>The pointer's content cannot be modified, but the ptr can point to a new data location. (type const *)</h4>
<pre class="brush: cpp">
        #include &lt;iostream>
        using namespace std;
        
        int main(){
            int container = 0;
            int const * const_value_pointer = &container;
            int * value_pointer = &container;
            cout &lt;&lt; container &lt;&lt; *const_value_pointer &lt;&lt; *value_pointer &lt;&lt; endl; // 000
            container++;
            (*value_pointer)++;
            cout &lt;&lt; container &lt;&lt; *const_value_pointer &lt;&lt; *value_pointer &lt;&lt; endl; // 222
            int another_container = -1;
            const_value_pointer = & another_container;
            cout &lt;&lt; *const_value_pointer &lt;&lt; endl;// -1
            
            return 0;
        }

</pre>
<h4>The pointer itself cannot be modified, but its content can be modified. (type * const)</h4>
<pre class="brush: cpp">
#include &lt;iostream>
using namespace std;
class F{
public:
    int x;
    F(){
        x = 10;
    }
};

int main(){
    // pointer as a variable
    F g, h;
    F * const f = &g; // f always binds to g
    cout &lt;&lt; g.x &lt;&lt; endl;
    f->x = 11;
    cout &lt;&lt; g.x &lt;&lt; (*f).x &lt;&lt; endl;
    //f = &h; cannot assign to variable 'f' with const-qualified type 'F *const'
    return x;
}
</pre>
</p>
</li>
<li>
<h4>const non-static member function</h4>
<p>In non-member function, only the arguments are considered to be constant or not. If yes, simple add a const before it. However, an implicit "this" 
is passed into member function in the non-static situation; How to guarantee "this" not to be changed is a new issue in member functions. And this is handled by const keyword after the member function's declaration and definition. 
</p>
<p style="color:red">With a const after function, the member variable cannot be modified. It is same like add a const before "this".</p>
<p class="starMark">* Both declaration and definition need the const keyword.</p>
<p><a href="./program/const_member_function.cpp">Source code</a></p>
<pre class="brush:cpp">
#include &lt;iostream>
using namespace std;

class F{
public:
    int x = 11;
    void get(int &amp;y) const;
    
};
void F::get(int &amp;y) const{
    y = x; // y is still mutable
    // x++; //cannot assign to non-static data member within const member function 'get'
}
int main(){
    F f;
    int y;
    f.get(y);
    cout &lt;&lt; y &lt;&lt; endl;
    return 0;
}
</pre>
</li>
<li>
<h4><del>const static member function</del></h4>
<p>Static member functions don't need to use const keyword because it is same as a non-member (free) function. There is no <i>this</i> passed to it, and static member variables can be protected with their own const keyword.</p>
</li>
</ol>
</div>
</div>
</li>
<li>
<div class="content" id="constCascade">
<h3>Const Cascade</h3>
<p>Once a object is declared as const, its internal member variables also cannot be modified any more. Moreover, this relation is cascade, which means the non-primitive type member variable's member cannot be changed anymore.</p>
<p><span style="color:red">Pointers is dealt as a variable</span>, which means the content can be modified but the location that it points cannot be changed.</p>
<p>Moreover, the intial value has to be assigned in order to create a const object. So it must has a user-defined constructor or using the c++11 <i>in-class initialization of non-static data member</i>. </p>
<pre class="brush:cpp">
#include &lt;iostream>
using namespace std;
class G{
public:
    int x;
    G(){ // required by cascade initialization
        x = 1;
    }
};
class F{
public:
    int x = 1;
    int * y = new int(1);
    G g;
};
int main(){
    const F f;
    cout &lt;&lt; f.x &lt;&lt; *(f.y) &lt;&lt; endl;
    *(f.y) = 2;
    // f.g.x = 10; cascade
    //f.y = new int(2); cannot assign to variable 'f' with const-qualified type 'const F'
    cout &lt;&lt; f.x &lt;&lt; *(f.y) &lt;&lt; endl;
    return 0;
}
</pre>
</div>
</li>
<li>
<div class="content" id="constArgument">
<h3>Const as arguments</h3>
<p>Two types of them 1). function signature's argument as const 2). value is const</p>
<div class="featureList">
<ol>
<li>
<h4>Const in signature</h4>
<p>If function signature's arguments defined by a const, then either const or non-const value can be used.</p>
<pre class="brush: cpp">
#include &lt;iostream>
using namespace std;
class F{
public:
    int x;
    F(){
        x = 10;
    }
};
void foo(const F&amp; f){
    cout &lt;&lt; "const reference " &lt;&lt; f.x &lt;&lt; endl;
}
void foo(const F* f){
    cout &lt;&lt; "const pointer " &lt;&lt; f->x &lt;&lt; endl;
}
int main(){

    const F f;
    const F * g = new F();
    F t;
    F * u = new F();
    foo(f);
    foo(&amp;f);
    foo(t);
    foo(&amp;t);
    foo(*g);
    foo(g);
    foo(*u);
    foo(u);
    
    return 0;
}
</pre>
</li>
<li>
<h4>value is const</h4>
<p>The function signature indicates to use the reference or pointer type. However, the past arguments are const or pointing to const.
In this case, the function cannot be called. (no matching function).
</p>
<p class="starMake">* Once you have a const object, it cannot be assigned to a non-const reference or use functions that are known to be capable of changing the state of the object. [1]</p>
<p>It is meaningful. <span style="color:red">const variable narrow down the function it can invoke.</span></p>
<pre class="brush: cpp">
#include &lt;iostream>
using namespace std;
class F{
public:
    int x;
    F(){
        x = 10;
    }
};
void foo(F&amp; f){
    f.x++;
}
void foo(F* f){
    f->x++;
}
int main(){

    const F f;
    const F * g = new F();
    cout &lt;&lt; f.x &lt;&lt; g->x &lt;&lt; endl;
    //foo(f); no matching function for call to 'foo'
    //foo(g); no matching function for call to 'foo'
    cout &lt;&lt; f.x &lt;&lt; g->x &lt;&lt; endl;
    return 0;
}

</pre>
</li>
<li>
<h4>Mix - Summary</h4>
<p>Compiler's can distinguish void f(const Type&amp; ); and void f(Type&amp; ) in terms of declaration and calling. 
<br>const value can be used by both of them but prefer const signature.
<br>non-const value can only be used by non-const signature
</p>

<pre class="brush: cpp">
#include &lt;iostream>
using namespace std;
class F{
public:
    int x;
    F(){
        x = 10;
    }
};
void foo(const F&amp; f){
    cout &lt;&lt; "const reference " &lt;&lt; f.x &lt;&lt; endl;
}
void foo(F&amp; f){
    cout &lt;&lt; "non-const reference " &lt;&lt; f.x &lt;&lt; endl;
}
void foo(const F* f){
    cout &lt;&lt; "const pointer " &lt;&lt; f->x &lt;&lt; endl;
}
void foo(F* f){
    cout &lt;&lt; "non-const pointer " &lt;&lt; f->x &lt;&lt; endl;
}
int main(){

    const F f;
    const F * g = new F();
    F t;
    F * u = new F();
    foo(f);
    foo(&amp;f);
    foo(t);
    foo(&amp;t);
    foo(*g);
    foo(g);
    foo(*u);
    foo(u);
    
    return 0;
}
</pre>

</li>
</ol>
</div>
</div>
</li>
<li>
<div class="content" id="constReference">
<h3>References</h3>
<div class="featureList">
<ol>
<li><a href="https://www.cprogramming.com/tutorial/const_correctness.html" target="_blank">Const correctness.</a></li>
</ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
