<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>C++&nbsp;inheritance</title>
<meta charset="utf-8">
<meta name="date" content="2018-01-25">
<meta name="keywords" content="inheritance">
<meta name="keywords" content="c++">
<meta name="keywords" content="object-oriented">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>C++&nbsp;-&nbsp;inheritance</strong></center>
</div>
<p class="date"><span class="created-date">Created:2018-01-25</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2018-01-25</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#inheritIntro">Introduction</a></li>
<li><a href="#inheritExamples">Examples</a></li>
<li><a href="#inheritReference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="inheritIntro">
<h3>Introduction</h3>
<p>Inheritance: is-a (vs. has-a) architecture, child contains class. Natural and good for code reusing.</p>
<p>Subclasses automatically inherit all Parent classes's members except *structors (Even though the subclasses cannot directly access parent private members, but they are also inherited. )</p>
<p>Different from Java, C++ inheritance allows <span style="color:red">mutli-inheritance</span></p>
<p>It also has <span style="color:red">public/protect/private modifier</span> before parent name.</p>
</div>
</li>
<li>
<div class="content" id="inheritExamples">
<h3>Examples</h3>
<div class="featureList">
<ol>
<li>
<h4>Constructor inheritance</h4>
<p>Either child's compiler-provided or user-provided default/non-default constructor would FIRST call Parent default constructor, then do it self. (same as Java)</p>
<p>Using c++ std11, child constructor use initialization list to choose a specific parent constructor.</p>
<p>Exact one of parent constructor must be called first in the every child constructor.</p>
<pre class="brush: cpp"> 
        #include &lt;iostream>
        using namespace std;
        class Parent{
        public:
            Parent();
        };
        Parent::Parent(){
            cout &lt;&lt; "Parent constructor" &lt;&lt; endl;
        }
        class Child: public Parent{
            
        };
        
        int main(){
            Parent p; // Parent constructor
            Child c; // Parent constructor
            return 0;
        }
            
</pre>
<p><a href="./program/inheritance_contructor.cpp">Source code</a></p>
<pre class="brush: cpp">

#include &lt;iostream>
    using namespace std;
    class Parent{
    public:
        Parent();
        Parent(int x, int y);
    };
    Parent::Parent(){
        cout &lt;&lt; "Parent constructor" &lt;&lt; endl;
    }
    Parent::Parent(int x, int y){
        cout &lt;&lt; "Parent (int, int) constructor" &lt;&lt; endl;
    }
    class Child: public Parent{
    private:
        int x;
        int y;
    public:
        Child();
        Child(int x, int y);
        Child(int x, int y, int z);
    };
    Child::Child(){
        // Parent(); syntax is ok, but this is actually just to create a Parent object without assignment.
        cout &lt;&lt; "Child constructor" &lt;&lt; endl;
    }
    Child::Child(int x, int y):x(x), y(y){
        this->x = x;
        this->y = y;
        cout  &lt;&lt; "Child (int, int) constructor" &lt;&lt; endl;
    }
    Child::Child(int x, int y, int z):Parent(x,y){ //using initialization list to choose a non-default parent constructor.
        cout &lt;&lt; "Child (int, int, int) constructor" &lt;&lt; endl;
    }
    int main(){
        Parent p; // Parent constructor
        Child c; //  Parent constructor /n Child constructor
        Child c1(1,1); //Parent constructor /n Child (int, int) constructor
        Child c2(1,1,1); // Parent (int, int) constructor /n Child (int, int, int) constructor
        return 0;
    }
</pre>
</li>
<li>
<h4>The requirement for a parent default constructor</h4>
<p>In some cases, the parent class may not have the default constructor either provided by the compiler or defined by the user. However, because the subclass's constructors would implicitly invoke 
    the parent's default constructor, it would cause compilation error. To avoid this issue, 1) always having a default constructor; or 2) explicitly invoking parent's own constructors.
</p>
<pre class="brush:cpp">
#include &lt;iostream>
using namespace std;

class F{
public:
    F(int x){cout &lt;&lt; "F(int x) constructor" &lt;&lt; endl; }
};
class E: public F{
    
};

int main(){
    E e; //no matching function for call to ‘F::F()’ class E: public F{

    return 0;
}
</pre>
<pre class="brush: cpp">
#include &lt;iostream>
using namespace std;

class F{
public:
    F(int x){cout &lt;&lt; "F(int x) constructor" &lt;&lt; endl; }
};
class E: public F{
public:
    E():F(1){} // explicitly call F(int )
};

int main(){
    E e; 

    return 0;
}
</pre>
</li>
<li>
<h4>Initialization list order</h4>
<p>The order of element in the initialization does not matter. e.g. :x(x), y(y), Parent(x,y) is OK. But the real initialization order is <span style="color:red">Parent, arguments in declaration order.</span></p>

</li>
<li>
<h4>Override parent private functions</h4>
<p>The parent private function is invisble to child class, so the child </p>
</li>
<li>
<h4>Override &amp; Call super class method</h4>
<p>Subclasses automatically inherit all Parent classes's members <span style="color:red">except constructor</span> (Even though the subclasses cannot directly access parent private members, but they are also inherited). </p>
<p>However, if the subclass define a method to override a parent method (the two methods have same signature: name + same order arguments), but the child still wants to call its parent version, then it has to use Parent:: syntax</p>
<p><span style="color:red">C++ does not have super like keywork (e.g. super in Java), perhaps because C++ support multiple inheritance.[1]</span></p>
<p><a href="./program/override.cpp">Source code</a></p>
<pre class="brush: cpp;  highlight: [19, 25];">
    #include &lt;iostream>
        using namespace std;
        class Parent{
        public:
            Parent();
            void display();
        };
        Parent::Parent(){
            cout &lt;&lt; "Parent constructor" &lt;&lt; endl;
        }
        void Parent::display(){
            cout &lt;&lt; "Parent display" &lt;&lt; endl;
        }
        
        //========
        class Child: public Parent{
        public:
            Child();
            void display(); // if child wants to override a function, it has to explicitly declare the function.
        };
        Child::Child(){
            cout &lt;&lt; "Child Constructor" &lt;&lt; endl;
        }
        void Child::display(){
            Parent::display(); // invoke parent's display
            // display();// this causes infinite recursion
            cout &lt;&lt; "Child display "  &lt;&lt;  endl;
        }
        int main(){
            Child c; // Parent constructor /n Child constructor
            c.display(); // Parent display /n Child display
            return 0;
        }
</pre>
</li>
<li>
<h4>Override member variables</h4>
<p>Override member variable can modify variable's access modifier, and variable's type. Also it will create a new storage area for this new variable and still has space for parent. </p>
<p><span style="color:red">If the parent's functions access the parent's variable, the child inherited functions still go to access the inherited parent's variable instead of child newly defined varaibles.</span></span></p>
</li>
<li>
<h4>Modes of inheritance: public, protected and private</h4>
<div class="featureList">

</div>
</li>
<li>
<h4>Override changes the modifers</h4>
<p>Override can also override the modifer. The child class can make public parent functions to be private or protected. In this case, outside of the child class cannot invoke 
this function anymore. <span style="color:red">In order to call the child class function, a virtual function can be used.</span>.
</p>
<pre class="brush:cpp">
#include &lt;iostream>
using namespace std;
class F{
protected:
    int x = 0; 
    void print(){cout &lt;&lt; "P protected print!" &lt;&lt; endl; }
public:
    virtual void draw(){cout &lt;&lt; "P public draw!" &lt;&lt; endl; }
    void showX(){ cout &lt;&lt; x &lt;&lt; endl;} // a new x is defined in child, but parent still use its self x
};
class E: public F{
public:
    int x; // child override parent's variable
    void print(){cout &lt;&lt; "C public print!"  &lt;&lt; endl; }
protected:
    void draw(){cout &lt;&lt; "C protected draw!" &lt;&lt; endl; }
};
int main(){
    E e;
   // e.draw();// ‘void E::draw()’ is protected
    e.print();
    e.x = 10;
    e.showX();
    F * f = new E();
    f->draw(); // invoke child protected...
    return 0;
}
</pre>
</li>
<li>
<h4>Mutli-inheritance</h4>
<p></p>
<pre>

</pre>
</li>
</ol>
</div>
</div>
</li>
<li>
<div class="content" id="inheritReference">
<h3>References</h3>
<ol>
<li>Problem solving with C++ 9th edition, P846</li>
<li><a href="https://www.geeksforgeeks.org/inheritance-in-c/" target="_blank">Inheritance in C++ - GeeksforGeeks</li>
<li><a href="https://stackoverflow.com/questions/357307/how-to-call-a-parent-class-function-from-derived-class-function" target="_blank">C++ does not have super keyword.</a></li>
</ol>
</div>
</li>
</ol>
</div>
    
</body>
</html>
