<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Javascript&nbsp;Prototype & Class</title>
<meta charset="utf-8">
<meta name="date" content="2018-04-05">
<meta name="keywords" content="prototype">
<meta name="keywords" content="inheritance">
<meta name="keywords" content="javascript">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>Javascript&nbsp;-&nbsp;Prototype & Class</strong>
</div>
<p class="date"><span class="created-date">Created:2018-04-05</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-11-12</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#prototype">Prototype</a></li>
<li><a href="#class">Class</a></li>
<li><a href="#reference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="prototype">
<h3>Introduction</h3>
<p>JS doesn't natively support user-defined class. It is prototype-oriented programming language, which new members are directly added to objects instead of first defining them in class's definitions.</p>
<div class="featureList">
    <ol>
        <li>
            <h4>Object construction</h4>
            <p>Because new members are directly added to objects, no need to define them in class definition. So when creating a new object, we can define the "constructor" or clone another objects and modify it.</p>
            <pre class="brush:javascript">
                function Animal(){
                    this.weight = 0;
                    this.age = 0;
                }

                let animal = new Animal();
                console.log(animal.weight);
                console.log(animal.age);
            </pre>
            <p>Or the animal object can be directly constructed from a generic object.</p>
            <pre class="brush:javascript">
                let animal = {weight: 10, age:12};
            </pre>
        </li>
        <li>
            <h4>Inheritance</h4>
            <p>Inheritance is achieved by cloning objects.</p>
            <pre class="brush:javascript">
                    let animal = {weight: 10, age:12};
                    let cat = Object.create(animal);

                    cat.yeild = function(){ // inheritance.
                        let value = "";
                        for(let i = 0; i &lt; this.age; i++){
                            value += "miao;"
                        }
                        return value;
                    }

                    let cat2 = Object.create(cat);
                    cat2.age = 3;
                    console.log(cat2.yeild()); // "miao;miao;miao"
                    
            </pre>
        </li>
        <li>
            <h4>Prototype</h4>
            <p>"prototype" is a property of the constructor function. We can also add new members to prototype to achieve inheritance.</p>
            <pre class="brush:javascript">
                function Animal(weight, age){
                    this.weight = weight;
                    this.age = age;
                }
                
                let animal = new Animal(10, 12);
                let cat = Object.create(animal);
                Animal.prototype.jump = function(){
                    return "jump";
                }
                console.log(cat.jump());
            </pre>
            <p>Adding members to prototype will also enable already existed objects to have these new members. However, cloning the objects only introduce new members if the cloned objects already have the new members.</p>
            <p><span style="color:red">prototype members are not shared by objects. If an object modifies the value of a member from prototype, other objects still have the old values.</span></p>
        </li>
        <li>
            <h4>Another inheritance</h4>
            <p>"prototype" can inherit shared members. ".call" lets us inherit individual members.</p>
            <pre class="brush:javascript">
            function Person(name, age){
                this.name = name;
                this.age = age;
            }
            function Employee(name, age, salary){
                this.salary = salary;
                Person.call(this, name, age); // create properties for Employee's instance.
            }
            Employee.prototype.print = function(){
                console.log(`${this.name}:${this.salary}`);
            }
            const ep = new Employee("nan", 4000);
            ep.print();
            </pre>
        </li>
        <li>
            <h4>Prototype chain</h4>
            <p>How does an instance find a member?</p>
            <p>JS will first try to find if the object itself has the definition of the member, if not, it will go a __proto__ object to find the member.
                <span style="color:red">prototype在constructor上叫prototype, 在instance上叫__proto__, 只不过 car.__proto__.print() 可以直接写成 car.print()</span>
            </p>
            <h4>Prototype chain</h4>
            <p>An object has __proto__ field, but __proto__ field is also an object, which may also have its __proto__. Eventually the search for a member will go to Object's __proto__, where Object's prototype is null.</p>
        </li>
    </ol>
</div>
</div>
</li>
<li>
    <div class="content" id="class">
        <h3>Class</h3>
        <p>JS doesn't natively support class, class is simulated with prototype. Class is a new features in ES6. And public/private modifiers are not supported yet.</p>
        <div class="featureList">
            <ol>
                <li>
                    <h4>Javascript class with static member</h4>
                    <p>Static methods can be defined in class body, static fields must be declared outside the class body. And static members are only accessible with class.</p>
                    <p>When using "this" inside static member, "this" is the class(function).</p>
                    <pre class="brush:javascript">
                        'use strict'
                        class RepeatedPrinter{
                            constructor(copy){
                                this.copy = copy;
                            }
                            print(msg){
                                for(let i = 0; i &lt; this.copy; i++){
                                    console.log(msg);
                                }
                            }
                            static PrintMeta(){
                                console.log("V1.0 beta");
                                console.log(this == RepeatedPrinter); // true
                            }
                        }
                        // static member
                        RepeatedPrinter.Brand = "HP";

                        let rp = new RepeatedPrinter(2);
                        rp.print("Who are you?");
                        // rp.printMeta(); instance cannot access static members.
                        RepeatedPrinter.PrintMeta();
                    </pre>
                </li>
                <li>
                    <h4>Anonymous class</h4>
                    <pre class="brush:javascript">
                        new class {
                            constructor(copy){}
                            print(msg){}
                        }(10).print("Who are you?")
                    </pre>
                </li>
                <li>
                    <h4>Inheritance</h4>
                    <p> 
                        Javascript supports inheritance. We can use super keyword to refer to parent class member.
                        <span style="color:red">Must call super constructor in derived class before accessing 'this' or returning from derived constructor</span>
                    </p>
                    <pre class="brush:javascript">
                        'use strict'
                        class Printer{
                            constructor(prompt){
                                this.prompt = prompt;
                            }
                            print(msg){
                                console.log(this.prompt +msg);
                            }
                        }
                        class RepeatPrinter extends Printer{
                            constructor(prompt, copy){
                                super(prompt);
                                this.copy = copy;
                            }
                            print(msg){
                                for(let i = 0; i &lt; this.copy; i++){
                                    super.print(msg);
                                }
                            }
                        }
                        let rp = new RepeatPrinter(">>> ", 30)
                        rp.print("Who are you?");
                </li>
                <li>
                    <h4>Late binding</h4>
                    <p>When an object invokes a method, "this" inside the method always refers to the object.</p>
                    <pre class="brush:javascript">
                            class ReturnThis{
                                getThis(){
                                    return this;
                                }
                            }
                            
                            let rt = new ReturnThis();
                            console.log(rt.getThis()); // {}
                            let obj = {x:1, y:2};
                            obj.z = rt.getThis;
                            console.log(obj.z()); // {x:1, y:2, z: [Function:getThis]}
                    </pre>
                </li>
            </ol>
        </div>
    </div>
</li>
<!--<li>
<div class="content" id="prototypeObject">
<h3>Object's prototype</h3>
<p>Object is also a constructor function. This constructor function's prototype has a couple important properites.
<div class="featureList">
<ol>
<li>
<h4>constructor</h4>
<p>By default, the constructor is set to itself.</p>
<pre class="brush:js">
function Person(name){
    this.name = name;
    // Person.prototype.constructor = Person // automatically
}
const p = new Person();
console.log(p.constructor === Person); // true
</pre>
<p>When we change the value prototype to another instance, the prototype.constructor will also be changed.</p>
<pre class="brush:js">
function Person(){
    // Person.prototype.constructor = Person
}
function Employee(){
}
Employee.prototype = new Person();
const em = new Employee();
console.log(em.constructor); // [Function:Person]
</pre>
<p>Reason: <br>
    em.constructor<br>
    -> em.__proto__.constructor<br>
    -> Employee.prototype.constructor<br>
    -> (new Person()).constructor<br>
    -> (new Person()).__proto__.constructor<br>
    -> Person.prototype.constructor
</p>
<p>Usually, we manually change it back</p>
<pre class="brush:js">
Employee.prototype = new Person();
Employee.prototype.constructor = Employee;
const em = new Employee();
</pre>
<p><span style="color:goldenrod">constructor property 仅仅可以用于识别对象是由哪个构造函数初始化的，仅此而已
<br>instanceof 等等不会被这个property影响</span></p>
</li>
<li>
.hasOwnProperty(’str’) ;// 这个property必须是定义在自己里的，继承的不算
</li>
<li>
pro.isPrototypeOf( obj ); // pro objects 在obj的prototype chain上         
</li>
</ol>
</div>
</div>
</li>-->

<li>
<div class="content" id="reference">
    <h3>References</h3>
    <div class="featureList">
        <ol>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank">Defining classes</a></li>
            <li><a href="http://www.jb51.net/article/81556.htm" target="_blank">Nodejs中的this详解</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling">JavaScript Guide</a></li>
            <li><a href="https://www.w3schools.com/js/js_reserved.asp" target="_blank">Reversed words</a></li>
        </ol>
    </div>
</div>
</li>
</ol>
</div>

</body>
</html>
