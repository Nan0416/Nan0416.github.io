<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Javascript&nbsp;Prototype</title>
<meta charset="utf-8">
<meta name="date" content="2018-04-05">
<meta name="keywords" content="prototype">
<meta name="keywords" content="inheritance">
<meta name="keywords" content="javascript">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>Javascript&nbsp;-&nbsp;Prototype</strong></center>
</div>
<p class="date"><span class="created-date">Created:2018-04-05</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2018-04-07</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#prototypeIntro">Introduction</a></li>
<li><a href="#prototypePrototype">Prototype and .call</a></li>
<li><a href="#prototypeObject">Object's prototype</a></li>
<!--<li><a href="#prototypeReference">References</a></li>-->
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="prototypeIntro">
<h3>Introduction</h3>
<p>JS can realize inhertiance by using prototype.</p>
<p>"Prototype" (原型对象) is a property of the constructor function (构造函数). A function is also an object in JS, so it can have properties.</p>
<p>The constructor function will be automatically assigned a "prototype" property.</p>
<p>The prototype by default is an empty object {}. But developer can assign functions, properties or an object to this "prototype".</p>
<p>Then all instances of this constructor function will <span style="color:red">share</span> those functions, properties or the object.</p>
<p class="starMark">* The instance of this constructor does not have the "prototype" property, they can directly reference those functions, properties, or the object.</p>
<h4>Example</h4>
<span style="font-size: 13px">
<pre class="brush:js">

function Car(){

}
Car.prototype.x = 0; // x is shared by all instances.
Car.prototype.log = function(){ // the log function is shared by all instances.
    Car.prototype.x = Car.prototype.x + 1;
    console.log(Car.prototype.x);
};

const car1 = new Car();
const car2 = new Car();
car1.log(); // 1 The syntax makes developers feel that the instance itself has a function called log().
car2.log(); // 2

</pre>
</span>
<h4>Inherit shared (static in java) functions and properties</h4>
<p>Because instances can directly access all properties from the prototype, it seems like inheritance.</p>
<p>The prototype can help save memory, because it allows instance to share the stateless functions.</p>
<p>But sometimes, we do not want the instances share properties. Properties should belong to individuals.</p>
<p>In this case, we can combine "this" and "prototype"</p>
<h4>Example</h4>
<span style="font-size: 13px">
<pre class="brush:js">
function Car(make, model){
    this.make = make;
    this.model = model;
}
Car.prototype.print = function(){
    console.log(`${this.make}:${this.model}`);
};

const car1 = new Car('Benz', 'ML350');
const car2 = new Car('Mazda', 'CX-5');
car1.print(); 
car2.print();
</pre></span>
<h4>Inherit individual properties and functions</h4>
<p>"prototype" can inherit shared members. ".call" lets us inherit individual members.</p>
<h4>Example</h4>
<span style="font-size: 13px">
<pre class="brush:js">
function Person(name, age){
    this.name = name;
    this.age = age;
}
function Employee(name, age, salary){
    this.salary = salary;
    Person.call(this, name, age); // create properties for Employee's instance.
}
Employee.prototype.print = function(){
    console.log(`${this.name}:${this.salary}`);
}
const ep = new Employee("nan", 4000);
ep.print();
</pre></span>
</div>
</li>

<li>
<div class="content" id="prototypePrototype">
<h3>Prototype &amp; __proto__</h3>
<div class="featureList">
<ol>
<li>prototype上的function无法访问 构造函数里的local variable，没有closure</li>
<li>JS engine 会先去找这个instance的constructor有没有自己定义func，如果有，则先调用自己的</li>
<li><span style="color:red">prototype在constructor上叫prototype, 在instance上叫__proto__, 只不过 car.__proto__.print() 可以直接写成 car.print()</span></li>
</ol>
<h4>Prototype chain (原型链)</h4>
<p>一个object有prototype这个object，而prototype本身也是一个object 所以也有prototype，最终会追溯到Object的prototype，Object的prototype是null，而null没有prototype</p>
<h4>Example</h4><span style="font-size: 13px">
<pre class="brush:js">
function Person(){
    this.person = function(){
        console.log("this is a person");
    }
}
function Employee(){
}
Employee.prototype = new Person();
function Manager(){
}
Manager.prototype = new Employee();
const mgr = new Manager();
mgr.person();
mgr.__proto__.person();
console.log(mgr.__proto__.__proto__ === p); // true
</pre></span>
</div>
</div>
</li>
<li>
<div class="content" id="prototypeObject">
<h3>Object's prototype</h3>
<p>Object is also a constructor function. This constructor function's prototype has a couple important properites.
<div class="featureList">
<ol>
<li>
<h4>constructor</h4>
<p>By default, the constructor is set to itself.</p>
<pre class="brush:js">
function Person(name){
    this.name = name;
    // Person.prototype.constructor = Person // automatically
}
const p = new Person();
console.log(p.constructor === Person); // true
</pre>
<p>When we change the value prototype to another instance, the prototype.constructor will also be changed.</p>
<pre class="brush:js">
function Person(){
    // Person.prototype.constructor = Person
}
function Employee(){
}
Employee.prototype = new Person();
const em = new Employee();
console.log(em.constructor); // [Function:Person]
</pre>
<p>Reason: <br>
    em.constructor<br>
    -> em.__proto__.constructor<br>
    -> Employee.prototype.constructor<br>
    -> (new Person()).constructor<br>
    -> (new Person()).__proto__.constructor<br>
    -> Person.prototype.constructor
</p>
<p>Usually, we manually change it back</p>
<pre class="brush:js">
Employee.prototype = new Person();
Employee.prototype.constructor = Employee;
const em = new Employee();
</pre>
<p><span style="color:goldenrod">constructor property 仅仅可以用于识别对象是由哪个构造函数初始化的，仅此而已
<br>instanceof 等等不会被这个property影响</span></p>
</li>
<li>
.hasOwnProperty(’str’) ;// 这个property必须是定义在自己里的，继承的不算
</li>
<li>
pro.isPrototypeOf( obj ); // pro objects 在obj的prototype chain上         
</li>
</ol>
</div>

</div>
</li>
</ol>
</div>
    
</body>
</html>
