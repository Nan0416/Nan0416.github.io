<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<title>C#&nbsp;Attribute & Reflection</title>
<meta charset="utf-8">
<meta name="date" content="2019-07-12">
<meta name="keywords" content="">
<meta name="keywords" content="">
<meta name="keywords" content="">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushPython.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushSql.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>

</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>C#&nbsp;-&nbsp;Attribute & Reflection</strong>
</div>
<p class="date"><span class="created-date">Created:2019-07-12</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-07-12</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#attribute">Attribute</a></li>
<li><a href="#reflection">Reflection</a></li>
<li><a href="#reflection_attrbute">Reflection with Attributes</a></li>
<li><a href="#reference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="attribute">
<h3>Attribute</h3>
<p class="reference-box">
Attributes provide a way of associating information with code in a declarative way. They can also provide a reusable element that can be applied to a variety of targets.<br>
Any attribute you create acts only as metadata, and doesn't result in any code within the attribute class being executed<br>
Programmers can then attach attributes to various program entities (class, method, properties), and retrieve attribute information in a run-time environment
</p>
<div class="featureList">
    <ol>
        <li>C# Attribute (Java Annotation, Python decorator) is a way that enables us use declarative way to "mark" code and provide metadata about code. <span style="color:red">Most likely, the attribute does not contain any complex logic. 
            The processing framework will use reflection to parse these attribute and initialize/modify the marked targets (e.g. class, method, parameter ...)</span><br>
            <span style="color:red">Not sure C# attribute has lifecycle like Java's compile time annotation and runtime annotation.</span> In this note, an C# attribute is involved in both complie time and runtime.
        </li>
        <li>
            <h4>Attribute Class</h4>
            <p>Attributes are class that inherit from <span class="inline-code">Attribute</span> class. By convention, the definition of an attribute class is {AttributeName}Class, but usage is just [AttributeName]</p>
            <pre class="brush:cpp">
namespace System.Runtime.InteropServices{
    public interface _Attribute{
        void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
        void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
        void GetTypeInfoCount(out uint pcTInfo);
        void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    }
}
namepace System{
    public abstract class Attribute : _Attribute{
        protected Attribute();
        // When implemented in a derived class, gets a unique identifier for this System.Attribute.
        public virtual object TypeId { get; }
        // A static method to get a Attribute from an Assembly with the certain type. inherit is ignored, and does not affect its behavior.
        public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
        public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
        // ...
    }
}
            </pre>
        </li>
        <li>
            <h4>Attribute applied targets</h4>
            <p>An attribute can be used as a tag to place on a number of different targets, including <br>
                <span style="color:blue;font-weight:bold">Assembly, Module<br>
                Class, Enum, Interface, Struct, Delegate<br>
                Constructor, Method, Field, Event, Property, GenericParameter<br>
                Parameter, ReturnValue</span>
            </p>
            <p>By default, an attribute can place on all these target. By we can add restriction on it.</p>
            <pre class="brush:cpp">
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public class NanClassAttribute : Attribute {

    }
            </pre>
            <p>Internal definition</p>
            <pre class="brush:cpp">
    [ComVisible(true)]
    [Flags]
    public enum AttributeTargets
    {
        Assembly = 1,
        Module = 2,
        Class = 4,
        Struct = 8,
        Enum = 16,
        Constructor = 32,
        Method = 64,
        Property = 128,
        Field = 256,
        Event = 512,
        Interface = 1024,
        Parameter = 2048,
        Delegate = 4096,
        ReturnValue = 8192,
        GenericParameter = 16384,
        All = 32767
    }
            </pre>
            <p>Attribute's Attribute</p>
    <pre class="brush:cpp">
    [AttributeUsage(AttributeTargets.Class, Inherited = true)]
    [ComVisible(true)]
    public sealed class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn);
        public AttributeTargets ValidOn { get; }
        // Gets or sets a Boolean value indicating whether more than one instance of the indicated attribute can be specified for a single program element.
        public bool AllowMultiple { get; set; }
        // Whether the indicated attribute is inherited by derived classes and overriding members.
        public bool Inherited { get; set; }
    }
    </pre>
        </li>
        <li>
            <h4>Initialization of attribute</h4>
            <p>
                An attribute is placed on a target place, and initialized with positional and named parameters.
            </p>
            <pre class="brush:cpp">
                public class NanClassAttribute :Attribute{
                    private string _data;
                    public NanClassAttribute(string data) {
                        _data = data;
                    }
                    public int Number { get; set; }
                }
            
                [NanClass("Testing", Number = 1)]
                public class Target{
                    private string _name;
                    public Target(string name) {
                        _name = name;
                    }
                }
            </pre>
            <p>Positional argument are constructor parameter of the attribute, Named parameters are attribute's public properties with public get and public set</p>
            <h4>Type restriction on positional & named argument</h4>
            <p>They must be primitive types (int, short ...), string, object, System.Type, Enum, single-dimensional array with these types. <span style="color:red">An attribute can have objects of complex class, but they cannot be used as positional or named parameter.</span></p>
            <p>Passing System.Type & Object, and then casting...</p>
        </li>
    </ol>
</div>
</div>
</li>
<li>
    <div class="content" id="reflection">
        <h3>Reflection</h3>
        <p class="reference-box">Use reflection to 1). dynamically create an instance of a type, 2). bind the type to an existing object, or 3). get the type from an existing object and 4). invoke its methods or access its fields and properties. 5). retrieve information stored in attribute. 6). building new type at runtime.</p>
        
        <div class="featureList">
            <ol>
                <li>
        <h4>Modules vs. Assembly</h4>
        <p>Any .NET supported language e.g. C#, F#. VB, can be compiled into a modules .netmodule. These modules can be understood by the .NET CLR (common language runtime). But modules cannot not be run directly, they must be linked to a library .dll or a application .exe file.</p>
        <p>A module can involve multiple namespace, a namespace can span over multiple modules, or assembly.</p>
        <p>Library Assembly has an internal manifest file that a module doesn't have. An assembly can have one or more modules, and the manifest includes the metadata about these modules.</p>
        <p>Application Assembly has a static Main function that Library Assembly doesn't have.</p>
        <pre class="brush:bash">
            csc /t:module Formatter.cs # compile a code into a module.
            csc /out:Formatter.dll /t:library Formatter.cs # compile a code into an library assembly.
            csc /out:MultiFileLibrary.dll /t:library /addmodule:Formatter.netmodule Logger.cs # compile a code along with a module into an assembly. This assembly has two modules.
            csc /out:App.exe /t:exe /addmodule:Formatter.netmodule Main.cs # compile code into application assembly.
         </pre>
                </li>
                <li>
                     
                </li>
            </ol>
        </div>
    </div>
</li>
<li>
<div class="content" id="reference">
<h3>References</h3>
<div class="featureList">
    <ol>
        <li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/attributes" target="_blank">C# Attribute</a></li>
        <li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/attributes#positional-and-named-parameters" target="_blank">Positional and named parameters</a></li>
        <li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/attributes#compilation-of-an-attribute" target="_blank">Compilation of an attribute.</a></li>
    </ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
