<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<title>C#&nbsp;Attribute & Reflection</title>
<meta charset="utf-8">
<meta name="date" content="2019-07-12">
<meta name="keywords" content="">
<meta name="keywords" content="">
<meta name="keywords" content="">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushPython.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushSql.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>

</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>C#&nbsp;-&nbsp;Attribute & Reflection</strong>
</div>
<p class="date"><span class="created-date">Created:2019-07-12</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-07-12</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#attribute">Attribute</a></li>
<li><a href="#reflection">Reflection</a></li>
<li><a href="#reference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="attribute">
<h3>Attribute</h3>
<p class="reference-box">
Attributes provide a way of associating information with code in a declarative way. They can also provide a reusable element that can be applied to a variety of targets.<br>
Any attribute you create acts only as metadata, and doesn't result in any code within the attribute class being executed<br>
Programmers can then attach attributes to various program entities (class, method, properties), and retrieve attribute information in a run-time environment
</p>
<div class="featureList">
    <ol>
        <li>C# Attribute (Java Annotation, Python decorator) is a way that enables us use declarative way to "mark" code and provide metadata about code. <span style="color:red">Most likely, the attribute does not contain any complex logic. 
            The processing framework will use reflection to parse these attribute and initialize/modify the marked targets (e.g. class, method, parameter ...)</span><br>
            <span style="color:red">Not sure C# attribute has lifecycle like Java's compile time annotation and runtime annotation.</span> In this note, C# attribute is only the runtime attribute.
        </li>
        <li>
            <h4>Attribute Class</h4>
            <p>Attributes are class that inherit from <span class="inline-code">Attribute</span> class. By convention, the definition of an attribute class is {AttributeName}Class, but usage is just [AttributeName]</p>
            <pre class="brush:cpp">
namespace System.Runtime.InteropServices{
    public interface _Attribute{
        void GetIDsOfNames(ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
        void GetTypeInfo(uint iTInfo, uint lcid, IntPtr ppTInfo);
        void GetTypeInfoCount(out uint pcTInfo);
        void Invoke(uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    }
}
namepace System{
    public abstract class Attribute : _Attribute{
        protected Attribute();
        // When implemented in a derived class, gets a unique identifier for this System.Attribute.
        public virtual object TypeId { get; }
        // A static method to get a Attribute from an Assembly with the certain type. inherit is ignored, and does not affect its behavior.
        public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
        public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
        // ...
    }
}
            </pre>
        </li>
        <li>
            <h4>Attribute applied targets</h4>
            <p>An attribute can be used as a tag to place on a number of different targets, including <br>
                <span style="color:blue;font-weight:bold">Assembly, Module<br>
                Class, Enum, Interface, Struct, Delegate<br>
                Constructor, Method, Field, Event, Property, GenericParameter<br>
                Parameter, ReturnValue</span>
            </p>
            <p>By default, an attribute can place on all these target. By we can add restriction on it.</p>
            <pre class="brush:cpp">
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public class NanClassAttribute : Attribute {

    }
            </pre>
            <p>Internal definition</p>
            <pre class="brush:cpp">
    [ComVisible(true)]
    [Flags]
    public enum AttributeTargets
    {
        Assembly = 1,
        Module = 2,
        Class = 4,
        Struct = 8,
        Enum = 16,
        Constructor = 32,
        Method = 64,
        Property = 128,
        Field = 256,
        Event = 512,
        Interface = 1024,
        Parameter = 2048,
        Delegate = 4096,
        ReturnValue = 8192,
        GenericParameter = 16384,
        All = 32767
    }
            </pre>
            <p>Attribute's Attribute</p>
    [AttributeUsage(AttributeTargets.Class, Inherited = true)]
    [ComVisible(true)]
    public sealed class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn);
        public AttributeTargets ValidOn { get; }
        // Gets or sets a Boolean value indicating whether more than one instance of the indicated attribute can be specified for a single program element.
        public bool AllowMultiple { get; set; }
        // Whether the indicated attribute is inherited by derived classes and overriding members.
        public bool Inherited { get; set; }
    }
        </li>
        <li>
            <h4>Initialization of attribute</h4>
            <p>
                An attribute is placed on a target place, and initialized with positional and named parameters.
            </p>
            <pre class="brush:cpp">
                
            </pre>
        </li>
    </ol>
</div>
</div>
</li>
<li>
<div class="content" id="reference">
<h3>References</h3>
<div class="featureList">
    <ol>
        <li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/attributes" target="_blank">C# Attribute</a></li>
        <li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/attributes#positional-and-named-parameters" target="_blank">Positional and named parameters</a></li>
    </ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
