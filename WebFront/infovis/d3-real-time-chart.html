<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>D3&nbsp;Code Structure</title>
<meta charset="utf-8">
<meta name="date" content="2018-09-15">
<meta name="keywords" content="">
<meta name="keywords" content="">
<meta name="keywords" content="">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>

</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>D3&nbsp;-&nbsp;Code Structure</strong>
</div>
<p class="date"><span class="created-date">Created:2018-09-15</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2018-11-18</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#concept">Organization</a></li>
<li><a href="#example">A real-time scatter plot</a></li>
<li><a href="#code">Code</a></li>
<li><a href="#reference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
    <div class="content" id="concept">
        <h3>Organization</h3>
        <p>A <span style="color:red">D3 SVG chart</span> composes several components, including a HTML svg tag, axis objects, labels, and svg objects (line, circles and paths)</p>
        <div>
            <img src="./images/d3.png" width="500" height="200">
        </div>
        <p>All of these objects are only instantiated/created once, and then update as the data change. <span style="color:red">Data may change because of filtering or real-time data.</span></p>
        <h4>HTML structure</h4>
        <pre style="font-size: 13px">
            svg/g/axis1
            svg/g/axis2
            svg/g/path
            svg/g/circle
                  circle
                  circle
                  circle
                  ...
            svg/g/label 
        </pre>
        <h4>Instantiate/Update</h4>
        <div class="featureList">
            <ol>
                <li>
                    Scale
                    <pre class="brush:js">
                        // create scale
                        let scale = d3.scaleLinear();
                        // set/update domain (according to data)
                        scale.domain([ , ]);
                        // set/update range (according to HTML SVG)
                        scale.range([ , ]);
                    </pre>
                    
                </li>
                <li>
                    Axis
                    <pre class="brush:js">
                        // Bind a scale to the axis, and format axis. 
                        // **** Axis is automatically updated when the scale changing because of the binding.
                        let axis =d3.axisTop(scale)
                                .ticks(8)
                                .tickFormat(d3.format('.0%'));
                    </pre>
                </li>
                <li>
                    Draw Axis on HTML
                    <pre class="brush:js">
                        // Initialize once on the SVG
                        let htmlAxis = svg.append('g')
                            .attr('transform', `translate(${padding.l},${padding.t - 10})`);
                        
                        // draw and re-draw
                        htmlAxis.call(axis);
                    </pre>
                </li>
                <li>
                    Draw Path Objects (Chart represented by a path)
                    <pre class="brush:js">
                        // Initialize once on the SVG, bind data 
                        let pathG = svg.append('g')
                            .attr('transform', translate);
                        let path1 = pathG.append('path')
                            .datum(data) // data is an array
                            .attr('class', 'line-plot')
                            .attr('fill', 'none')
                            .attr('stroke', color)
                            .attr('stroke-width', '2px');
                        let fun = d3.line()
                            .x((d)=>{ return xScale(d.x);})
                            .y((d)=>{ return yScale(d.y);})
                            .curve(d3.curveBasis); //optional curve
                        
                        // draw and re-draw, (data and scale are update automatically)
                        path1.attr('d', fun);
                    </pre>
                </li>
                <li>Draw Other Objects (e.g. Scatterplot -- a lot of circles)
                    <pre class="brush:js">
                        // create a group, transform
                        let scatterplotG = svg.append('g').attr('class', 'scatter-plot');
                        
                        // rebind the updated data to chart for each redrawing
                        let scatterPlot = scatterplotG.selectAll('.point')
                            .data(data, (d)=>(d.time)); // bind data with k
                        // for new 
                        let sp_enter = scatterPlot.enter()
                            .append('circle')
                            .attr('class', 'point')
                            .attr('fill', 'green')
                            .attr('r', 3)
                            .attr('cx', d=>{return xScale(d.time)})
                            .attr('cy', d=>{return yScale(d.value)})
                        // for update existed all
                        sp_enter.merge(scatterPlot).transition()
                            .attr('cx', d=>{return xScale(d.time)})
                            .attr('cy', d=>{return yScale(d.value)})
                        
                        // for removed
                        scatterPlot.exit().remove();
                    </pre>
                </li>
            </ol>
        </div>
    </div>
</li>
<li>
    <div class="content" id="example">
        <h3>A real-time scatter plot</h3>
        <div>
            <button onclick="increase_size()">Increase Size</button>
            <button onclick="decrease_size()">Decrese Size</button>
        </div>
        <div>
            <svg id="real-time" width="700" height="200"  style="border: 1px solid #777;"></svg>
        </div>
        <script>
            // dynamic data
            const MAX_VALUE = 100;
            function data_generator(){
                return {time: Date.now(), value: Math.random() * MAX_VALUE};
            }
            function data_filter(data, period){
                // keep data within period
                if(period <= 0){
                    return;
                }
                period = period * 1000; // s -> ms
                let temp = data[data.length - 1].time;
                while(data.length > 0 && data[0].time + period < temp){
                    data.shift();
                }
                return;
            }
            
            

            const data = [];
            let svg = d3.select("#real-time");
            
            let padding = {t: 60, r: 40, b: 30, l: 40};
            let svgWidth = +svg.attr('width');    
            let chartWidth = svgWidth - padding.l - padding.r;
            
            const data_period = 20; // 10s
            let xScale = d3.scaleTime().range([0, chartWidth]); // dynamic domain, fixed domain
            let yScale = d3.scaleLinear().domain([0, MAX_VALUE]) // fixed domain, dynamic range.
            
            let xAxis = d3.axisBottom(xScale).ticks(8);
            let yAxis = d3.axisRight(yScale).ticks(4);

            let xSVGAxis = svg.append('g').attr('class', 'x axis'); // position is dynamic
            let ySVGAxis = svg.append('g').attr('class', 'y axis'); // position is dynamic
            let pathG = svg.append('g').attr('class', 'path-chart');
            let scatterplotG = svg.append('g').attr('class', 'scatter-plot');
            
            let path = pathG.append('path') // setup path
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', 'blue')
                .attr('stroke-width', '2px');
            let fun = d3.line()
                .x((d)=>{ return xScale(d.time);})
                .y((d)=>{ return yScale(d.value);})
                .curve(d3.curveBasis); //optional curve
            

            function draw(){
                let svgHeight = +svg.attr('height');
                let chartHeight = svgHeight - padding.t - padding.b;
                // set range and domain
                let endTime = new Date(data[data.length - 1].time);
                let startTime = new Date(data[data.length - 1].time - data_period * 1000);
                xScale.domain([startTime, endTime]);
                yScale.range([chartHeight , 0])
                // set transform
                xSVGAxis.attr('transform',`translate(${padding.l}, ${padding.t + chartHeight})`);
                ySVGAxis.attr('transform', `translate(${padding.l + chartWidth}, ${padding.t})`);
                pathG.attr('transform', `translate(${padding.l}, ${padding.t})` );
                scatterplotG.attr('transform', `translate(${padding.l}, ${padding.t})`);
                // draw
                xSVGAxis.transition().call(xAxis);
                ySVGAxis.transition().call(yAxis);
                path.transition().attr('d', fun);
                let scatterPlot = scatterplotG.selectAll('.point')
                    .data(data, (d)=>(d.time)); // bind data with k
                let sp_enter = scatterPlot.enter()
                    .append('circle')
                    .attr('class', 'point')
                    .attr('fill', 'green')
                    .attr('r', 3)
                    .attr('cx', d=>{return xScale(d.time)})
                    .attr('cy', d=>{return yScale(d.value)})
                sp_enter.merge(scatterPlot).transition()
                    .attr('cx', d=>{return xScale(d.time)})
                    .attr('cy', d=>{return yScale(d.value)})
                scatterPlot.exit().remove();
            }
            
            setInterval(()=>{
                data.push(data_generator());
                data_filter(data, data_period);
                console.log(data.length);
                draw();
            },600);
            function increase_size(){
                d3.select("#real-time")
                    .attr('height', parseInt(d3.select("#real-time").attr('height')) + 100);
                draw();
            }
            function decrease_size(){
                let h = parseInt(d3.select("#real-time").attr('height'));
                if(h < 150){
                    return;
                }
                d3.select("#real-time")
                    .attr('height',h - 100);
                draw();
            }
            
        </script>
    </div>
</li>
<li>
    <div class="content" id="code">
        <h3>Code</h3>
        <pre class="brush:js">
                // dynamic data
                const MAX_VALUE = 100;
                function data_generator(){
                    return {time: Date.now(), value: Math.random() * MAX_VALUE};
                }
                function data_filter(data, period){
                    // keep data within period
                    if(period &lt;= 0){
                        return;
                    }
                    period = period * 1000; // s -> ms
                    let temp = data[data.length - 1].time;
                    while(data.length > 0 && data[0].time + period &lt; temp){
                        data.shift();
                    }
                    return;
                }
                
                
    
                const data = [];
                let svg = d3.select("#real-time");
                
                let padding = {t: 60, r: 40, b: 30, l: 40};
                let svgWidth = +svg.attr('width');    
                let chartWidth = svgWidth - padding.l - padding.r;
                
                const data_period = 5; // 10s
                let xScale = d3.scaleTime().range([0, chartWidth]); // dynamic domain, fixed domain
                let yScale = d3.scaleLinear().domain([0, MAX_VALUE]) // fixed domain, dynamic range.
                
                let xAxis = d3.axisBottom(xScale).ticks(8);
                let yAxis = d3.axisRight(yScale).ticks(4);
    
                let xSVGAxis = svg.append('g').attr('class', 'x axis'); // position is dynamic
                let ySVGAxis = svg.append('g').attr('class', 'y axis'); // position is dynamic
                let pathG = svg.append('g').attr('class', 'path-chart');
                let scatterplotG = svg.append('g').attr('class', 'scatter-plot');
                
                let path = pathG.append('path') // setup path
                    .datum(data)
                    .attr('fill', 'none')
                    .attr('stroke', 'blue')
                    .attr('stroke-width', '2px');
                let fun = d3.line()
                    .x((d)=>{ return xScale(d.time);})
                    .y((d)=>{ return yScale(d.value);})
                    .curve(d3.curveBasis); //optional curve
                
    
                function draw(){
                    let svgHeight = +svg.attr('height');
                    let chartHeight = svgHeight - padding.t - padding.b;
                    // set range and domain
                    let endTime = new Date(data[data.length - 1].time);
                    let startTime = new Date(data[data.length - 1].time - data_period * 1000);
                    xScale.domain([startTime, endTime]);
                    yScale.range([chartHeight , 0])
                    // set transform
                    xSVGAxis.attr('transform',`translate(${padding.l}, ${padding.t + chartHeight})`);
                    ySVGAxis.attr('transform', `translate(${padding.l + chartWidth}, ${padding.t})`);
                    pathG.attr('transform', `translate(${padding.l}, ${padding.t})` );
                    scatterplotG.attr('transform', `translate(${padding.l}, ${padding.t})`);
                    // draw
                    xSVGAxis.transition().call(xAxis);
                    ySVGAxis.transition().call(yAxis);
                    path.transition().attr('d', fun);
                    let scatterPlot = scatterplotG.selectAll('.point')
                        .data(data, (d)=>(d.time)); // bind data with k
                    let sp_enter = scatterPlot.enter()
                        .append('circle')
                        .attr('class', 'point')
                        .attr('fill', 'green')
                        .attr('r', 3)
                        .attr('cx', d=>{return xScale(d.time)})
                        .attr('cy', d=>{return yScale(d.value)})
                    sp_enter.merge(scatterPlot).transition()
                        .attr('cx', d=>{return xScale(d.time)})
                        .attr('cy', d=>{return yScale(d.value)})
                    scatterPlot.exit().remove();
                }
                
                setInterval(()=>{
                    data.push(data_generator());
                    data_filter(data, data_period);
                    console.log(data.length);
                    draw();
                },160);
                function increase_size(){
                    d3.select("#real-time")
                        .attr('height', parseInt(d3.select("#real-time").attr('height')) + 100);
                    draw();
                }
                function decrease_size(){
                    let h = parseInt(d3.select("#real-time").attr('height'));
                    if(h &lt;  150){
                        return;
                    }
                    d3.select("#real-time")
                        .attr('height',h - 100);
                    draw();
                }
        </pre>
        
    </div>
</li>
<li>
<div class="content" id="reference">
<h3>References</h3>
<div class="featureList">
    <ol>
        <li><a href="https://github.gatech.edu/CS-7450/Labs/wiki/Lab-4:-D3-Chart-Types-and-Scales" target="_blank">D3 Scale InfoVis Lab4.</a></li>
        <li><a href="https://github.gatech.edu/CS-7450/Labs/wiki/Lab-6:-D3-Enter,-Update-and-Exit" target="_blank">D3 D3 Enter, Update and Exit InfoVis Lab6.</a></li>
        <li><a href="https://bl.ocks.org/boeric/6a83de20f780b42fadb9" target="_blank">D3 Real Time Chart with Multiple Data Streams</a></li>
    </ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
