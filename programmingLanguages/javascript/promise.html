<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Javascript&nbsp;Promise</title>
<meta charset="utf-8">
<meta name="date" content="2018-04-07">
<meta name="keywords" content="javascript">
<meta name="keywords" content="promise">
<meta name="keywords" content="callback&nbsp;hell">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>JavaScript&nbsp;-&nbsp;Promise</strong></center>
</div>
<p class="date"><span class="created-date">Created:2018-04-07</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2018-04-07</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#promiseIntro">Introduction</a></li>
<li><a href="#promise3rdParty">3rd Party's Perspective</a></li>
<li><a href="#promiseReference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="promiseIntro">
<h3>Introduction</h3>
<p>Javascript is an asynchronous language. To implement functions synchronously, we frequently use callback functions.</p>
<p>But callback functions introduce the problem of callback hell or pyramid of doom. Promise can solve the problem.</p>
<h4>Promise</h4>
<p>Promise is like a programming scheme. It is initially developed by 3rd party, but now supported by ES2016. A new class, Promise</p>
<p>Using Promise, we can use the .then chain instead of callback.</p>
<h4>Roles</h4>
<p>ES2016: the provider of the Promise class</p>
<p>3rd party: the provider of a 3rd party package that enabled the Promise function.</p>
<p>developer: the user of the 3rd party package with Promise enabled.</p>
</div>
</li>
<li>
<div class="content" id="promise3rdParty">
<h3>3rd Party's Perspective</h3>
<p>The job of the 3rd parties is to make their packages support Promise scheme.</p>
<h4>Example of making XMLHttpRequest Promise</h4>
<p>XMLHttpRequest has a callback function called "onreadystatechange", it is invoked when the status of this request changes.</p>
<pre class="brush:js">
function httpGet(url){
    const xhttp=new XMLHttpRequest();
    const promise = new Promise((resolve, reject)=>{
        xhttp.onreadystatechange = function(){
            if(this.readyState == 4 &amp;&amp; this.status == 200){
                resolve(xhttp.responseText);
            }else{
                reject(xhttp.responseText);
            }
        };
        xhttp.open('GET', url, true);
        xhttp.send();
    });
    return promise;
}
function httpPost(url, data){
    const xhttp=new XMLHttpRequest();
    const promise = new Promise((resolve, reject)=>{
        xhttp.onreadystatechange = function(){
            if(this.readyState == 4 &amp;&amp; this.status == 200){
                resolve(xhttp.responseText);
            }else{
                reject(xhttp.responseText);
            }
        };
        xhttp.open('POST', url, true);
        xhttp.send(data);
    });
    return promise;
}
</pre>
<div class="featureList">
<ol>
<li>The above function returns a Promise instance. The Promise function takes a function as input.</li>
<li>The function is defined by 3rd-party. Moreover, this function also takes two functions as inputs.</li>
<li>The function is invoked by the ES2016 Promise, the two function arguments are also provided by the ES2016 Promise.</li>
<li>Inside the function, 3rd-party defines the task, and calls one of the argument functions.</li>
<li>resolve function: The function can take one argument, it will invoke the next "then" task.</li>
<li>reject function: The function can take one argument, it will invoke the next close "catch" task.</li>
</ol>
</div>
</div>
</li>
<li>
<div class="content" id="promiseDeveloper">
<h3>Developer's Perspective</h3>
<p>The usage of Promise scheme</p>
<pre class="brush:js">
httpGet('/hello').then(
(text)=>{ // text is the get http.responseText
    console.log(text);
    return httpPost('/hello', text);
})
.then(
(text)=>{ // text is the post http.responseText
    console.log(text);
    return 'success';
})
.then((text)=>{ // 'success'
    console.log(text);
});
</pre>
<div class="featureList">
<ol>
<li>A promise instance has a method called .then, which takes two optional functions. The first is used to handle successful case, The second handles error case. </li>
<li>The two functions are invoked by Promise after the 3rd party calls the "resolve" or "reject"</li>
<li>The input of the two functions are the input of the "resolve" and "reject". (ES2016 Promise stores "resolve" and "reject" input and gives to the developer's code)</li>
<li>ES2016 Promise makes "then" return a new Promise instance so that it can form a chain.</li>
<li>The two developer-defined functions can return any type of value, including a new Promise.</li>
<li><span style="color:red">If the return value of the developer-defined function is not a promise instance, then the value will be directly used as the input of next 
    "then" developer-defined functions</span></li>
<li><span style="color:red">If the return value of the developer-define function is a promise instance, then the promise's resolve/reject's arguments will be used as the input of next "then"'s developer-defined functions</span></li>
</ol>
</div>
<pre class="brush:js">
var p = new Promise((resolve, reject)=>{
    resolve(1);
});
p.then(function(v) {
    console.log('1: ', v); // 1: 1
    return v + 1;
})
.then(function (v){
    console.log('1: ', v); // 1: 2
    return new Promise((resolve)=>{
        resolve(100);
    });
})
.then(function (v){
    console.log('1: ', v);  // 1: 100
    return v + 1
})
</pre>
</div>
</li>
<li>
<div class="content" id="promiseES2016">
<h3>ES2016 JS's Perspective</h3>
<div class="featureList">
<ol>
<li>The promise has three status: 0):Pending, 1):fulfilled, 2):rejected</li>
<li>Two functions: resolve, reject</li>
<li>One value: value that stores the input argument of "resolve" or "reject" from 3rd party.</li>
<li>A list: stores then's function arguments provided by developers</li>
</ol>
</div>
<p></p>
</div>
</li>
<li>
<div class="content" id="promiseReference">
<h3>References</h3>
<div class="featureList">
<ol>
<li><a href="https://www.promisejs.org/implementing/" target="_blank">Promise Implementation</a></li>
</ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
