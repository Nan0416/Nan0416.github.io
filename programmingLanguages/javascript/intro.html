<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Javascript&nbsp;Syntax</title>
<meta charset="utf-8">
<meta name="date" content="2018-03-26">
<meta name="keywords" content="js">
<meta name="keywords" content="syntax">
<meta name="keywords" content="javascript">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>Javascript&nbsp;-&nbsp;Syntax</strong>
</div>
<p class="date"><span class="created-date">Created:2018-03-26</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2018-10-08</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#jsIntro">Introduction</a></li>
<li><a href="#jsConcept">Concepts</a></li>
<li><a href="#jsScope">Variable Scope</a></li>
<li><a href="#jsVariable">Declaring variables and variable types</a></li>
<li><a href="#jsThis">Nodejs "this"</a></li>
<li><a href="#jsClass">Class</a></li>
<li><a href="#jsFunction">Function calls</a></li>
<li><a href="#jsSyntax">Syntax</a></li>
<li><a href="#jsReference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="jsIntro">
<h3>Introduction</h3>
<p>1. JS is a weak type, interpreted, dynamic language.</p>
<p>2. programming paradigm: event-driven, functional, prototype-based and object-oriented</p>
<p>3. prototype-based: No class, a object is created from prototype or another object, new members can be directly added to objects.</p>
<p>4. JavaScript itself does not support I/O, but browser provide it ajax to make http request, node.js provide it i/o with libuv.</p>
<h4>History</h4>
<p>JavaScript is first released in 1995 with the Netscape Navigator (Web browser), developed by Brendan Eich.</p>
<p>In 1996, JavaScript is submitted to ECMA International in order to be standardized so than JS can be also implemented by other broswers. </p>
<p>The first ECMAScript specification (ECMA-262) was published in June 1997.</p>
<p>** JScript is Microsoft implementation of ECMAScript, it is used in IE.</p>
<h4>ECMAScript</h4>
<div class="featureList">
	<ol>
		<li>ES 5 (2009.12): strict mode</li>
		<li>ES 6 (2015.06): new syntax, class, modules, arrow functions, promise, collections, for/of loop</li>
		<li>ES 7 (2016.06): </li>
		<li>ES 8 (2017.06): syntactic integration with promises (async/await)</li>
		<li>ES 9 (2018.06): </li>
	</ol>
</div>
<p>** Because the actual implementation of ECMAScript standard is slower than the standard itself, current (2018.09) popular version of ES is ES6.</p>
</div>
</li>
<li>
<div class="content" id="jsConcept">
<h3>Concept</h3>
<div class="featureList">
<ol>
<li>function is same as variable => it causes local variable closore.</li>
<li>varaible has three different scopes: global, local, this</li>
</ol>
</div>
<div class="featureList">
<h4>Value and functions</h4>
<ol>
<li><p><i>Simple example</i></p>
<pre class="brush:js">
var local1 = 1;
console.log(local1);
var fun1 = function(p1){
	console.log(p1);
}
fun1("hello, world");
</pre>
</li>
<li>
<p><i>Closure</i></p>
<pre class="brush:js">
function L3(){
	var x = 10;
	function L4(){
		console.log(x);
		x = x + 1;
	}
	return L4;
}
l2 = L3(); // different from C, which stack is reclaimed after the method executing. The local variable x still exists.
l2();
l2();
</pre>
</li>
</ol>
</div>
</div>
</li>
<li>
<div class="content" id="jsScope">
<h3>Variable scope</h3>
<div class="featureList">
<ol>
<li>Module:</li>
<li>Global variable:  any variables declared at any location without "var".
<p>
	NodeJs <span style="color:blue">(No browser)</span> provides a couple of built-in global variables (and functions):<br>
	<div class="termniology">
	<ul>
	<li>__dirname: the absolute path of the js file's directory.</li>
	<li>__filename: the absolute path of the js file</li>
	<li>global: a special variable that all other global variable will be mounted onto this variable (including itself)
		<pre class="brush:js">
			x = 10;
			console.log(global.global.global.x); // 10
		</pre>
	</li>
	<li>... <a href="https://nodejs.org/api/globals.html#globals_global" target="_blank">Others</a></li>
	</ul>
	</div>
</p>
</li>
<li>local variable: any variables declared with a "var", it will become a local variable in this scope {}</li>
</ol>
<h4>JS executing order</h4>
<ol>
<li>scope is defined by {}. <span style="color:red">Before executing a function, JS scan the code first to find the right variable.</span>
<pre class="brush:js">
var variable = "variable in global";
function show(){
     
    console.log(variable);  // undefined
    var variable = "variable in local"; 
    console.log(variable);  // "variable in local"
};
show(); // "variable in local"
// ==================================================
var variable = "variable in global";
function show(){
     
    console.log(variable);  // "variable in global"
    // var variable = "variable in local"; 
    console.log(variable);  // "variable in global"
};
show(); // "variable in global"
</pre>
<p>JS first scans the code and finds that the show(){} defines the variable, so it will use the local variable.</p>
<p>However when executing the first console.log, the local variable is undefined yet, so print undefined.</p>
<p><span style="color:red">This feature applies to both let and var</span></p>
</li>
</ol>
</div>
</div>
</li>
<li>
<div class="content" id="jsVariable">
<h3>Declaring variables and variable types</h3>
<h4>declaring variables:let, var, const</h4>
<div class="featureList">
<ol>
<li>
No prefix: global variable.
<pre class="brush:js">
x = 10;
console.log(global.x);
</pre>
</li>
<li>
const: not mutable, declared once.
<pre class="brush:js">
const z = 11;
// const z = 12; // error
// z = 12; // error
</pre>
</li>
<li>
let: mutable, can be declared once, otherwise X redeclaration. Usually use in for-loop.
<span style="color:blue">{} inside {} access</span>
<pre class="brush:js">
let x = 11;
// let x = 12; // error
for(let x = 0; x &amp; 10; x++){

}
console.log(x); // 11
</pre>
</li>
<li>
var: mutable, can be declared multiple times. 
<span style="color:blue"> non (function) stack, global access</span>
<pre class="brush:js">
var y = 11;
var y = 12;
for(var y = 0; y &amp; 2; y++){
	var x = 10;
}
console.log(y); // 2
console.log(x); // 10
function func(){
	var z = 10;
}
// console.log(z); // error
</pre>
</li>
<li>
<h4>var vs. let</h4>
<p>let's variables has the traditional C-like scope
	<pre class="brush:js">
		let x = 10;
		{
			console.log(x); // *** not defined, the new define is below
			let x = 100;
			let x2 = 11;
			console.log(x); // 100
		}
		console.log(x); // 10
		console.log(x2) ; // not defined.
	</pre>
</p>
<p>all var's variables intend to be a function
	<pre class="brush:js">
		{
			var x2 = 10;
		}
		console.log(x2); // 10
		function printing(){
			for(var i = 0; i&lt;10; i++) {
			  console.log(i)
			}
		}
		printing()
		console.log(i) // undefined, var's scope is the function
	</pre>
</p>
</li>
</ol>
<h4>Variable types</h4>
<div class="featureList">
<ol>
<li>Primitive types: number, string, boolean, null, undefined, symbol : all symbol are unique. </li>
<li>Object: objects, Array, Date, Map, Set and Regex</li>
</ol>
</div>
</div>
</div>
</li>
<li>
<div class="content" id="jsThis">
<h3>Global "this"</h3>
<div class="featureList">
<ol>
<li>The "this" are different in the global environments of NodeJs and HTML</li>
<li>In html, the global "this" is set to the "window" object.</li>

<li>In nodejs, the "this" is referenced to the <i>module.exports</i> when using it in a global environment.
<pre class="brush:js">
// module_x.js
this.x = 10;
console.log(module.exports.x); // 10

// index.js
var x = require('module_x.js');
console.log(x.x); // 10
</pre>
</li>
<li>In nodejs, the "this" is referenced to the <i style="color:red">global</i> global variable when using it in a function.
<pre class="brush:js">
function f(){
	this.x = 10;
}
f();
console.log(x); // 10 
console.log(global.x); // 10
</pre>
<p>All defined global variable in the module will be mounted to the global variable.</p>
<p><a href="#nodejs_global">Global variable</a></p>
</li>
<li>
In nodejs, the "this" is referenced to its instance when using it in a constructor.
<p class="starMark">* If a function is called with a "new", then the function is treated as a constructor.</p>
<pre class="brush:js">
function f(){
	this.x = 10;
}
var f = new f();
console.log(this); // {}
console.log(global.x) // undefined.
</pre>
</li>
</ol>
</div>
</div>
</li>
<li>
<div class="content" id="jsClass">
<h3>Class</h3>
<div class="featureList">
<h4>Class and Object</h4>
<p>JS does not define how to create object, but we can simulate the class/object throught its features</p>
<ol>
<li><p><i>"Java anonymous class"</i></p>
<p>Don't have a name, it can only be instintiate once.</p>
<pre class="brush:js">
var local2_object ={
	x:1,
	y:-10,
	z:11
}
console.log(local2_object);
</pre>
<p>Uses Object.create(obj)</p>
<pre class="brush:js">
	var local3_object = Object.create(local2_object);
	// it creates a new copy of the object.
</pre>
</li>
<li>
<p><i>Using this. "This" is to create member with "new"</i></p>
<pre class="brush:js">
function L2(){
	this.x = 1;
	this.y = -10;
	this.z = 11;
	this.f(){
		console.log("L2");
	}
}
var local3_object = new L2();
console.log(local3_object);
</pre>
<p><i>What if we call L2(), instead of new</i></p>
<p class="starMark">* Then this function is just a regular function (a value), the "this" references the upper level "this". In this case, it is the global special "this".</p>
<p><i>Function code is not shared.</i></p>
<p><i>The function code (in terms of memory) is not shared. Every object of this class will have an independent memory storage for that function.</i></p>
<pre class="brush:js">
function L3(){
	this.x = 99;
	this.fc = function(){
		console.log(this.x); // this is used in a regular function
	}
}

var local4_x = new L3();
local4_x.fc();
local4_x.x = 11;
local4_x.fc();
</pre>
<p><i>But "this" does not have the ability to create a not existed member.</i></p>
<p><span style="color:red">Even though there is an implicit "this" in the global scope, "this" can only be used inside a function.</span></p>
<pre class="brush:js">
function L2(){
	this.x = 1;
}
L2();
console.log(this.x); // undefined.
console.log(x); // 1
this.x = 10;
console.log(x); // 1
this.y = 11;
console.log(this.y); // undefined

</pre>
</li>
<li>
<p><i>Mix return, new, this</i></p>
<pre class="brush:js">
function L3(){
	this.x = 10;
	this.y = 11;
	return 10;
}
f = L3();
console.log(f); // 10
n = new L3();
console.log(n); // L3 { x: 10, y: 11 }
</pre>
</li>
<li>
<i><p>Search order, local > this > global</p></i>
<pre class="brush:js">
gl = 19;
function L3(){
	this.gl = 10;
}

L3();
console.log(gl); // 10. using this

function L3(){
	var gl = 11;
	this.gl = 10;
	console.log(gl);
}

L3(); // 11
new L3(); // 11
</pre>
</li>
</ol>
</div>
</div>
</li>
<li>
<div class="content" id="jsFunction">
<h3>Function calls</h3>
<p> function 定义的argument和其他PL比及其不严格。 e.g. 定义 func( arg1, arg2) 看似要给两个argument，但是具体给几个是随便的。这个定义的arg1 和 arg2只是在define function时用着方便。可以 func(1, 2), func( ), func(1,2,3,4,5,5) .
本质上，每个function都是一个 object，而function的arguments就是这个function这个object的一个property</p>
<pre  class="brush:js">
arguments = {‘0’：1， ‘1’： 2}
</pre>
</div>
</li>
<li>
<div class="content" id="jsSyntax">
<h3>Syntax</h3>
<div class="featureList">
<ol>
<li>
<h4>Switch</h4>
<p>switch statement can take any type value.<br>
1). It compares values for primitive type.<br>
2). It compares reference for object type</p>
</li>
<li>
<h4>For-in loop</h4>
<pre class="brush:js">
var x = { 
	name:"Nan Qin",
	date:new Date(1994,4,16)
};
for(let key in x){ 
	if(x.hasOwnProperty(key)){ // testing the property is from itself, not from prototype.
		console.log(x[key])
	}	
}
</pre>
</li>
<li>
<h4>For-each loop</h4>
<pre class="brush:js">
Object.keys(x).forEach((key) => {}); // it gives the key as string. The keys are from its self.
</pre>
</li>
<li>
<h4>If</h4>
<p>If statement must followed with (), false, null, undefined will be traded as false </li></p>
</li>
</ol>
</div>
</div>
</li>
<li>
<div class="content" id="jsReference">
<h3>References</h3>
<div class="featureList">
<ol>
	<li><a href="https://en.wikipedia.org/wiki/ECMAScript#Versions" target="_blank">ECMAScript Wiki</a></li>
	<li><a href="http://www.jb51.net/article/81556.htm" target="_blank">Nodejs中的this详解</a></li>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling">JavaScript Guide</a></li>
</ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
