<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Java&nbsp;Generic</title>
<meta charset="utf-8">
<meta name="date" content="2018-03-15">
<meta name="keywords" content="power">
<meta name="keywords" content="atmega328p">
<meta name="keywords" content="microcontroller">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>Java&nbsp;-&nbsp;Generic</strong></center>
</div>
<p class="date"><span class="created-date">Created:2018-03-15</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2018-03-15</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#genericIntro">Introduction</a></li>
<li><a href="#genericClass">Generic Class</a></li>
<li><a href="#genericMethod">Generic Method</a></li>
<li><a href="#genericRestriction">Restriction on Type parameters (extends interface)</a></li>
<li><a href="#genericLimitation">Limitation</a></li>
<li><a href="#genericInheritance">Generic Inheritance</a></li>
<li><a href="#genericReference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="genericIntro">
<h3>Introduction</h3>
<p>Generic: class as variable (Type variable)</p>
<p>A generic class can have several type variable (the type can be class, interface)</p>
<p>Compared to use Object class as a "generic" class, we don't need <span style="color:red">cast</span> by using type variables.</p>
</div>
</li>
<li>
<div class="content" id="genericClass">
<h3>Generic Class</h3>
<h4>Example</h4>
<pre class="brush:java">
public class Generic1 &lt;T, V> {
    private T key;
    private V value;

    public void print(){
        System.out.println("Key: " + key + ",Value: " + value);
    }

    public Generic1(T t, V v){
        key = t;
        value = v;
    }
    public V getValue(){
        return value;
    }
    public static void main(String [] args){
        Generic1&lt;String, String> g = new Generic1&lt;>("one","yi");
        g.print();
        String v = g.getValue();
        System.out.println("value : " + v);
    }
}
</pre>
<p>After creating an instance with type variables setting to String, then we actually get a new class's object.</p>
<p>The class is</p>
<pre class="brush:java">
public class Generic1 {
    private String key;
    private String value;

    public void print(){
        System.out.println("Key: " + key + ",Value: " + value);
    }

    public Generic1(String t, String v){
        key = t;
        value = v;
    }
    public String getValue(){
        return value;
    }
    public static void main(String [] args){
        Generic1 g = new Generic1("one","yi");
        g.print();
        String v = g.getValue();
        System.out.println("value : " + v);
    }
}
</pre>
<div class="featureList">
<ol>
<li>One generic class can have multiple type variables, they are declared at the first line.</li>
<li>In the constructor, no type variable is needed. Use them as a regular type.</li>
<li><strong>Cannot directly instantiate type parameter. e.g. Cannot T t = new T();</strong></li>
</ol>
</div>
</div>
</li>
<li>
<div class="content" id="genericMethod">
<h3>Generic Method</h3>
<p>The class is not a generic class, but one of the methods can be a generic method.</p>
<pre class="brush:java">
public class GenericMethod {
    public static &lt;T> void print(T v, T x){
        System.out.println(v + " " + x);
        System.out.println(v.getClass().getName()); // dynamic binding print the actual class, not the infered generic type
        System.out.println(x.getClass().getName());
    }
    public static void main(String [] args){
        print("x", "y"); // auto inference
        print(12, 2.01);
        print(13, "u");
        GenericMethod.&lt;String>print("s", "w");
    }
}

</pre>
<h4>Auto inference</h4>
<p>We can directly use the print function, because the compiler can automatically inference the value's type.</p>
<p>Inference rule: e.g. print(13, "u"). <br>
1. wrap the primary type with Integer <br>
2. find the Integer and String's common parent, which is Object <br>
3. Call .toString inside the println.
</p>

</div>
</li>
<li>
<div class="content" id="genericRestriction">
<h3>Restriction on Type parameters with bounding types</h3>
<p>In above example, the type parameter can be any types. But sometimes, we need guarantee that the supplied type parameters have some common features, such as has a common function.</p>
<h4>Solution</h4>
<pre class="brush:java">
public class GenericBound&lt;T extends InterFace>
</pre>
<p>The InterFace is called bounding types.</p>
<h4>Generic Interface</h4>
<pre class="brush:java">
interface Numeric&lt;T>{
    T init();
    T Sum(T v);
    void print();
}
</pre>
<h4>Implement a generic interface</h4>
<pre class="brush:java">
class F implements Numeric&lt;F>{
    private int x;
    public F(int x){
        this.x =x;
    }
    @Override
    public F init(){
        return new F(0);
    }
    @Override
    public void print(){
        System.out.println(x);
    }
    }
    @Override
    public F Sum(F x){
        return new F(this.x + x.x);
    }
}
</pre>
<h4>The interface becomes</h4>
<pre class="brush:java">
interface Numeric{
    F init();
    F Sum(F v);
    void print();
}
</pre>
<h4>Use this interface</h4>
<pre class="brush:java">
public class GenericBound&lt;T extends Numeric&lt;T>> 
</pre>
</div>
</li>

<li>
<div class="content" id="genericLimitation">
<h3>Limitation</h3>
<p>The generic feature is achieved by the compiler replacing generic type with Object, and insert type parameter for casting.</p>
<div class="featureList">
<ol>
<li>Cannot instantiate type variable: because the <i>T t = new T()</i> is translated to <i>(T) t = (T) new Object()</i><br>
Same as this, new T[10] and T.class are also forbidden. <br>
<strong>Create type parameter's object</strong>: give a type's Class from outside, and call newInstance.
<pre class="brush:java">
public static &lt;T> Pair&lt;T> makePair(Class&lt;T> cl)
{
   try { return new Pair&lt;>(cl.newInstance(), cl.newInstance()) }
   catch (Exception ex) { return null; }
}
</pre>
</li>
<li></li>
</ol>
</div>
</div>
</li>
<li>
<div class="content" id="genericInheritance">
<h3>Generic Inheritance</h3>
<p>Employee is a super class of Manager, but Generic&lt;Employee> is not a super class of Generic&lt;Manager></p>
<h4>Wildcard</h4>
<p>Suppose a relation Employee -> Manager -> CEO</p>
<p>? extends Manager can match Manager and CEO; ? super Manager can match Employee and Manager</p>
<div class="featureList">
<ol>
<li>Wildcard 不是用着declaration.e.g. 不是public class G&lt;? extends Employee> </li>
<li>Wildcard 是用于define generic class type. 相当于Set&lt;String>里的String那个位置</li>
<li>Generic&lt;? extends Manager> is a super class of Generic&lt;Manager> and Generic&lt;CEO><br>
It can match the two classes.<br>
<strong>Generic&lt;? extends Manager> can only be used as a return type.</strong>
<p>Reason</p>
<pre>
Suppose Generic&lt;T> provide a method called "void set(T x)" and "T get()"
Generic&lt;Manager> => "void set(Manager x)" and "Manager get()"
Generic&lt;CEO> => "void set(CEO x)" and "CEO get()"
Generic&lt;? extends Manager> is either a Generic&lt;Manager> and Generic&lt;CEO>
=> "void set(? extends Manager x)" and "? extends Manager get()"
For safety => it can only set a high detailed class "void set(CEO x)" and return a low detailed "Manager get()".
But because there is no language guarantee that set will set the  high detailed class, so the set is forbidden, only get is allowed 
// 不管返回什么样的type，一定是extends Manager.
set的argument不一定满足标准，但是get的return value一定可以
</pre>
<strong>Generic&lt;? super Manager> can only be used as an argument type.</strong>
<p>Reason</p>
<pre>
Suppose Generic&lt;T> provide a method called "void set(T x)" and "T get()"
Generic&lt;Manager> => "void set(Manager x)" and "Manager get()"
Generic&lt;Employee> => "void set(Employee x)" and "Employee get()"
Generic&lt;? super Manager> is either a Generic&lt;Manager> and Generic&lt;Employee>
=> "void set(? super Manager x)" and "? super Manager get()"
For safety => it can only set a high detailed class "void set(CEO x)" and return a low detailed "Manager get()".
But because there is no language guarantee that set will set the  high detailed class, so the set is forbidden, only get is allowed 
// 不管返回什么样的type，一定是extends Manager.
set的argument不一定满足标准，但是get的return value一定可以
</pre>


<h4>Example</h4>
<pre class="brush:java">
public class Wildcard{

    public void show2(OperatePeople&lt;? super Manager> p){
        // 这里能把　? super manager　传进来是因为 p　可能会调用一些他自己的方法，
        // 对于不同的　matched OperationPeople, e.g. OperatePeople&lt;Manager> 和　OperatePeople&lt;Employee>
        // p　所拥用的　methods 是一样的，只是他们的argument type可能不一样，有的是Manager,　有的是Employee, 总而言之，都是Manager本身或者是他的父类。
        // e.g. print(Manager ), print(Employee ),　只要是Manager本身或者是他的父类的object都可以被传进去。
        // 而又因为这个用了wildcard，
        // 也就是说，一个OperatePeople&lt;Employee>的print(Employee)　可能要去处理一个Manager的object。还好这个是允许的。
        // 但是　假设这里给的是　OperatePeople&lt;? extend Manager> p, 这就意味着一个OperatePeople&lt;CEO>的print(CEO)要去处理一个Manager，这就是不允许的了。
        Manager e = new Manager("Manager");
        p.print(e);
    }
    public OperatePeople&lt;? extends Manager> show3(){
        // return a subclass, more detailed class
        OperatePeople&lt;Manager> x = new OperatePeople&lt;>();
        return x;
    }
    public static void main(String [] args){
        Wildcard w = new Wildcard();
        OperatePeople&lt;Employee> eo = new OperatePeople&lt;>();
        OperatePeople&lt;Manager> mo = new OperatePeople&lt;>();
        OperatePeople&lt;CEO> co = new OperatePeople&lt;>();
        OperatePeople&lt;? super Manager> cm = eo;


        w.show2(cm, new Manager("Manager"));
        // cm is eo, eo's T is Employee, set an Manager object to an Employee is OK
        // Suppose cm is co, co's T is CEO, set an Manager object to an CEO is not allowed.
    }
}

class OperatePeople&lt;T>{
    private T x; 
    public void print(T p){
        x = p; 
        System.out.println(p);
    }
}

class Employee{
    public String name;

    @Override
    public String toString() {
        return name;
    }

    public Employee(String name){
        this.name = name;
    }
}
class Manager extends Employee{
    public Manager(String name){
        super(name);
    }
}
class CEO extends Manager{
    public CEO(String name){
        super(name);
    }
}
</pre>
</li>
</ol>
</div>
<p></p>
</div>
</li>
<li>
<div class="content" id="genericReference">
<h3>References</h3>
<div class="featureList">
<ol>
<li><a href="http://proquestcombo.safaribooksonline.com.ezp3.lib.umn.edu/9780137082346?uicode=umntc">Core Java Volume I. Ch12. Generic Programming.</a></li>
</ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
