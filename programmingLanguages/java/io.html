<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Java&nbsp;File I/O</title>
<meta charset="utf-8">
<meta name="date" content="2018-03-11">
<meta name="keywords" content="java">
<meta name="keywords" content="i/o">

<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>Java&nbsp;-&nbsp;File I/O</strong>
</div>
<p class="date"><span class="created-date">Created:2018-03-11</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-01-29</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#ioIntro">Introduction</a></li>
<li><a href="#ioFileByte">File I/O Byte</a></li>
<li><a href="#ioFileChar">File I/O Char</a></li>
<li><a href="#ioflush">Flush</a></li>
<li><a href="#ioFile">File Class</a></li>
<Li><a href="#ioRedirection">Redirection</a></Li>
<li><a href="#ioReference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="ioIntro">
<h3>Introduction</h3>
<p>Java IO: two types of stream</p>
<div class="featureList">
<h4>I. Byte: (1byte)</h4>
<p><strong>abstract</strong> class InputStream implements <strong>Closeable</strong> and <strong>AutoCloseable (JDK 7)</strong></p>
<p><strong>abstract</strong> class OutputStream implements <strong>flushable</strong>, <strong>Closeable</strong> and <strong>AutoCloseable</strong></p>

<ol>
<li>abstract int read(): return the next byte, -1 means end</li>
<li>int read(byte[]): read a chunck of byte with at most b.length; return the number of read byte</li>
<li>int read(byte[], int offest, int len): </li>
<li>int avaliable(): return an estimate of the number of bytes that can be read.</li>
<li>void close(): </li>
<li>long skip(long n): discard the first n bytes, return the actual skipped bytes</li>
<li>void mark(int readLimit): mark the current stream position. The mark will be invaliated after reading "readLimit" bytes.</li>
<li>void reset(): go back the mark position.</li>
<li>boolean markSupported(): test if this stream supports mark.</li>
</ol>
<p class="starMark">* 3 input functions, 4 position functions. Except mark and markSupported, all others throw IOException</p>
<br>
<ol>
<li>abstract void write(int b): Write a byte; The int is treated as a byte by ignoring the first 24-bit</li>
<li>write(byte [] b):</li>
<li>write(byte [] b, int off, int len): the len and offset are in terms of the byte[], not the stream.</li>
<li>flush(): enforce any buffered output bytes to be written out.</li>
<li>close(): autoflash</li>
</ol>
<h4>II. char: (2byte Unicode)</h4>
<p><span style="color:red">char and String can understand and represent "好", "a". However, byte can only understand 0x7F.<br>
char and String can convert "好"，"a" to bytes according to charset, e.g. GBK or UTF-8.
</span></p>
<p>So Java char stream are built on Java byte stream with an extra encoding/decoding function.</p>
<p><strong>abstract</strong> class Reader implements <strong>Readable</strong> and <strong>Closeable</strong>,没有auotcloseable</p>
<p><strong>abstract</strong> class Writer implements <strong>Closeable</strong>, <strong>Flushable</strong>, <strong>Appendable</strong>, and <strong>AutoCloseable</strong></p>
<ol>
<li>int read(): blocked read, return a char value from 0x0000-0x00ff. -1 indicates end</li>
<li>abstract int read(char [] buf, int off, int len): </li>
<li>int read(char [] buf):</li>
<li>int read(CharBuffer target): </li>
<li>boolean ready(): return true if the next read is guarantee not blocked.</li>
<li>mark, marksupported, reset</li>
<li>skip</li>
<li>close</li>
</ol>
<br>
<ol>
<li>write(int c), write(char [] buf), write(char [] buf, int off, int len), write(String), write(String, int off, int len)</li>
<li>flush</li>
<li>close</li>
<li>append(char c),append(CharSequence csq), append(CharSequence csq, int start, int end): return the writer object.</li>
</ol>
<p>class InputStreamReader extends Reader implements <strong>AutoCloseable</strong></p>
<p>比Reader多了一个getEncoding():, encoding is set when creating the stream, constructor</p>
<br>
<p>Closeable: defines a close function: which is intented to relinquish resources.</p>
<p>AutoCloseable: defines a close function: which can be used with the try-with-resources statement (since Java7)</p>
<p>byte vs char: byte没有ready,char没有avaliable, reader没有autocloseable</p>
<p><img src="./img/javaio.png" width="800" height="250"></p>
<p><img src="./img/javaio2.png" width="800" height="250"></p>
</div>
</div>
</li>
<li>
<div class="content" id="ioFileByte">
<h3>File I/O Byte</h3>
<pre>
InputStream &lt;- FileInputStream
OutputSream &lt;- FileOutputStream
</pre>
<h4>functions notes</h4>
<p>
1. avaliable() function can return the actual number of remain byte. If using it before read, it can return the size of the file.<br>
2. constructor with string argument throw FileNotFound exception<br>
3. does not support mark
</p>

<pre class="brush:java">
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Arrays;

public class FileIO {
    public static void main(String [] args) throws IOException{
        FileInputStream in;
        try{
            in = new FileInputStream("udisk.tar.gz");
        }catch (FileNotFoundException e){
            System.out.println("file not found");
            return;
        }

        System.out.println("available : " +in.available() );

        byte [] buffer = new byte[10];
        int num = 0;
        num = in.read(buffer);
        System.out.println(num + " " + Arrays.toString(buffer));
        num = (int)in.skip(10);
        System.out.println(num);
        num = in.read(buffer);
        System.out.println(num + " " + Arrays.toString(buffer));
        if(in.markSupported()) {
            in.mark(100);
            num = in.read(buffer);
            System.out.println(num + " " + Arrays.toString(buffer));
            in.reset();
            num = in.read(buffer);
            System.out.println(num + " " + Arrays.toString(buffer));
        }
        in.close();
    }
}
</pre>

<h4>try-with-resources (autocloseable)</h4>
<p>close function is called in the finally statement, however, close function can also throw IOException, then we have to throw IOException from the function</p>
<pre class="brush:java">
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class FileIO3 {
    public static void main(String [] args) throws FileNotFoundException, IOException{
        FileInputStream in = new FileInputStream("Tesing.txt");

        try {
            in.read();
        }catch (IOException e){

        }finally {
            in.close(); // throw IOException in finally block
        }
    }
}
</pre>
<pre class="brush:java">
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class FileIO2 {
    public static void main(String [] args){
        try (FileInputStream in = new FileInputStream("Tesing.txt")) {
            // implement AutoCloseable, automatically call close, which is throw IOException
            //
        }catch (FileNotFoundException e){

        }catch (IOException e){

        }
    }
}
</pre>
<h4>FileOutputStream</h4>
<p>It allows appending. FileOutputStream(String, boolean append)</p>
<pre class="brush:java">
import java.io.FileOutputStream;
import java.io.IOException;

public class FileIO4 {
    public static void main(String [] args) throws IOException, InterruptedException{
        FileOutputStream out = new FileOutputStream("Testing.txt");
        byte[] x = new byte[]{113, 110,110};
        out.write(x, 0, 3);
        //out.flush();
        Thread.sleep(6000);
        out.close();
    }
}
</pre>
<h4>DataInputStream/DataOutputStream</h4>
<p>These two classes can read a datum and convert (interpret) it to as certain types, such as byte, float, long, UTF (a character)</p>
</div>
</li>
<li>
<div class="content" id="ioFileChar">
<h3>File I/O Char</h3>
<pre>
Reader &lt;-InputStreamReader &lt;- FileReader
Writer &lt;-OutputSreamWriter &lt;- FileWriter
</pre>
<p>The FileReader always use Java default charset (utf-8), but the input file may be encoded in a different charset.</p>
<p>FileReader has the same methods as the InputStreamReader. InputStreamReader can be created from InputStream with a decoder charset.</p>
<p>To designate a charset for FileReader, create as following: 1. Open a FileInputStream, 2 give it to a Reader with a charset.</p>
<pre class="brush:java">
    import java.io.FileInputStream;
    import java.io.FileNotFoundException;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.nio.charset.Charset;
    
    public class FileIO6 {
        public static void main(String [] args){
            try(FileInputStream fi = new FileInputStream("txe");  // txe is encode in GBK
                InputStreamReader ir = new InputStreamReader(fi, Charset.forName("GBK"));
            ){
                System.out.println(ir.getEncoding());
                char [] bu = new char[1];
                ir.read(bu);  // the read convert GBK to UTF-8, can print.
                System.out.println(bu);
                System.out.println((int)bu[0]);
            }catch (FileNotFoundException e){
    
            }catch (IOException e){
    
            }
        }
    }
</pre>
<h4>File IO read and write text</h4>
<p>FileReader -> BufferedReader</p>
<p>BufferedWriter -> FileWriter</p>
<pre class="brush:java">
    public static void main(String [] args) throws IOException{
        // FileInputStream ins = new FileInputStream("resouces.txt");
        FileReader fr = new FileReader("resources.txt");
        BufferedReader br = new BufferedReader(fr);
        FileWriter fw = new FileWriter("output.txt");
        BufferedWriter bw = new BufferedWriter(fw);
        String text = br.readLine(); // ignore the \n
        while(text != null) {
            System.out.println(text);
            bw.write(text);
            text = br.readLine();

        }
        br.close();
        bw.close();
        fw.close();
        fr.close();
    }
</pre>
</div>
</li>
<li>
    <div class="content" id="ioflush">
        <h3>IO flush</h3>
        <p>
            When writing data to network or files, data is not write until close or flush.
            <br>PrintStream/PrintWrite has a autoflush function that auto invoking the flush when encountering a new line. e.g. println() or print('qinnan/n');
        </p>
        <p>
            When read data from network or files, Buffered input's readLine will not return until a /n is encoutering. This readLine function eliminates the new line char. 
        </p>
    </div>
</li>
<li>
<div class="content" id="ioFile">
<h3>File Class</h3>
<p>File class: a representation of a file or directory.</p>
<p>It executes operations on a file, such as creation, deletion, check permission, getName, getParent, test if a directory</p>
<h4>functions</h4>
<div class="featureList">
<ol>
<li>.createNewFile(): boolean, true if success, false if already exists.</li>
<li>.mkdir(): create directory</li>
<li>.mkdirs(): create directories on the path. e.g. ./dir1/dir2. It will create dir1 too.</li>
</ol>
</div>
<pre class="brush:java">
import java.io.File;
import java.io.IOException;

public class FileIO7 {
    public static void main(String [] args) throws IOException {
        File f = new File("./ne/we");
        f.createNewFile();
        System.out.println(f.getAbsolutePath());
        System.out.println(f.getCanonicalPath());
        f.delete();
    }
}
</pre>
</div>
</li>
<li>
<div class="content" id="ioRedirection">
<h3>Redirection</h3>
<div class="featureList">
<p>java.lang.System defines 3 standard I/O,</p>
<ol>
<li>static final InputStream in</li>
<li>static final PrintStream out</li>
<li>static final PrintStream err</li>
</ol>
<p>They are opened when launching the Java VM, closed at the end of the process.</p>
</div>
<h4>Redirection</h4>
<p>Same as Unix, the 3 standard i/o objects can be redirected.</p>
<div class="featureList">
<ol>
<li>static void setIn(InputStream in)</li>
<li>static void setOut(PrintStream out)</li>
<li>static void setErr(PrintStream err)</li>
</ol>
</div>
</div>
</li>
<li>
<div class="content" id="ioReference">
<h3>References</h3>
<div class="featureList">
<ol>
<li>
<a href="http://blog.csdn.net/zhangerqing/article/details/8466532" target="_blank">Java I/O UML</a>
</li>
</ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
