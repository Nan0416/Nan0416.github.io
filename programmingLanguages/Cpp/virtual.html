<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>System&nbsp;Control</title>
<meta charset="utf-8">
<meta name="date" content="2017-12-28">
<meta name="keywords" content="power">
<meta name="keywords" content="atmega328p">
<meta name="keywords" content="microcontroller">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>C++&nbsp;-&nbsp;Virtual functions</strong></center>
</div>
<p class="date"><span class="created-date">Created:2018-01-19</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2018-04-03</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#virtualIntro">Introduction</a></li>
<li><a href="#virtualExample">Examples</a></li>
<li><a href="#virtualReferences">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="virtualIntro">
<h3>Introduction</h3>
<p>Virtual function (A special override) achieved a runtime polymorphism instead of compile-time. [late binding]</p>
<p>It allowes a child class object but is declared as parent class to call the child functions.</p>
<p>Only accessing via <span style="color:red">pointer or reference</span> of parent type can achieve the runtime polymorphism.</p>
<p> for deconstructor</p>
<div class="featureList">
<h4>Features</h4>
<ol>
<li>Only parent class need the virtual keyword</li>
<li>No virtual member variables</li>
<li>Private/Protected modifier is static, but virtual function is dynamic.</li>
<li>virtual functions can be defined as public, protected or private in the Parent class. But Attention: modifier is static even with a pointer or reference type</li>
</ol>

</div>
</div>
</li>
<li>
<div class="content" id="virtualExample">
<h3>Example</h3>
<h4>Pure virtual function</h4>
<p>In the parent declaration, we add a "= 0" after the virtual function, then the virtual function becomes a pure virtual function</p>
<p>Pure virtual function is like java's abstract function, where we don't need to implement the function inside the parent class, and the 
    parent class is not instantiatable. Subclass may implement this function if they want to be instantiated.</p>
<pre class="brush: cpp">
class Parent{
    public:
        virtual void func() = 0;
        virtual void func2() const = 0; // virtual function cannot modify the value of this object
}
class Child{
    public:
        void func() override; // keyword comes from -suggest-override
        void func2() const override;
}
// In the .cc file, the "override" is not required, but const is still needed.
// override is a mark, const is part of the signature.
</pre>
<h4>Others</h4>
<pre class="brush: cpp">
    #include &lt;iostream>
        using namespace std;
        class Parent{
        public:
            Parent();
            void display();
            virtual void virtualDisplay();
        };
        Parent::Parent(){
            cout &lt;&lt; "Parent constructor" &lt;&lt; endl;
        }
        void Parent::display(){
            cout &lt;&lt; "Parent display" &lt;&lt; endl;
        }
        void Parent::virtualDisplay(){
            cout &lt;&lt; "Parent virtual display "  &lt;&lt; endl;
        }
        //========
        class Child: public Parent{
        public:
            Child();
            void display();
            void virtualDisplay();
        };
        Child::Child(){
            cout &lt;&lt; "Child Constructor" &lt;&lt; endl;
        }
        void Child::display(){
            cout &lt;&lt; "Child display" &lt;&lt; endl;
        }
        void Child::virtualDisplay(){
            cout &lt;&lt; "Child virtual display "  &lt;&lt; endl;
        }
        void callByReference(Parent &amp; p){
            p.virtualDisplay();
        }
        void callByValue(Parent p){
            p.virtualDisplay();
        }
        int main(){
            Child c; // Parent constructor /n Child constructor
            Parent p2 = c; /* it is just an assignment, but p2 is staticly bind to c's inherited parent method*/
            Parent * p = &c;
            p->display(); // Parent display
            p->virtualDisplay(); // Child virtual display
            p2.virtualDisplay(); // Parent virtual display
            
            callByReference(c); //Child virtual display
            callByValue(c); //Parent virtual display
            return 0;
        }
</pre>
<h4>Protected virtual function: provide an encapsulation</h4>
<pre class="brush: cpp">
    #include &lt;iostream>
        using namespace std;
        class Parent{
        public:
            Parent();
            void display();
        protected:
            virtual void virtualDisplay();
        };
        Parent::Parent(){
            cout &lt;&lt; "Parent constructor" &lt;&lt; endl;
        }
        void Parent::display(){
            // do something
            virtualDisplay();
            // do something
        }
        void Parent::virtualDisplay(){
            cout &lt;&lt; "Parent virutal display" &lt;&lt; endl;
        }
        //========
        class Child: public Parent{
        public:
            Child();
        protected:
            void virtualDisplay();
        };
        Child::Child(){
            cout &lt;&lt; "Child Constructor" &lt;&lt; endl;
        }
        
        void Child::virtualDisplay(){
            cout &lt;&lt; "Child virtual display "  &lt;&lt; endl;
        }
        void callByReference(Parent &amp; p){
            p.display();
        }
        void callByValue(Parent p){
            p.display();
        }
        int main(){
            Child c; // Parent constructor /n Child constructor
            Parent p2 = c;
            Parent * p = &c;
            p->display(); // Child virtual display
            callByReference(c); //Child virtual display
            callByValue(c); //Parent virtual display
            return 0;
        }
</pre>
<h4>static binded modifier</h4>
<p><a href="./program/virtualPrivate.cpp">Source code</a></p>
<pre class="brush: cpp">
#include &lt;iostream>
using namespace std;
class F{
private:
    virtual void func(){cout &lt;&lt; "Parent Private virtual function" &lt;&lt; endl;}

};
class E: public F{
public:
    void func(){cout &lt;&lt; "Child Public virtual function" &lt;&lt; endl;}

};
int main(){
    E e;
    F * f = &amp;e;
    e.func();
    //f->func(); private modifer static bind
}
</pre>
</div>
</li>
</ol>
</div>
    
</body>
</html>
