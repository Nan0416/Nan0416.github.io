<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>C++&nbsp;Class</title>
<meta charset="utf-8">
<meta name="date" content="2018-01-13">
<meta name="keywords" content="C++">
<meta name="keywords" content="class">
<meta name="keywords" content="object">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>

<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />


</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>C++&nbsp;-&nbsp;Class</strong></center>
</div>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#classTips">Class Notes</a></li>
<li><a href="#"></a></li>
<li><a href="#"></a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="classTips">
<h3>Class Notes</h3>
<div class="featureList">
<h4>Modifiers</h4>
<ol>
<li><p><span style="font-weight:bold">Default modifier</span>: private. There are three modifier in C++ (public, protected, private); There are four modifier in Java (public, default, protected, private).</p></li>
<li><p><span style="font-weight:bold">Private modifier</span>: Only inside this class or friend class/function. The child class has this field, but cannot access it.</p></li>
<li><p><span style="font-weight:bold">Protected modifier</span>: Inside class, friend class/function, and subclass.</p></li>
<li><p><span style="font-weight:bold">Public modifier</span>: All place.</p></li>
</ol>
</div>

<div class="featureList">
<h4>Operators</h4>
<ol>
<li><p><span style="font-weight:bold">.</span> envoke the member of an <mark>object</mark>.</p></li>
<li><p><span style="font-weight:bold">::</span> define or call the member of a <mark>class</mark>. (static members of a class)</p></li>
<li><p><span style="font-weight:bold">:</span> followed by the constructor initialization section e.g. BankAccount::BankAccount(): balance(0){}</p></li>
</ol>
</div>

<div class="featureList">
<h4>Other</h4>
<ol>
<li><p><span style="font-weight:bold">this</span>: this is a keywork used inside the definition of an class. Suppose the class's object is created, this is a pointer that points to the object. (Java self.)</p></li>
</ol>
</div>

<div class="featureList">
<h4>Constructor/Destructor (Suppose class name is BankAccount)</h4>
<ol>
<li><p><span style="font-weight:bold">In-class initialization (a feature of C++11)</span>:</p></li>
<li><p><span style="font-weight:bold">Default constructor</span>: the constructor without arguments. The compiler gives a default constructor that does nothing if no constructor is defined.
<pre class="brush: cpp">
class BankAccount{
public:
    BankAccount(); // no return type
};

BankAccount::BankAccount(){
    // initialization
}
int main(){
    BankAccount ba; // BankAccount ba(); is wrong
    BankAccount ba2 = BankAccount(); // it is only take one step. int x = 1;
    BankAccount * baP = new BankAccount;
    delete baP;
}
</pre>
</p></li>
<li><p><span style="font-weight:bold">Other Constructor</span>: the constructor with arguments. 
<p class="starMark"><span style="color:red;">* C++ does not allow to call constructors in another constructor by using this-></span>, but in C++11 the constructor delegation allows to take one constructor inside another. (有助于代码复用）</p>
<pre class="brush: cpp">
#include &lt;iostream>
using namespace std;
class BankAccount{
public:
    BankAccount(); // no return type
    BankAccount(int x);
    int getX();
private:
    int x;
};

BankAccount::BankAccount(){
    x = 0;
    // this->BankAccount(11); // wrong, cannot call self class constructor inside a constrcutor
}
BankAccount::BankAccount(int x){
    this->x = x;
}
int BankAccount::getX(){
    // this->BankAccount(11); // wrong, cannot call self class constructor inside a member function
    return x;
}
int main(){
    BankAccount ba; // BankAccount ba(); is wrong
    cout &lt;&lt; ba.getX() &lt;&lt; endl;
    BankAccount * baP = new BankAccount(10);
    cout &lt;&lt; baP->getX() &lt;&lt; endl;
    delete baP;
}
</pre>
</p></li>
<li><p><span style="font-weight:bold">Constructor initialization section</span>: feature for convenience, used in the definition.
<pre class="brush: cpp">
class BankAccount{
public:
    BankAccount();
    BankAccount(double balance, double interest);
private:
    double balance;
    double interest;
};

BankAccount::BankAccount():balance(0), interest(0){
    // init
}
BankAccount::BankAccount(double balance, double interest):balance(balance), interest(interest){ // can be same name
    // init
    // it is equivalent to place the assigments at the very begin of the function, 
    cout &lt;&lt; this->balance &lt;&lt; endl;
}
</pre></p></li>
<li><p><span style="font-weight:bold">Constructor delegation</span>: C++11's feature that allows one constructor to call another constructor. The syntax is similar to the 
constructor initialization section.
<pre class="brush: cpp">
class BankAccount{
public:
    BankAccount();
    BankAccount(double balance, double interest);
private:
    double balance;
    double interest;
};

BankAccount::BankAccount(): BankAccount(0.0, 0.0){ // delegation calls another constructor. 
    // init
}
BankAccount::BankAccount(double balance, double interest):balance(balance), interest(interest){ // initialization section
    //
}
</pre></p></li>
<li><p><span style="font-weight:bold">Copy constructor</span></p>
<p>A copy constructor is a member function, which initializes an object using another object of the same class.</p>
<p>Signature: <span style="color:red;">Complex(const Complex&amp; c);</span> // it must be const &amp; </p>
<div class="featureList">
<h4>Invoke copy constructor</h4>
<ol>
<li>e.g. ClassType p1; ClassType p2 = p1; // this will invoke the copy constructor</li>
<li>void func(ClassType p1); func(p); // this call by value also invokes the copy constructor</li>
</ol>
</div>
<p><span style="color:red">default copy constructor</span>: primitive type just re-assign value, class type continues to call their copy constructor. So the pointer type is just copied a new pointer, the memory allocation is not copied.</p>
<p><a href="./program/copy_constructor.cpp">Source code</a></p>
<pre class="brush: cpp; highlight : [44,45];">
                #include &lt;iostream>
                using namespace std;
                class Complex{
                public:
                    int x = 0;
                    int y = 0;
                    Complex();
                    Complex(int x, int y);
                    Complex(const Complex &lt;c);
                    // const means c cannot be modified, &lt; means call by reference,
                    // it cannot use call by value, since the call by value will use this constructor.
                };
                Complex::Complex(int x, int y):x(x), y(y){
                    cout &lt;&lt; "constructor called" &lt;&lt;  endl;
                }
                Complex::Complex():Complex(0,0){
                }
                Complex::Complex(const Complex &amp;c){
                    cout &lt;&lt;  "copy constructor" &lt;&lt;  endl;
                    x = c.x;
                    y = c.y;
                }
                void printComplexReference(Complex &amp; c){
                    if(c.y > 0){
                        cout &lt;&lt;  c.x &lt;&lt;  " + i" &lt;&lt;  c.y &lt;&lt;  endl;
                    }else if(c.y  0){
                        cout &lt;&lt;  c.x &lt;&lt;  " - i" &lt;&lt;  -c.y &lt;&lt;  endl;
                    }else{
                        cout &lt;&lt;  c.x &lt;&lt;  endl;
                    }
                }
                void printComplexValue(Complex c){
                    if(c.y > 0){
                        cout &lt;&lt;  c.x &lt;&lt;  " + i" &lt;&lt;  c.y &lt;&lt;  endl;
                    }else if(c.y &lt; 0){
                        cout &lt;&lt;  c.x &lt;&lt;  " - i" &lt;&lt;  -c.y &lt;&lt;  endl;
                    }else{
                        cout &lt;&lt;  c.x &lt;&lt;  endl;
                    }
                }
                int main(){
                    Complex c(1,-1); // constructor called
                    printComplexReference(c); // 1 - i1
                    printComplexValue(c); // copy constructor /n 1 - i1
                    Complex x = c; // copy constructor
                }
</pre>
<h4>copy constructor cascade invoking</h4><p><a href="./program/copy_constructor2.cpp">Source code</a></p>
<pre class="brush: cpp">
#include &lt;iostream>
using namespace std;
class F1{
public:
    F1();
    F1(const F1 &amp; f);
};
F1::F1(const F1 &amp; f){
    cout &lt;&lt; "F1 copy constructor" &lt;&lt; endl;
}
F1::F1(){
    cout &lt;&lt; "F1 user defined default constructor" &lt;&lt; endl;
}

class F2{
public:
    F1 f;
};
int main(){
    F2 f2; // F1 user defined default constructor // since F2 has a F1
    F2 a[10]; // invoke 10 times.
    F2 * b = new F2[10]; // invoke 10 times
    F2 f2_ = f2; // F1 copy constructor, F2 default copy constructor also invokes F1 copy constructor
}
</pre>
</li>
<li><p><span style="font-weight:bold">Assignment operator</span></p>
<p>It is just a regular overloading operator, no special meaning on syntax. But it is important and error-prone in terms of the whole program.</p>
<div class="featureList">
<h4>Invoke assignment operator</h4>
<ol>
<li>c1 = c2;</li>
<li><span style="color:red;">Not invoke</span>: Complex c1 = c; // this cause the copy constructor</li>
</ol>
</div>
<h4>Convention</h4>
<p>Assignment operator usually treated as a class member instead of [friend] global function. <br>Const &amp; argument type.<br>It may also return a reference of the current object.</p>
<p class="starMark"> *Return a reference is OK if this operator is a class member.</p>
<p><a href="./program/as.cpp">Source code</a></p>
<pre class="brush: cpp">
#include &lt;iostream>
using namespace std;
class Complex{
public:
    int x;
    int y;
public:
    Complex();
    Complex(int x, int y);
    Complex &amp; operator = (const Complex &amp; value);
    Complex(const Complex &amp; value);
};
Complex::Complex():Complex(0,0){
    
}
Complex::Complex(int x, int y):x(x), y(y){
    cout &lt;&lt; "constructor" &lt;&lt; endl;
}
Complex::Complex(const Complex &amp; value){
    x = value.x;
    y = value.y;
    cout &lt;&lt; "copy constructor" &lt;&lt; endl;
}
//return *this as a reference is allowed because the object is out of the function scope.
Complex&amp; Complex::operator = (const Complex &amp; value){
    cout &lt;&lt; "assigment constructor" &lt;&lt; endl;
    this->x =  value.x;
    this->y =  value.y;
    return *this;
}

int main(){
    Complex c(1,1); // constructor
    Complex c2; // constuctor
    Complex x = (c2 = c); // assignment constructor /n copy constructor
    // c2 = c is c2.operator=(c);, the return value is not received by
}
</pre>
</li>
<li><p><span style="font-weight:bold">Destructor</span>: called when an object of the class <mark>goes out of scope</mark>. It also can be invoked by calling the delete.</p>
<p>Using destructor to deallocate the dynamic allocated memory is necessary, because it can avoid memory leakage. However, it is also dangerous because of <span style="color:red">using the compiler provided copy constructor and assignment operator</span>. 
    In the following case, a new copy constructor has to be defined. (Or According to the requirement, a static member may be needed.)
</p>
<p>Moreover, destructor usually is set as virtual function.</p>
<pre class="brush: cpp">
#include &lt;iostream>
using namespace std;
class F1{
public:
    int * x;
    F1();
    ~F1();
};
F1::F1(){
    x = new int [10];
}
F1::~F1(){
    cout &lt;&lt; "destructor" &lt;&lt; endl;
    delete x;
}
int main(){
    F1 f;
    F1 f_ = f;
    /*destructor
    destructor
    a.out(5044,0x7fffe882c3c0) malloc: *** error for object 0x7fb10f500000: pointer being freed was not allocated
        *** set a breakpoint in malloc_error_break to debug
        Abort trap: 6*/
}

</pre>
</li>

</ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
