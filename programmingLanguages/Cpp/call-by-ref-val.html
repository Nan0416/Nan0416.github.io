<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>C++&nbsp;call-by-value/call-by-reference</title>
<meta name="date" content="2018-01-13">
<meta name="keywords" content="call&nbsp;by&nbsp;value">
<meta name="keywords" content="call&nbsp;by&nbsp;reference">
<meta name="keywords" content="C++">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>


<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>C++&nbsp;-&nbsp;call-by-value/call-by-reference</strong></center>
</div>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#rvIntro">Introduction</a></li>
<li><a href="#rvExample">Example</a></li>
<li><a href="#rvReturnReference">Return a reference</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="rvIntro">
<h3>Introduction</h3>
<p>Call by value is the common suition. When encountering a function call, the argument is copyied onto the stack. Even if the function modifies the value, it will
not reflect to the variable that is outside the function. So the original value is isolated. The disadvantage of call-by-value is that it requires <mark>more memory and time</mark> to copy the value.</p>
<p>Call by reference is like an alias of the original variable. Usually it is used in the function argument, but it can be used to declare variable. It is just like a pointer in C. (C does not have reference variable.)
Because of its nature, it does not isolate the original value. Just like a pointer, all modification made inside a function would reflect into the original variable. Its advantage is <mark>faster and less memory</mark>.
</p>
<p><span style="color:red">Same as pointer, it also can invoke the virtual functions.</span></p>
</div>
</li>

<li>
<div class="content" id="rvExample">
<h3>Example</h3>
<p>
<a href="./program/callByVR.cpp">Source code</a>
<pre class="brush: cpp">
#include &lt;iostream&gt;
using namespace std;

class Testing{
private:
    int x;
public:
    Testing();
    int get();
    void set(int x);
};
Testing::Testing(){
    x = 0;
}
int Testing::get(){
    return x;
}
void Testing::set(int x){
    this->x = x;
}

//call by reference
void incByRef(Testing &amp; t){
    t.set(t.get()+1);
}
//call by value
void incByVal(Testing t){
    t.set(t.get()+1);
}
int main(){
    Testing t;
    t.set(1);
    cout &lt;&lt; "before call incByRef " &lt;&lt; t.get() &lt;&lt; endl; // 1
    incByRef(t);
    cout &lt;&lt; "after call incByRef " &lt;&lt; t.get() &lt;&lt; endl; // 2
    cout &lt;&lt; "before call incByVal " &lt;&lt; t.get() &lt;&lt; endl; // 2
    incByVal(t);
    cout &lt;&lt; "after call incByVal " &lt;&lt; t.get() &lt;&lt; endl; // 2
    Testing &amp; reft = t; // declare an alias. Usually it is not meaningful
    cout &lt;&lt; "before call incByRef(reft) " &lt;&lt; t.get() &lt;&lt; endl; // 2
    incByRef(reft);
    cout &lt;&lt; "after call incByRef(reft) " &lt;&lt; t.get() &lt;&lt; endl; // 3
    return 0;
}
</pre>
</p>
</div>
</li>
<li>
<div class="content" id="rvReturnReference">
<h3>Return reference</h3>
<p>Return a reference of an object to the scope that the object does not exist would cause warning but not error.</p>
<p class="starMark">* The effect is same as returning a pointer from a stack object.</p>
<p>However, if the scope of the object is allowed, then it is ok. For example, return *this in a class member function because the object itself is outside its member function.</p>
<p><a href="./program/return_reference.cpp">Source code</a></p>
<pre class="brush: cpp;">
#include &lt;iostream>
using namespace std;

class F{
public:
    int x = 0;
};
//warning: reference to stack memory associated with local variable 'f' returned [-Wreturn-stack-address]
F&amp; return_reference(){
    F f;
    f.x = 1;
    return f;
}
//warning: address of stack memory associated with local variable 'f' returned [-Wreturn-stack-address]
F* return_address(){
    F f;
    f.x = 1;
    return &f;
}
//allowed 
F* return_out(F&amp; f){
    return &f;
}
int main(){
    F *fa = return_address();
    cout &lt;&lt; fa->x &lt;&lt; endl;
    F fr = return_reference();
    cout &lt;&lt; fr.x &lt;&lt; endl;
}
</pre>
</div>
</li>
</ol>
</div>
    
</body>
</html>
