<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>C++&nbsp;call-by-value/call-by-reference</title>
<meta name="date" content="2018-01-13">
<meta name="keywords" content="call&nbsp;by&nbsp;value">
<meta name="keywords" content="call&nbsp;by&nbsp;reference">
<meta name="keywords" content="C++">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>


<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>C++&nbsp;call-by-value/call-by-reference</strong></center>
</div>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#rvIntro">Introduction</a></li>
<li><a href="#rvExample">Example</a></li>

</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="rvIntro">
<h3>Introduction</h3>
<p>Call by value is the common suition. When encountering a function call, the argument is copyied onto the stack. Even if the function modifies the value, it will
not reflect to the variable that is outside the function. So the original value is isolated. The disadvantage of call-by-value is that it requires <mark>more memory and time</mark> to copy the value.</p>
<p>Call by reference is like an alias of the original variable. Usually it is used in the function argument, but it can be used to declare variable. It is just like a pointer in C. (C does not have reference variable.)
Because of its nature, it does not isolate the original value. Just like a pointer, all modification made inside a function would reflect into the original variable. Its advantage is <mark>faster and less memory</mark>.
</p>
</div>
</li>

<li>
<div class="content" id="rvExample">
<h3>Example</h3>
<p>
<a href="./program/callByVR.cpp">Source code</a>
<pre class="brush: cpp">
#include &lt;iostream&gt;
using namespace std;

class Testing{
private:
    int x;
public:
    Testing();
    int get();
    void set(int x);
};
Testing::Testing(){
    x = 0;
}
int Testing::get(){
    return x;
}
void Testing::set(int x){
    this->x = x;
}

//call by reference
void incByRef(Testing &amp; t){
    t.set(t.get()+1);
}
//call by value
void incByVal(Testing t){
    t.set(t.get()+1);
}
int main(){
    Testing t;
    t.set(1);
    cout &lt;&lt; "before call incByRef " &lt;&lt; t.get() &lt;&lt; endl; // 1
    incByRef(t);
    cout &lt;&lt; "after call incByRef " &lt;&lt; t.get() &lt;&lt; endl; // 2
    cout &lt;&lt; "before call incByVal " &lt;&lt; t.get() &lt;&lt; endl; // 2
    incByVal(t);
    cout &lt;&lt; "after call incByVal " &lt;&lt; t.get() &lt;&lt; endl; // 2
    Testing &amp; reft = t; // declare an alias. Usually it is not meaningful
    cout &lt;&lt; "before call incByRef(reft) " &lt;&lt; t.get() &lt;&lt; endl; // 2
    incByRef(reft);
    cout &lt;&lt; "after call incByRef(reft) " &lt;&lt; t.get() &lt;&lt; endl; // 3
    return 0;
}
</pre>
</p>
</div>
</li>
</ol>
</div>
    
</body>
</html>
