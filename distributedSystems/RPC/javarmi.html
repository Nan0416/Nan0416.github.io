<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>RPC&nbsp;Java&nbsp;RMI</title>
<meta charset="utf-8">
<meta name="date" content="2018-02-03">
<meta name="keywords" content="rmi">
<meta name="keywords" content="java">
<meta name="keywords" content="distributed&nbsp;objects">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>RPC&nbsp;Java RMI</strong></center>
</div>
<p class="date"><span class="created-date">Created:2018-02-03</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2018-02-03</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#rmiIntro">Introduction</a></li>
<li><a href="#rmiExample">Examples</a></li>

</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="rmiIntro">
<h3>Introduction</h3>
<p>Java RMI (Remote method  invocation) is a Java API used to do the job of RPC.</p>
<div class="featureList">
<h4>Features</h4>
<ol>
<li>Both client and server must run on JVM</li>
<li>Dynamic code Loading: download class definition if it is not defined in the server side.</li>
</ol>
</div>
<div class="termnology">
<h4>terms</h4>
<ul>
<li>Remote object: objects with methods that can be invoked across Java virtual machines.</li>
<li>Remote interface: an interface extends the interface <strong>java.rmi.Remote</strong>, and each method throws <strong>java.rmi.RemoteException</strong>.</li>
<li>Remote class: implemented the remote interface, and extends UnicastRemoteObject</li>
<li>RMI registry: a remote object that provides naming service that enables clients to obtain a reference to a remote object by name.</li>
</ul>
</div>
</div>
</li>
<li>
<div class="content" id="rmiExample">
<h3>Example</h3>
<h4>Interface example</h4>
<pre class="brush:java">
import java.rmi.Remote;
import java.rmi.RemoteException;

public interface PrimaryServerServesLocalServer extends Remote {
    boolean reportAddress(String sIP, int nPort) throws RemoteException;
}
</pre>
<h4>Remote class</h4>
<p>It must have a constructor that throws/handle RemoteException</p>
<p>Also extends UnicastRemoteObject, which is used for exporting a remote object.</p>
<pre class="brush:java">
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
public class PrimaryServer extends UnicastRemoteObject implements PrimaryServerServesLocalServer{

    public PrimaryServer() throws RemoteException{

    }
    @Override
    public boolean reportAddress(String sIP, int nPort) throws RemoteException{
        System.out.println("IP "+ sIP + " " + nPort);
        return true;
    }
}
</pre>

<h4>Run local servers</h4>
<p>Before starting the service, a naming service that let the client find the remote object must be started.</p>
<p>Java RMI provided a simple naming service. LocateRegistry:</p>
<p>In server-side, it can createRegistry(port). It returns a Registry object, which is just a remote object that providing the naming service.<br>
In client-side, it can return the stub of the Registry, getRegistry(ip, port).</p>
<p>After having the registry object, binding the server-side remote object to it, bind(String name, Remote obj)<br>
In the client-side, obtaining it by lookup(String name)
</p>
<h4>Server-side</h4>
<pre class="brush:java">
import java.rmi.AlreadyBoundException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class Server {
    public static void main(String[] args) throws RemoteException, AlreadyBoundException, Exception{
        PrimaryServer ps = new PrimaryServer();
        String bindingName = "primary";
        int portRMI = 1099;
        Registry registry = LocateRegistry.createRegistry(portRMI);
        Naming.bind(bindingName, ps);
        System.out.println("register to registry");
        while(true); // without true, the bind will end.
    }
}
</pre>
<h4>Client-side</h4>
<pre class="brush:java">
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.util.concurrent.locks.Lock;
import java.rmi.registry.Registry;
import java.rmi.registry.LocateRegistry;
public class LocalServer {
    private PrimaryServerServesLocalServer pClient;
    private String primaryServerIP;
    private int primaryServerPort;
    private Registry localRegistry;


    public LocalServer() throws RemoteException, NotBoundException{
        primaryServerIP = "127.0.0.1";
        primaryServerPort = 1099;
        localRegistry = LocateRegistry.getRegistry(primaryServerIP, primaryServerPort);
        pClient = (PrimaryServerServesLocalServer) localRegistry.lookup("primary");
    }
    public static void main(String [] args) throws Exception{
        LocalServer ls = new LocalServer();
        ls.pClient.reportAddress("1",1);

    }
}
</pre>

<div class="featureList">
<h4>***************Developing steps****ignore********</h4>
<h4>Server side</h4>
<ol>
<li>Define remote interface.</li>
<li>Create remote server class by implementing the remote interface.</li>
<li>Driver file: new an instance and get its stub <i>UnicastRemoteObject.exportObject(instance, 0); // 0 indicates the TCP port is chosen at runtime.</i></li>
</ol>
</div>
<div class="featureList">
<h4>Passing arguments</h4>
<ol>
<li>Remote objects are essentially passed by reference. A remote object reference is a stub, which is a client-side proxy that implements the complete set of remote interfaces that the remote object implements.</li>
<li>Local objects are passed by copy, using object serialization. By default, all fields are copied except fields that are marked static or transient. Default serialization behavior can be overridden on a class-by-class basis.</li>
</ol>
</div>


</div>
</li>
</ol>
</div>
    
</body>
</html>
