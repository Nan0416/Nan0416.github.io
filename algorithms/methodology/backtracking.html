<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<title>Methodology&nbsp;Backtracking</title>
<meta charset="utf-8">
<meta name="date" content="2019-08-27">
<meta name="keywords" content="Backtracking">
<meta name="keywords" content="Methodology">
<meta name="keywords" content="">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushPython.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushSql.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>

</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>Methodology&nbsp;-&nbsp;Backtracking</strong>
</div>
<p class="date"><span class="created-date">Created:2019-08-27</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-09-06</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#intro">Introduction</a></li>
<li><a href="#reference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="intro">
<h3>Introduction</h3>
<p>Backtracking is a kind of recursion, sub-recur is used to solve the same problem.</p>
<p>还是有些像DFS. Difference is DFS operates on a tree or graph, backtracking usually operates on an array. AND backtracking need to keep track of the visited path.</p>
<p><span style="color:red">Runtime usually equals to the size of result.</span></p>
</div>
</li>
<li>
<div class="content" id="reference">
<h3>Examples</h3>
<h4>Where to apply?</h4>
<div class="featureList">
    <ol>
        <li>
            <p>Backtracking usually applied to string and array based question. AND <span style="color:red">the output is the enumeration of all valid result.</span></p>
        </li>
        <li>
            <p>Backtracking is kind of methodology for brute force. Because it will search and validate every possible result.</p>
        </li>
    </ol>
</div>
<h4>Example</h4>
<div class="featureList">
    <ol>
        <li>
            <p class="algorithm-problem-title">39. Combination (Subset) Sum</p>
            <p class="algorithm-problem-title">40. Combination (Subset) Sum II</p>
            <p class="algorithm-problem-title">77. Combinations</p>
            <p class="algorithm-problem-title">78. Subsets</p>
            <p class="algorithm-problem-title">90. Subsets II</p>
            <p class="algorithm-problem-title">46. Permutations</p>
            <p class="algorithm-problem-title">47. Permutations II</p>
            <p>Desc: <br>
                39. an array of positive integers without duplicated and a target number. find all unique combinations' sum = target e.g. [2,3,5], 8 => [[2,2,2,2], [2, 3, 3], [3, 5]] <span style="color:red">a number can be repeatedly used.</span><br>
                40. an array of positive integers may have duplicated element, and a number can only be used once. make sure no duplicated in result<br>
                77. Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. e.g. n = 3, k = 2, [1,2],[1,3],[2,3]<br>
                78. an array of distinct numbers, return all its subsets. e.g. [1,2,3] -> [], [1], [2], [3], [1,2],[1,2,3], [1,3],[2,3]<br>
                79. an array that may have duplicated numbers, return all its subsets without duplicated.<br>
                46. an array of distinct numbers, return all its permutations, e.g. [1,2,3] -> [1,2,3],[1,3,2], [2,1,3] ...<br>
                47. an array may have duplicate numbers, return all its permutations without duplicated.
            </p>
            <h4 style="color:red">Summary (Combination vs. Permutation)</h4>
            <p>
                subset: select numbers from array, each number may select once or multiple times.<br>
                combination: select k numbers from an array and order doesn't matter.<br>
                permutation: select k numbers (usually all k = nums.length) from an array and arrange in different orders.<br>
                <p style="font-weight: bold">1). without considering duplicated element.</p>
                <pre class="brush:java">
                    // permutation uses an flag array to indicates if the number is used. The base condition is path.size() == nums.length.
                    // combination doesn't need the flag array. It has base condition when path.size() == k
                    // subset doesn't need the flag array. It doesn't has base condition, it iterate the array until end.

                    // permutation
                    public void premutationHelper(int [] nums, byte[] used, LinkedList&lt;Integer> path, List&lt;List&lt;Integer>> result){
                        if(path.size() == nums.length){
                            result.add(new ArrayList&lt;>(path)); // diff: add only when path.size() == nums.length;
                            return;
                        }
                        for(int i = 0; i &lt; used.length; i++){ // diff: start from 0
                            if(used[i] == 0
                            // && (i == 0 || nums[i-1] != nums[i] || flags[i-1] == 1) // avoid duplicated.
                            ){
                                used[i] = 1;
                                path.add(nums[i]);
                                premutationHelper(nums, used, path, result);
                                path.remove(path.size()-1);
                                used[i] = 0;
                            }
                        }
                    }
                    // combination

                    public void combinationHelper(int [] nums, int index, int k, List&lt;Integer> path, List&lt;List&lt;Integer>> result){
                        if(k == 0){
                            result.add(new ArrayList&lt;>(path));
                            return;
                        }
                        for(int i = index; i &lt; nums.length; i++){
                            /*if(i > 0 && nums[i] == nums[i-1]){ // avoid duplicated.
                                continue; 
                            }*/
                            path.add(nums[i]);
                            combinationHelper(nums, i+1, k - 1, path, result);
                            path.remove(path.size()-1);
                        }
                    }
                    // subset.
                    public void subsetsHelper(int [] nums, int index, List&lt;Integer> path, List&lt;List&lt;Integer>> result){
                        for(int i = index; i &lt; nums.length; i++){ // diff: start from index.
                            /*if(i > index && nums[i-1] == nums[i]){ // avoid duplicated
                                continue;
                            }*/
                            path.add(nums[i]);
                            result.add(new ArrayList&lt;>(path));   // diff: add every possible path.
                            subsetsHelper(nums, i + 1, result, path); 
                            path.remove(path.size()-1);
                        }
                    }
                </pre>
                <p style="font-weight: bold">2). with duplicated element</p>
                <p>First thing is to sort the array, and then before adding new element we need to check if it's same as the previous element.</p>
                <p style="font-weight: bold">3). allow repeatedly use elements?</p>
                <p>If an element is allowed to use repeatedly, then the recursive call starts from i instead of i+1</p>
                <pre class="brush:java">
                for(int i = index; i &lt; nums.length; i++){
                    // subsetsHelper(nums, i + 1, result, path);
                    subsetsHelper(nums, i, result, path);
                } 
                </pre>
                <p>First thing is to sort the array, and then before adding new element we need to check if it's same as the previous element.</p>
                <p style="font-weight: bold">4). Tips</p>
                <p>
                    1). using ArrayList instead of LinkedList<br>
                    2). subset includes empty list.
                </p>
            </p>
        </li>
        <li>
            <h4>17. Letter Combinations of a Phone Number</h4>
            <p>Desc: given a old cellphone keyboard, that each digit except 1 has 3 or 4 letter. e.g.[2"abc", 3"def" ...]. Now given a digit string contains [2-9], return all possible string.</p>
            <p>Sol: DFS's backtracking.<br>
                optimization: using "char [] + index" to behave as the path arraylist.
            </p>
        </li>   
        <li>
            <h4>79. Word Search</h4>
            <p>Desc: given a char matrix, and a string word, find if the word exist in the grid. The word can be constructed from letters of sequentially adjacent cell. <span style="color:red">a cell once used once.</span></p>
            <p>Sol: 2d backtracking permutation. <br>
                optimization 1: it needs a 2d used array, but can be optimized by using the char matrix). [kind of DFS]<br>
            </p>
        </li>
        <li>
            <h4>89. gray code</h4>
            <p>Desc: given integer n, return a list of n-bit gray code in order. .e.g. n = 4 return [0,1,3,2]</p>
            <p>Sol: rules
                <pre class="brush:java">
                    n = 1; 0, 1
                    n = 2; 00 01 11 10
                    n = 3; 000 001 011 010 110 111 101 100
                    n = 4; prepend 0 on each number when n=3, and reverse n=3, prepend 1.
                </pre>
                <pre class="brush:java">
                    List&lt;Integer> number = new ArrayList&lt;>();
                    number.add(0);
                    int count = 0;
                    while(count &lt; n){
                        int size = number.size();
                        for(int i = size - 1; i >= 0; i--){
                            number.add(number.get(i) | 1 &lt;&lt; count);
                        }
                        count++;
                    }
                    
                </pre>
            </p>
        </li>

    </ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
