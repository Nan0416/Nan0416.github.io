<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Methodology&nbsp;Dynamic Programming (Practice)</title>
<meta charset="utf-8">
<meta name="date" content="2018-09-10">
<meta name="keywords" content="dp">
<meta name="keywords" content="dynamic_programming">
<meta name="keywords" content="microcontroller">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>
<style>
    .important{
        color:red;
        font-weight: bold;
    }
    .title{
        font-weight: bold;
    }
</style>
</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>Methodology&nbsp;Dynamic Programming (Practice)</strong>
</div>
<p class="date"><span class="created-date">Created:2018-09-10</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-08-28</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#example">Examples</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
    <div class="content" id="example">
        <h3>Examples</h3>
        <div class="featureList">
            <h4>Where to apply?</h4>
            <ol>
                <li>DP problem usually based on an array (or string), it ask find the (max value/min value) <span style="color:red">subarray</span> or <span style="color:red">a set of elements</span> that construct the optimal goal.</li>
                <li>
                    <h4>SubArray (continuous elements)</h4>
                    <p>The transition is usually <span style="color:red">from n to n + 1</span> or <span style="color:red">from i to i -1/ j to to j + 1</span></p>
                </li>
                <li>
                    <h4>Implicit array (continuous elements)</h4>
                    <p>The input may not have an array, but it's implicitly based on an implicit array.</p>
                </li>
                <li>
                    <h4>A set of element (not need to be continuous)</h4>
                    <p>e.g. <span style="color:red">Knapsack</span>. Then the subproblem is for array from v to v+1, and goal from w to w+1. [todo]</p>
                    <p><span style="color:red">It's can also be solved by the backtracking (brute force).</span></p>
                </li>
            </ol>
            <hr>
            <h4>Notice</h4>
            <ol>
                <li>Runtime limit exceed. if the runtime is O(2^n), then it must exceed the runtime limit. O(n!), O(n^4) is ok</li>
                <li>Subsequence vs. Substring<br>
                    subsequence: "acef" is a subsequence of "abcdef"<br>
                    subtring: "bcd" is a substring of "abcdef"
                </li>
            </ol>
        </div>
        <div class='featureList'>
            <h4>Examples</h4>
            <ol>
                <li>
                    <h4>62. Unique Paths</h4>
                    <h4>63. Unique Paths II</h4>
                    <h4>64. Minimum Path Sum</h4>
                    <p>Desc: 62. a m*n grid, a robot on the left-top corner wants to move to the right-bottom corner. it can only move to either right or down direction. find the #unique paths.
                        <br> 63.besides the m, n input, it also has some obstacles on the m*n grid
                    </p>
                    <p>64. an matrix (2d array) has non-negative integers. Find a minimum path from left-top to right-bottom. 
                        <pre class="brush:java">
                            [[1,2,3],
                            [4,5,6]] -> 1,2,3,6 = 12
                        </pre>
                    </p> 
                </li>
                <li>
                    <h4>70. Climbing Stairs</h4>
                    <p>Desc: a stair has n steps, you can climb 1 step or 2 steps each time. How many different ways you can climb to the top?</p>
                    <p>Sol: DP, subproblem is a stair with n-1 steps. O(n) time, O(1) space</p>
                </li>
                <li>
                    <h4>91. Decode Ways</h4>
                    <p>Desc: given that encode method: a -> '1', b -> '2', .. z -> '26'. Now given a digit string e.g. '1234' determine how many way to decode. <span style="color:red">The input string may not be valid, e.g. '0123', '1002', in this case, return 0.</span></p>
                    <p>Sol: DP, O(n) time, O(1) space. pay attention to '0'.</p>
                </li>
                <li>
                    <h4>5. Longest Palindromic Substring</h4>
                    <h4>516. Longest Palindromic Subsequence</h4>
                    <p>Desc: given a string, find the longest palindromic substring (e.g. ababa, cddc)</p>
                    <p>DP, simulation (expand around center), Manacher's algorithm</p>
                    <p><span style="color:red">Notice</span>: the solution is a classic because the two layer of loop iterates all substring or subsequence.</p>
                </li>

                <li>
                    <h4>1143. Longest Common Subsequence</h4>
                    <p>Desc: given <span style="color:red">two strings</span>, find the longest common subsequence (e.g. "abcdef" & "bedf" -> "bef")</p>
                    <p>Sol:
                        <p>old idea, DP O(n^3): fixed the first string, increase the second string by one char. find if we should use the newly add char.</p>
                        <pre class="brush:java">
                            result[i][j] is the length of longest common string with str1 length = i and str2 length = j.
                            for(int i = 0; i &lt; str1.length; i++){
                                for(int j = 0; j &lt; str2.length; j++){
                                    // determine we should use the str2[j]
                                    1. find str2[j] exsited in str1[0 ... i] if not result[i][j] = result[i][j-1]
                                    2. if existed, let index = str2[j] in str1[0 ... i].
                                    result[i][j] = max(1 + result[index-1][j-1], result[i][j-1]); // using or not using.
                                }
                            }
                        </pre>
                        <p>The above idea return O(n^3) because the find str2[j] existed in str1[0...i] takes O(n) runtime.</p>
                        <p>
                            new idea, DP O(n^2): still result[i][j] with same meaning. Fixed the first string, increase the second string by one char.
                             <span style="color:red">Check if str[j] == str[i], if yes, we try to use it, if not, we find max(result[i-1][j], result[i][j-1])</span>
                            This idea also works because if str[j] == str[i] and using str[j] make the result bigger, then it will affect the i+1, i+2 ... result via max(result[i-1][j], <span style="color:red">result[i][j-1]</span>)
                        </p>
                    </p>
                </li>
                <li>
                    <h4>* 97. Interleaving String</h4>
                    <p>Desc: given <span style="color:red">two strings</span> and a target string. ask if the two strings can interleave to form the target string, e.g. "abc" & "ef" can form "aebcf", or "abefc" ...</p>
                    <p>Sol: inc each strings size one by one. boolean [][] dp, dp[i][j] represent can form with target substring[0, i+j] with s1[0,i] and s2[0,j].<br>
                    transition: (dp[i][j] = dp[i-1][j] & s1[i] as end || dp[i][j-1] & s2[j] as end)
                    </p>
                </li>
                <li>
                    <h4>120. Triangle</h4>
                    <p>Desc: a given List&lt;List&lt;Integer>> represent a triangle
                        <pre class="brush:java">
                        [       
                                [3]
                               [2,3]
                              [4,2,1]
                             [9,2,0,1]
                        ]
                        </pre>
                        find the minimum path sum from bottom to top. Each step you may move to adjacent numbers on the row below. e.g. 3->2->2->0
                    </p>
                    <p>Sol: dp, subproblem [9], [2] we can build [[4],[9,2]], from bottom to top. O(n^2) time, O(n) space</p>
                </li>
                <li>
                    <h4>* 139. Word Break</h4>
                    <p>Desc: a string and a list of words. can the string be broken according to the given list of words, .e.g "helloworld" ['hello', 'world'] -> return true</p>
                    <p>Sol: brute force with memorization. e.g. "catsandhello", given [cat, cats, sand, and, ...] both can reach catsand, so only one need to do the feature exploration.</p>
                </li>
                <li>
                    <h4>* 140. Word Break II</h4>
                    <p>Desc: same as word break, but instead of answering if a string can be broken. Now, it asks all possible breaking. e.g. "catsandhello...." ["cats, and", "cat", "sand", "hello"]</p>
                    <p>Sol: DFS (backtracking) with memorization <span style="color:red">the same subproblem is both "cat" + "sand" and "cats" + "and" results in "hello....", so we only need to solve the "hello..." once.</span></p>
                </li>
                <li>
                    <h4>Knapsack[3]</h4>
                    <p>Desc: an array of integers represent each item's value, an array of integres represent each item's weight. A knapsack with maximum capacity of weight W, find the max value it can take.</p>
                    <p>Introduction: depending the number of each item can be selected, there 3 kinds of Knapsack problems.<br>
                        0-1 Knapsack: a item can only be chosen once or not.<br>
                        bounded knapsack: an item can be chosen in finite times. The input of the problem has an additional array int[] b, which indicates the maximum number of each element can be chosen.<br>
                        unbouned knapsack: an item can be chosen in unfinite times.
                    </p>
                    <h4>0-1 Knapsack</h4>
                    <p>Sol: Dynamic Programming.<br>
                        1). the problem is N items with knapsack W weight. the subproblem is i item with knapsack w Weight.<br>
                        2). status: matrix[i][w] represent with i items and w max weight, what is the max value<br>
                        3). transition: matrix[i][w] = max(value[i] + matrix[i-1][w-weight[i]], matrix[i-1][w]) // used ith element or not used ith element.
                    </p>
                    <pre class="brush:java">
    public int maxValueDP1(int [] weight, int [] value, int maxWeight){
        int[][] results = new int[weight.length][maxWeight + 1];
        for(int i = 0; i &lt; weight.length; i++){
            for(int w = 0; w &lt;= maxWeight; w++){
                int previous = 0 , current = 0;
                if(w > 0 && i > 0){
                    previous = results[i-1][w]; // without using ith element.
                }
                if(w >= weight[i]){ // using ith element.
                    if(i > 0){
                        current = value[i] + results[i-1][w - weight[i]];
                    }else{
                        current = value[0];
                    }
                }
                results[i][w] = Math.max(previous, current);
            }
        }
        return results[weight.length - 1][maxWeight];
    }
                    </pre>
                </li>
            </ol>
        </div>
    </div>
</li>
</ol>
</div>
    
</body>
</html>
