<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Methodology&nbsp;Dynamic Programming (Practice)</title>
<meta charset="utf-8">
<meta name="date" content="2018-09-10">
<meta name="keywords" content="dp">
<meta name="keywords" content="dynamic_programming">
<meta name="keywords" content="microcontroller">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>
<style>
    .important{
        color:red;
        font-weight: bold;
    }
    .title{
        font-weight: bold;
    }
</style>
</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>Methodology&nbsp;Dynamic Programming (Practice)</strong>
</div>
<p class="date"><span class="created-date">Created:2018-09-10</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-09-03</span></p>
<div class="catalog">
<ul class="catalogItems">
    <li><a href="#intro">Introduction</a></li>
    <li><a href="#example">Examples</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
    <li>
        <div class="content" id="intro">
            <h3>Introduction</h3>
            <div class="featureList">
                <ol>
                    <li>
                        <h4>How to solve DP</h4>
                        <p>For a simple DP problem (easy/medium), directly find the problem dimension and transition functions</p>
                        <p>For a hard DP that cannot easily find a transition function, using brute force (backtracking) + memorization.</p>
                    </li>
                    <li>
                        Once found the transition function, then it's just programming and optimization
                        <h4>How to find transition function</h4>
                        <p>
                            First <span style="color:red">identified the problem size</span> according to the input.<br>
                            e.g. input(int [] arr, int amount). then the problem size (result array) is usually 2 dimension. (inc arr size and inc amount. result[i][j] = subproblem result[i-1][j] and result[i][j-1])<br>
                            e.g. input(int [] arr), then the problem size can be 1 dimension or 2 dimension (inc arr size or inc arr size from two left and right.)
                        </p>
                    </li>
                    <li>
                        <h4>Optimization</h4>
                        <p>Sometimes, the 2d result array can be optimized to 1d</p>
                    </li>
                </ol>
            </div>
        </div>
    </li>
<li>
    <div class="content" id="example">
        <h3>Examples</h3>
        <div class="featureList">
            <h4>Where to apply?</h4>
            <ol>
                <li>DP problem usually based on an array (or string), it ask find the (max value/min value) <span style="color:red">subarray</span> or <span style="color:red">a set of elements</span> that construct the optimal goal.</li>
                <li>
                    <h4>SubArray (continuous elements)</h4>
                    <p>The transition is usually <span style="color:red">from n to n + 1</span> or <span style="color:red">from i to i -1/ j to to j + 1</span></p>
                </li>
                <li>
                    <h4>Implicit array (continuous elements)</h4>
                    <p>The input may not have an array, but it's implicitly based on an implicit array.</p>
                </li>
                <li>
                    <h4>A set of element (not need to be continuous)</h4>
                    <p>e.g. <span style="color:red">Knapsack</span>. Then the subproblem is for array from v to v+1, and goal from w to w+1. [todo]</p>
                    <p><span style="color:red">It's can also be solved by the backtracking (brute force).</span></p>
                </li>
            </ol>
            <hr>
            <h4>Notice</h4>
            <ol>
                <li>Runtime limit exceed. if the runtime is O(2^n), then it must exceed the runtime limit. O(n!), O(n^4) is ok</li>
                <li>Subsequence vs. Substring<br>
                    subsequence: "acef" is a subsequence of "abcdef"<br>
                    subtring: "bcd" is a substring of "abcdef"
                </li>
            </ol>
        </div>
        <div class='featureList'>
            <h4>Examples</h4>
            <ol>
                <li>
                    <h4>62. Unique Paths</h4>
                    <h4>63. Unique Paths II</h4>
                    <h4>64. Minimum Path Sum</h4>
                    <p>Desc: 62. a m*n grid, a robot on the left-top corner wants to move to the right-bottom corner. it can only move to either right or down direction. find the #unique paths.
                        <br> 63.besides the m, n input, it also has some obstacles on the m*n grid
                    </p>
                    <p>64. an matrix (2d array) has non-negative integers. Find a minimum path from left-top to right-bottom. 
                        <pre class="brush:java">
                            [[1,2,3],
                            [4,5,6]] -> 1,2,3,6 = 12
                        </pre>
                    </p> 
                </li>
                <li>
                    <h4>70. Climbing Stairs</h4>
                    <p>Desc: a stair has n steps, you can climb 1 step or 2 steps each time. How many different ways you can climb to the top?</p>
                    <p>Sol: DP, subproblem is a stair with n-1 steps. O(n) time, O(1) space</p>
                </li>
                <li>
                    <h4>** 279. Perfect Squares</h4>
                    <p>Desc: find a the least number of perfect square numbers (1,4,9,16, ...) which sum to n. e.g. 13 = 4 + 9, which needs 2 perfect square number.</p>
                    <p>Sol: DP, result[n] = min(1 + result[n - i*i]) i = 0...i*i &lt; j. <span style="color:red">The naive solution is result[n] = min(result[i] + result[n-i]), but it's O(n^2). With i*i as the boundary, runtime is sum(root(i))</span>.</p>
                </li>
                <li>
                    <h4>198. House Robber</h4>
                    <p>Desc: a row of house, each house has certain money, [10, 20, 13, 4]. a robber cannot rob two adjacent houses. the maximum amount money a robber can get.</p>
                    <p>Sol: DP, O(n) runtime, O(1) space. sum[i] = max(money[i] + sum[i-2], sum[i-1); // rob, or not rob.</p>
                </li>
                <li>
                    <h4>91. Decode Ways</h4>
                    <p>Desc: given that encode method: a -> '1', b -> '2', .. z -> '26'. Now given a digit string e.g. '1234' determine how many way to decode. <span style="color:red">The input string may not be valid, e.g. '0123', '1002', in this case, return 0.</span></p>
                    <p>Sol: DP, O(n) time, O(1) space. pay attention to '0'.</p>
                </li>
                <li>
                    <h4>5. Longest Palindromic Substring</h4>
                    <h4>516. Longest Palindromic Subsequence</h4>
                    <h4>* 300. Longest Increasing Subsequence</h4>
                    <p>Desc: #5 & #516. given a string, find the longest palindromic substring (e.g. ababa, cddc)<br>
                        #300. given an number array,e.g. [10, 9, 2, 5, 3, 4] find the length of longest increasing sequence. ([2,3,4] returns 3)
                    </p>
                    <p>DP, simulation (expand around center), Manacher's algorithm</p>
                    <p><span style="color:red">Notice</span>: the solution is a classic because the two layer of loop iterates all substring or subsequence.</p>
                    <p>08-31: DP 有时感觉没什么套路。比如#300 和 #516 感觉挺像，但是他们有着完全不一样的transition function.</p>
                    <p>Sol: #300<br>
                    DP solution: O(n^2). keep 1d array "result[]" has the same length as nums. <br>
                    1). <span style="color:red">result[i] means the length of LIS that ends at nums[i].</span><br>
                    2). <span style="color:red">result[i] = max(result[0...i-1] + 1) where nums[i-1] &lt; nums[i]</span><br>
                    BinarySearch + DP solution: as iterating each elements in the array, we build the LIS. <br>
                    1). <span style="color:red">Having a LIS with nums[0...i-1].</span><br>
                    2). <span style="color:red">LIS.append(nums[i]) if nums[i] > LIS.last(); LIS.replace(nums[i]) find the nums[i]'s position in the LIS with binary search, and replace it with old element.</span>
                    </p>
                </li>
                <li>
                    <h4>* 139. Word Break</h4>
                    <p>Desc: a string and a list of words. can the string be broken according to the given list of words, .e.g "helloworld" ['hello', 'world'] -> return true</p>
                    <p>Sol: brute force with memorization. e.g. "catsandhello", given [cat, cats, sand, and, ...] both can reach catsand, so only one need to do the feature exploration.</p>
                </li>
                <li>
                    <h4>* 140. Word Break II</h4>
                    <p>Desc: same as word break, but instead of answering if a string can be broken. Now, it asks all possible breaking. e.g. "catsandhello...." ["cats, and", "cat", "sand", "hello"]</p>
                    <p>Sol: DFS (backtracking) with memorization <span style="color:red">the same subproblem is both "cat" + "sand" and "cats" + "and" results in "hello....", so we only need to solve the "hello..." once.</span></p>
                </li>
                <li>
                    <h4>343. Integer Break</h4>
                    <p>Desc: given a positive integer, break it into at least 2 numbers' sum. and find the maximum product of these numbers. e.g. 10 = 3 + 3 + 4, which generates 3 * 3 * 4 = 36</p>
                    <p>Sol: DP O(n^2) time and O(n) space.<br>
                        for(int i = 1; i &lt;= n; i++){
                            result[n] = max(result[n], max(i, result[i]) * max(n-i, result[n-i]));
                        }
                    </p>
                </li>
                <li>
                    <p class="algorithm-problem-title">651. 4 Keys Keyboard</p>
                    <p>Desc: given a keyboard that contains 4 keys. key 1 prints A on screen, key 2 selects all screen, key 3 copies selected into buffer, key 4 prints buffer on screen. Now press key N times, find the maximum length of A on screen.</p>
                    <p>Sol: the key is once the buffer is not empty, then using (key 4) is always better the using (key 1)
                        <pre class="brush:java">
                            int [] nums = new int[N+1];
                            for(int i = 1; i &lt;= N; i++){
                                nums[i] = i;
                                for(int j = 3; j &lt;= N; ++){ // we only print buffer after a certain point.
                                    nums[i] = Math.max()
                                }
                            }
                           
                        </pre>
                        <!--
                             A
                            1
                            A A
                            1 2
                            A A A
                            1 3 4
                            A A A A
                            1 2 3 4
                            A A A A A
                            1 2 3 4 5
                            A A A 2 3 4 4 5
                            1 2 3 3 3 6 9 ?
                                        5, 5 * 2, 4 * 3, 3 * 4
                        -->
                    </p>
                    
                </li>
                <hr>
                <li>
                    <h4>221. Maximal Square</h4>
                    <p>Desc: a 2d char array contains only '0' and '1', find the max area of 1-constructed square</p>
                    <p>Sol: the result[i][j] is the edge length of a square whose bottom-right is (i,j). result[i][j] = 0 if '0', otherwise, it depends on result[i-1][j], result[i-1][j-1], and result[i][j-1]</p>
                </li>
                <hr>
                <li>
                    <h4>1143. Longest Common Subsequence</h4>
                    <p>Desc: given <span style="color:red">two strings</span>, find the longest common subsequence (e.g. "abcdef" & "bedf" -> "bef")</p>
                    <p>Sol:
                        <p>old idea, DP O(n^3): fixed the first string, increase the second string by one char. find if we should use the newly add char.</p>
                        <pre class="brush:java">
                            result[i][j] is the length of longest common string with str1 length = i and str2 length = j.
                            for(int i = 0; i &lt; str1.length; i++){
                                for(int j = 0; j &lt; str2.length; j++){
                                    // determine we should use the str2[j]
                                    1. find str2[j] exsited in str1[0 ... i] if not result[i][j] = result[i][j-1]
                                    2. if existed, let index = str2[j] in str1[0 ... i].
                                    result[i][j] = max(1 + result[index-1][j-1], result[i][j-1]); // using or not using.
                                }
                            }
                        </pre>
                        <p>The above idea return O(n^3) because the find str2[j] existed in str1[0...i] takes O(n) runtime.</p>
                        <p>
                            new idea, DP O(n^2): still result[i][j] with same meaning. Fixed the first string, increase the second string by one char.
                             <span style="color:red">Check if str[j] == str[i], if yes, we try to use it, if not, we find max(result[i-1][j], result[i][j-1])</span>
                            This idea also works because if str[j] == str[i] and using str[j] make the result bigger, then it will affect the i+1, i+2 ... result via max(result[i-1][j], <span style="color:red">result[i][j-1]</span>)
                        </p>
                    </p>
                </li>
                <li>
                    <h4>* 97. Interleaving String</h4>
                    <p>Desc: given <span style="color:red">two strings</span> and a target string. ask if the two strings can interleave to form the target string, e.g. "abc" & "ef" can form "aebcf", or "abefc" ...</p>
                    <p>Sol: inc each strings size one by one. boolean [][] dp, dp[i][j] represent can form with target substring[0, i+j] with s1[0,i] and s2[0,j].<br>
                    transition: (dp[i][j] = dp[i-1][j] & s1[i] as end || dp[i][j-1] & s2[j] as end)
                    </p>
                </li>
                <li>
                    <h4>376. Wiggle Subsequence</h4>
                    <p>Desc: a wiggle subsequece is [1,3,2,4,1,5] that the difference between two continuous numbers are wiggle, e.g. [2,-1,2,-3,4]. Now, given an array of integers, find the length of longest wiggle subsequence. 
                        e.g. [1,17,5,10,13,15,10,5,16,8]'s longest wiggle subsequence is [1,17,10,13,10,16,8], which has length of 7.</p>
                    <p>Sol: DP + greedy. keep two arrays of int [] big (<span style="color:red">big[i] is the length of longest wiggle subsequence ends at i and the last elements is bigger than its previous element.</span>)
                    int [] small.
                    </p>
                    <pre class="brush:java">
                        for(int i = 1; i &lt; nums.lengths; i++){
                            if(nums[i] > nums[i-1]){
                                big[i] = small[i-1] + 1; // greedy, we use it.
                            }else{
                                big[i] = big[i-1]; // maintain the proprity of big array.
                            }
                            if(nums[i] &lt; nums[i-1])
                            ...
                        }
                    </pre>
                </li>
                <hr>
                <li>
                    <h4>120. Triangle</h4>
                    <p>Desc: a given List&lt;List&lt;Integer>> represent a triangle
                        <pre class="brush:java">
                        [       
                                [3]
                               [2,3]
                              [4,2,1]
                             [9,2,0,1]
                        ]
                        </pre>
                        find the minimum path sum from bottom to top. Each step you may move to adjacent numbers on the row below. e.g. 3->2->2->0
                    </p>
                    <p>Sol: dp, subproblem [9], [2] we can build [[4],[9,2]], from bottom to top. O(n^2) time, O(n) space</p>
                </li>
                <li>
                    <h4>256. Paint House</h4>
                    <p>Desc: a row of n house, each house can be painted with one of three colors. Two adjacent housese are not allowed to have the same color. given a costs table [[123, 23, 12], [23, 24,12], ...], find the mininum costs</p>
                    <p>Sol: DP O(n) time, O(1) space. Create a [n * 3] costs table, costs[i][j] is the minimum cost of painting 0 to i-th house AND painting i-th house with j-th color. costs[i+1][j] = costs[i+1][j] + min(costs[i][0... except j])</p>
                </li>
                <li>
                    <h4>** 312. Burst Balloons</h4>
                    <p>Desc: given an array of non-negative integer [4,3,6,6]. Remove a number one by one, and you get a value = num[left] * num[i] * num[right]. after remove the i-th number, (i-1)th and (i+1) are adjacent each other. find the max value you can get.</p>
                    <p>
                        Sol: <span style="color:red">The hardest part is two numbers become adjacent after removing the middle number.</span> So we have to <span style="color:red">think this problem in backward, which means we don't consider which number to remove first, we consider which number remove last.</span> 
                        In this way, we can easily build result[i][j], which is the max value we can get from subarray i to j.
                    </p>
                    <pre class="brush:java">
                        for(int i = left+1; i &lt; right; i++){ // left and right are exclusive
                            // think about remove i-th after removing all other number. because i-th existed, so i-1 and i+1 are not adjacent.
                            result = max(num[left] * num[i] * num[right] + call(num, left, i-1) + call(num, i+1, right)) 
                            // num[left] * num[i] * num[right] when we calculate i-th, all others have been removed, so the left and right are not i-1 and i+1.
                        }
                    </pre>
                    <p>
                        <span style="color:red">backtracking with memorization idea</span>: remove one number and then calculate rest. <br>
                        e.g. 4 numbers. using [1,1,1,1] indicates which one has been removed. we have to try all combination event with memorization.<br>
                        so we have to try [1,1,1,1],[1,1,1,0], [1,1,0,1] ... and futhermore think it as a 4-bit integer, we have to try 2^n-1 times. O(2^n).<br>
                        Without memorization is will be O(sum(2^i) where i = 1...n)
                    </p>
                </li>
                <hr>
                <li>
                    <h4>Knapsack[3]</h4>
                    <p>Desc: an array of integers represent each item's value, an array of integres represent each item's weight. A knapsack with maximum capacity of weight W, find the max value it can take.</p>
                    <p>Introduction: depending the number of each item can be selected, there 3 kinds of Knapsack problems.<br>
                        0-1 Knapsack: a item can only be chosen once or not.<br>
                        bounded knapsack: an item can be chosen in finite times. The input of the problem has an additional array int[] b, which indicates the maximum number of each element can be chosen.<br>
                        unbouned knapsack: an item can be chosen in unfinite times.
                    </p>
                    <h4>0-1 Knapsack</h4>
                    <p>Sol: Dynamic Programming.<br>
                        1). the problem is N items with knapsack W weight. the subproblem is i item with knapsack w Weight.<br>
                        2). status: matrix[i][w] represent with i items and w max weight, what is the max value<br>
                        3). transition: matrix[i][w] = max(value[i] + matrix[i-1][w-weight[i]], matrix[i-1][w]) // used ith element or not used ith element.
                    </p>
                    <pre class="brush:java">
    public int maxValueDP1(int [] weight, int [] value, int maxWeight){
        int[][] results = new int[weight.length][maxWeight + 1];
        for(int i = 0; i &lt; weight.length; i++){
            for(int w = 0; w &lt;= maxWeight; w++){
                int previous = 0 , current = 0;
                if(w > 0 && i > 0){
                    previous = results[i-1][w]; // without using ith element.
                }
                if(w >= weight[i]){ // using ith element.
                    if(i > 0){
                        current = value[i] + results[i-1][w - weight[i]];
                    }else{
                        current = value[0];
                    }
                }
                results[i][w] = Math.max(previous, current);
            }
        }
        return results[weight.length - 1][maxWeight];
    }
                    </pre>
                </li>
                <li>
                    <h4>322. Coin Change</h4>
                    <p>Desc: given a list of available coin denominations (no duplicated value), and a target amount. Find latest number of coins that are sum to the target.</p>
                    <p>Same problems: find target number with minimum numbers.</p>
                    <p>Sol:
                    <p>#1. 2d DP. one dimension is #coin-denomination, another is target amount.
                        <pre class="brush:java">
                                result[i][j] = Math.min(result[i][j-1], 1 + result[i-coins[j]][j]);// i is amount, j is #coin
                        </pre>
                        <span style="color:red">using [j] instead of [j-1] is because a denominations can be used repeatedly.</span>
                    </p>
                    <p>
                        #2. 1d DP. only dimension is amount.
                        <pre class="brush:java">
                            for(int j = 0; j &lt; coins.length; j++){
                                result[i] = Math.min(result[i], 1 + result[i-coins[j]]);
                            }
                        </pre>
                        <p>It still has the same runtime as 2d DP but the space is O(n).</p>
                    </p>
                    </p>
                </li>
                <li>
                    <h4>983. Minimum Cost For Tickets</h4>
                    <p>Desc: given a list of days [1...365] on which you will travel by train. And it provides 1 day pass, 7 day pass and 30 day pass tickets for different prices. Find the minimum costs.</p>
                    <p>Sol: 1d DP. result[i] indicates the total minimum costs before and including the i-th day. (result = new int[366])<br>
                    <pre class="brush:java">
                        int c1 = costs[0] + ((i - 1 >= 0) ? result[i-1]: 0);
                        int c2 = costs[1] + ((i - 7 >= 0) ? result[i-7]: 0);
                        int c3 = costs[2] + ((i - 30 >= 0) ? result[i-30]: 0);
                        result[i] = Math.min(c1, Math.min(c2, c3));
                    </pre>
                    </p>
                </li>
                <hr>
                <li>
                    <h4>304. Range Sum Query 2D - Immutable</h4>
                    <p>Desc: Given a 2D matrix matrix, find the sum over any rectangle.</p>
                    <p>
                        Sol: DP O(n^2) initialize a matrix that mat[i,j] is the sum over (0,0,i,j) <span style="color:red">mat[i,j] = mat[i,j] + mat[i-1,j] + mat[i, j-1] - mat[i-1,j-1]</span> <br>
                        getsum takes O(1)
                    </p>
                </li>
                <hr>
                <li>
                    <h4>Easy</h4>
                    <p>303. Range Sum Query - Immutable (given an array of integer, find any sum over a range. O(1) space, O(n) init, O(1) get sum.</p>
                    <p>338. Counting Bits (given a number, count each number's 1 in binary for all [0...number]). <span style="color:red">result[i] = result[i>>1] + ((i & 1) == 1? 1:0);</span> (Attention: using (i & 1) == 1 instead of (i % 2) == 1</p>
                </li>
            </ol>
        </div>
    </div>
</li>
</ol>
</div>
    
</body>
</html>
