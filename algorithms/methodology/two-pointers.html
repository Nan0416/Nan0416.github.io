<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<title>LeetCode&nbsp;Two Pointers</title>
<meta charset="utf-8">
<meta name="date" content="2019-02-03">
<meta name="keywords" content="two pointers">
<meta name="keywords" content="array">
<meta name="keywords" content="string">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>

</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>LeetCode&nbsp;-&nbsp;Two Pointers</strong>
</div>
<p class="date"><span class="created-date">Created:2019-02-03 都他妈的过年了，可我却在做leetcode，操蛋！！！</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-07-09 @2月3号秦楠，还好找到了Kabbage的Intern / 2019-08-26 找fulltime / 2019-09-06</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#intro">Introduction</a></li>
<li><a href="#example">Examples</a></li>
<li><a href="#reference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
    <div class="content" id="intro">
    <h3>Introduction</h3>
    <p>Two pointers questions' goal is to find an optimal solution, e.g. "best time to buy & sell stock", "biggest volume of containers". This kind of questions is based on the form of array or string. So we need to iterate throught an array or char[], which usually take O(n) runtime.</p>
    <p>We would need <span class="inline-code">left_index</span>, <span class="inline-code">right_index</span>, <span class="inline-code">result</span> e.g. max, and <span class="inline-code">attemp</span></p>
    <p>For <span class="inline-code">left_index</span> and <span class="inline-code">right_index</span>, we need figure out how to move them (direction and moving condition); and the formula for calculating <span class="inline-code">attemp</span>, it is most likely very simple.</p>
    </div>
    <div class="featureList">
        <h4>Array question</h4>
        <p>Array & String based questions can be solved by two pointers, dp, sorting, stack, backtracking</p>
        <ol>
            <li>
                <h4>two pointers vs. dynamic programming</h4>
                <p><span style="color:red">keyword: array, subarray, substring, minimum/maximum, longest</span></p>
                <p>both two pointers and dp may solve subarray/substring problem. But two pointers much like greedy that can solve it with one-pass, whereas DP can consider the global optimal solution.</p>
            </li>
            <li>
                <h4>two pointers vs. sorting array</h4>
                <p>If we need to know the sliding window size (relative distance of two element's index), or we need to return index. then we may not use sorting. <span style="color:red">(it's still possible to use sort with hashmap/array record index but no duplicated in the array)</span></p>
                <p>If an array can have duplicated elements, and ask return index, then we won't use sorting.</p>
            </li>
            <li><h4>two pointers vs. stack</h4></li>
            <li>
                <h4>two pointers vs. backtracking</h4>
                <p>Backtracking return a list of result. Backtracking's result is the enumeration of all valid result.</p>
            </li>
        </ol>
    </div>
</li>
<li>
    <div class="content" id="example">
        <h3>Examples</h3>
        <div class="featureList">
            <ol>
                <li>
                    <h4>3. Longest Substring Without Repeating Characters</h4>
                    <p>Desc: Given a string, find the length of the longest substring without repeating characters.</p>
                    <p>Sol: using a int[] (hashmap) to record char and its index. two pointer find max length. example "dvdf" (both pointer moves from right to left)</p>
                </li>
                <li>
                    <h4>11. Container With Most Water</h4>
                    <p>Desc: Given n non-negative integers a1, a2, ..., an. Each integer is the height of walls. What is the maximum amount of water?</p>
                    <p>Sol: two pointers move toward each other.</p>
                </li>
                <li>
                    <p class="algorithm-problem-title">* 26. Remove Duplicates from Sorted Array</p>
                    <p class="algorithm-problem-title">27. Remove Element</p>
                    <p class="algorithm-problem-title">80. Remove Duplicates from Sorted Array II</p>
                    <p>Desc: <br>
                        #26. given a sorted array that may have duplicated number, remove duplicates (最多出现一次), return new length.<br>
                        #80. given a sorted array, remove the duplicates in-place (最多出现两次), return new length.
                        #27. remove a target element from an arrary.

                    </p>
                    <p>Sol: two pointer, left and right pointer starts from 1.
                        <br> nextSlot.
                    </p>
                </li>
                <li>
                    <h4>** 75. Sort Colors</h4>
                    <p>Desc: given an array contains 0, 1, 2. sort in-place in one pass.</p>
                    <p>Sol: 3 pointer last0, current, first1. (last0 &lt; current &lt; first1). Dutch national flag problem</p>
                </li>
                <li>
                    <h4>** 31. Next Permutation</h4>
                    <p>Desc: given an array of integer, find the next permutation</p>
                    <p>Sol: step1. from the right to left: find the first element Q that is less than its right element. (if not exist, then the current number is the largest number, reverse the entire array)<br>
                        step2. from right to left: find the first element that is large than Q, and swap it with Q. 
                        step3. reverse the subarray after the Q's original position.
                    </p>
                </li>
                <li>
                    <h4><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Best time to buy and sell stock</a></h4>
                    <pre class="brush:java">
/* attemp always tries to use the next value, so the attemp's value may go down or go up. But once attemp gets a change to become bigger than the global max, then we assign 
update global max to record this attemp. 
*/
class Solution {
    public int maxProfit(int[] prices) {
        if(prices == null){
            return 0;
        }
        int max = 0, attemp =0, left_index = 0;
        for(int right_index = 1; right_index &lt; prices.length; right_index++){
            if(prices[right_index] &lt; prices[left_index]){
                left_index = right_index;
                continue;
            }
            attemp = prices[right_index] - prices[left_index];
            max = Math.max(max, attemp);
        }
        return max;
    }
}
                    </pre>
                    <h4>Algorithm generation</h4>
                    <p><span class="inline-code">right_index, max, attemp</span> are updated during each iteration. So the algorithm is generated by primarly thinking when to update the <span class="inline-code">left_index</span>. <span style="color:red">In the above example, <span class="inline-code">left_index</span> is updated when it is meaningless to update <span class="inline-code">attemp</span>.</p>
                    <h4>Verify solution</h4>
                    <p>...</p>
                </li>
                <li>
                    <h4><a href="https://leetcode.com/problems/trapping-rain-water/">Trapping rain water</a></h4>
                    <pre class="brush:java">
/**
* two pointer, moving with restriction and greedy
* restriction: only the min height side can be used.
* greedy: as long as it can be counted to the volume, we add it.
*/

class Solution {
    
    public int trap(int[] height) {
        if(height == null || height.length == 0) return 0;
        int leftmax = height[0], rightmax = height[height.length - 1];
        int leftpointer = 0, rightpointer = height.length - 1;
        int volume = 0;
        while(leftpointer &lt; rightpointer){
            if(leftmax &lt; rightmax){
                // moving left
                if(leftmax > height[leftpointer + 1]){
                    volume += leftmax - height[leftpointer + 1];
                }else{
                    leftmax = height[leftpointer + 1];
                }
                leftpointer++;
            }else{
                // moving right
                if(rightmax > height[rightpointer - 1]){
                    volume += rightmax - height[rightpointer - 1];
                }else{
                    rightmax = height[rightpointer - 1];
                }
                rightpointer--;
            }
        }
        return volume;
    }
}
                    </pre>
                </li>
            </ol>
        </div>
    </div>
</li>
<li>
<div class="content" id="reference">
<h3>References</h3>
<div class="featureList">
    <ol>
        <li></li>
    </ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
