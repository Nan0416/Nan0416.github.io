<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Methodology&nbsp;Dynamic Programming</title>
<meta charset="utf-8">
<meta name="date" content="2018-09-10">
<meta name="keywords" content="dp">
<meta name="keywords" content="dynamic_programming">
<meta name="keywords" content="microcontroller">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>
<style>
    .important{
        color:red;
        font-weight: bold;
    }
    .title{
        font-weight: bold;
    }
</style>
</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>Methodology&nbsp;Dynamic Programming</strong>
</div>
<p class="date"><span class="created-date">Created:2018-09-10</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-04-28</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#dpIntro">Introduction</a></li>
<li><a href="#runtime">Runtime Analysis</a></li>
<li><a href="#dpReferences">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="dpIntro">
<h3>Introduction</h3>
<p>Dynamic Programming is an idea. It is used to solve the questions that have <span class="important">many</span> solutions, 
but you need to find an optimal solution and/or an optimal solution's result.</p>
<h4>Example: Rod cutting</h4>
<p>Question: Find the way that produce the maximum revenue.</p>
<p>Analysis: You have many different ways to cut the rob, each produce a revenue. You need find the best way that produce the maximum revenue.</p>
<h5>Definition</h5>
<div class="featureList">
    <ol>
        <li><span class="title">optimal solution's result</span>: the maximum revenue.</li>
        <li><span class="title">optimal solution</span>: how to cut that will produce the maximum revenue.</li>
    </ol>
</div>
<p>If we not only need an optimal solution, but also an optimal way, then we may need to keep extra information to maintain each recursion's optimal way.</p>
<h4>Steps</h4>
<div class="featureList">
    <ol>
        <li><span class="title">Optimal substructure with recursive idea</span>: Suppose you have an optimal solution for given numbers 1, 2, ..., n, which is R1, R2, ..., Rn.
            Now generate a function that produce an optimal solution for n+1, namely, Rn+1 = F(Rn, Rn-1, Rn-2, Rn-3 ... ,R1)
            <span class="important">It is usual that the Rn+1 may only depends on Rn. e.g. Rn+1 = F(Rn)</span>
            <pre class="brush:java">
                    public int traditionalSolutionOnly(int length){
                        if(length &lt;= 1){
                            return prices[length];
                        }else{
                            int result = prices[length];
                            for(int i = 1; i &lt; length - 1; i++){
                                int temp = traditionalSolutionOnly(i) + prices[length - i];
                                if(temp > result){
                                    result = temp;
                                }
                            }
                            return result;
                        }
                    }
            </pre>
        </li>
        <li><span class="title">Optimal substructure with recursive idea and memorized each sub-solution</span>: Create a static table that keep each sub-solution.
            <pre class="brush:java">
                    private static int [] subSolutions = new int[11];
                    public int memorizedSolutionOnly(int length){
                        // memorized table
                        if(RodCutting.subSolutions[length] != -1){
                            return RodCutting.subSolutions[length];
                        }
                        if(length &lt;= 1){
                            RodCutting.subSolutions[length] = prices[length];
                            return prices[length];
                        }else{
                            int result = prices[length];
                            for(int i = 1; i &lt; length - 1; i++){
                                int temp = memorizedSolutionOnly(i) + prices[length - i];
                                if(temp > result){
                                    result = temp;
                                }
                            }
                            RodCutting.subSolutions[length] = result;
                            return result;
                        }
                    }
            </pre>
        </li>
        <li>
            <span class="title">Bottom-up: Bottom-up is an approache that compute from small to big. i.e. from R1 to Rn. In this case, we should define R[n] = R[n-1] ..., how to construct R[n] from pervious results.
                With bottom-up, no recursion is needed. Moreover, bottom-up can eliminate the table if Rn+1 is only depending on Rn.
            <p>Calculate from n = 1 to n</p>
            <pre class="brush:java">
                    public int buttomUp(int length){
                        int [] subSolutions = new int[10];
                        subSolutions[1] = prices[1];
                        for(int i = 2; i &lt= length; i++){
                            int temp = prices[i];
                            for(int j = 1; j &lt; i; j++){
                                if(temp &lt; subSolutions[j] + prices[i - j]){ 
                                    // Although subSolutions[j] is just the optimal solution for length = j, do not forget that 
                                    // it actually hides the complicated story about how it is generated.
                                    temp = subSolutions[j] + prices[i - j];
                                }
                            }
                            subSolutions[i] = temp;
                        }
                        return subSolutions[length];
            </pre>
        </li>
        <li>
            <span class="title">Bottom-up keeps the optimal way</span>: Keep each length i's cutting way. 
                <br>Each cutting method can be represented by an array.
                <br><span class="important">But Each cutting method only needs to know how to do the first dividing, the following sub-problem method can be recovered by them self.</span>
            <pre class="brush:java">
                    public int buttomUpKeepOptimalWay(int length){
                        int [] subSolutions = new int[11];
                        int [][] subWays = new int[length + 1][length + 1];
                        for(int i = 1; i &lt; length + 1; i++){
                            for(int j = 1; j &lt; length + 1; j++){
                                subWays[i][j] = -1;
                            }
                        }
                        subSolutions[1] = prices[1];
                        subWays[1][1] = 1; // length = 1, cutting method is [1]
                        for(int i = 2; i &lt;= length; i++){
                            int temp = prices[i];
                            int indicator = i;
                            for(int j = 1; j &lt; i; j++){
                                if(temp &lt; subSolutions[j] + prices[i - j]){ 
                                    temp = subSolutions[j] + prices[i - j];
                                    indicator = j;
                                }
                            }
                            if(indicator == i){
                                subWays[i][1] = i;
                            }else{
                                int k = 1;
                                for(;k &lt;= indicator; k++){
                                    if(subWays[indicator][k] == -1){
                                        break;
                                    }else{
                                        subWays[i][k] = subWays[indicator][k];
                                    }
                                }
                                subWays[i][k] = i - indicator;
                            }
                            subSolutions[i] = temp;
                        }
                        int counter = 1;
                        while(subWays[length][counter] != -1){
                            System.out.println(subWays[length][counter]);
                            counter++;
                        }
                        return subSolutions[length];
                    }
            </pre>
            <pre class="brush:java">
                    public int buttomUpKeepOptimalWayOnAnArray(int length){
                        int [] subSolutions = new int[11];
                        int [] subWays = new int[length + 1];
                        
                        subSolutions[1] = prices[1];
                        subWays[1] = 1; // length = 1, the first cutting is 1. 
                        for(int i = 2; i &lt;= length; i++){
                            int temp = prices[i];
                            int indicator = i;
                            for(int j = 1; j &lt; i; j++){
                                if(temp &lt; subSolutions[j] + prices[i - j]){ 
                                    temp = subSolutions[j] + prices[i - j];
                                    indicator = j;
                                }
                            }
                            
                            subWays[i] = indicator;
                            subSolutions[i] = temp;
                        }
                        printWay(length, subWays);
                        return subSolutions[length];
                    }
                    private void printWay(int length, int [] solutionArray){
                        if(solutionArray[length] != length){
                            printWay(solutionArray[length], solutionArray);
                            printWay(length - solutionArray[length], solutionArray);
                        }else{
                            System.out.println(length);
                        }
                    }
            </pre>
        </li>
    </ol>
</div>
</div>
</li>
<li>
    <div class="content" id="runtime">
        <h3>Runtime</h3>
        <p>Because DP problem is expressed as a recursion or a while-loop, we can define the runtime recursively. e.g. T(n) = T(n-1) + ...</p>
        <p>In this form, we can use master theorem.</p>
        <p>
            <img src="./img/master-theorem.png" width="700" height="120">
        </p>
    </div>
</li>
<li>
<div class="content" id="dpReferences">
<h3>References</h3>
<div class="featureList">
    <ol>
        
    </ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
