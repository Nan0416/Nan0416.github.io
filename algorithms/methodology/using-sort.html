<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<title>Array&nbsp;Sorting</title>
<meta charset="utf-8">
<meta name="date" content="2019-02-04">
<meta name="keywords" content="">
<meta name="keywords" content="">
<meta name="keywords" content="">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>

</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>Array&nbsp;-&nbsp;Sorting</strong>
</div>
<p class="date"><span class="created-date">Created:2019-02-04</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-02-04</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#intro">Introduction</a></li>
<li><a href="#reference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="intro">
<h3>Introduction</h3>
<p>Math: XOR <a href="https://leetcode.com/problems/single-number/">Single Number</a></p>
</div>
</li>
<li>
    <div class="content" id="example">
        <h3>Examples</h3>
        <p>Keywords: <span style="color:red">array</span></p>
        <h4>Where to apply?</h4>
        <div class='featureList'>
            <ol>
                <li>Given an array, return an element or a set elements (not index) that satisfy a condition (e.g. 3sum, 4sum)</li>
            </ol>
        </div>
        <div class="featureList">
            <ol>
                <li>
                    <h4>* 15. 3Sum</h4>
                    <h4>16. 3Sum Closest</h4>
                    <h4>* 259. 3Sum Smaller</h4>
                    <p>Desc: <br>
                        15. given an array of numbers, return all unique triplets the sum = 0<br>
                        16. 3Sum closest is easier since don't need to consider the duplicated scenario.<br>
                        259. Given an array integers and a target, find the number of all index triplets that sum &lt; target.
                    </p>
                    <p>Sol: 
                        15 & 16. sorted and then loop. The inner loop is a kind of two pointers that move to each other. Avoid duplicated.
                        259. sorted and then loop O(n^2), the inner loop is a two pointer.
                    </p>
                </li>
                <li>
                    <h4><a href="https://leetcode.com/problems/merge-intervals/">Merge Interval</a></h4>
                    <pre class="brush:java">
/**
* Java 8 lambda sorting
* intervals.sort((i1, i2)->Integer.compare(i1.start, i2.start));
*/
class Solution {
    public List&lt;Interval> merge(List&lt;Interval> intervals) {
        intervals.sort((i1, i2)->Integer.compare(i1.start, i2.start));
        List&lt;Interval> result = new LinkedList&lt;Interval>();
        Interval interv = null;
       
        for(int i = 0; i &lt; intervals.size(); i++){
            Interval temp = intervals.get(i);
            if(interv == null){
                interv = temp;
            }else if(interv.end >= temp.start){
                // merge
                interv.end = interv.end > temp.end? interv.end: temp.end;
            }else{
                result.add(interv);
                interv = temp;
            }
        }
        if(interv!=null)
            result.add(interv);
        return result;
    }
}
                    </pre>
                </li>
                <li>
                    <h4>* 56. Merge Intervals</h4>
                    <p>Desc: given an array of interval (each interval is an array of 2 elements) merge all interval, .e.g [[1,4],[4,7],[2,5],[8,9]] ->[[1,7],[8,9]]</p>
                    <p>Sol: 1). this question is actually a <span style="color:red">connected components</span> question, however, different from a traditional UnionFind question, it doesn't
                         give any two interval are in one group (e.g. each interval is an node, you have to build edges by yourself). But the building each edge will need O(n) time. So With unionfind,
                          the runtime will be O(n^2)</p>
                    <p>The simple solution is using sort. Sort by the interval start point. Merge two intervals e.g. [1,5] & [4,7] and <span style="color:red">[1,5] & [2,3] and update the end point with the biggest value.</span></p>
                </li>
            </ol>
        </div>
    </div>
</li>
<li>
<div class="content" id="reference">
<h3>References</h3>
<div class="featureList">
    <ol>
        <li></li>
    </ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
