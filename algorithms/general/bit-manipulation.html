<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<title>General&nbsp;Bit Manipulation</title>
<meta charset="utf-8">
<meta name="date" content="2019-09-08">
<meta name="keywords" content="">
<meta name="keywords" content="">
<meta name="keywords" content="">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushPython.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushSql.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>

</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>Bit&nbsp;-&nbsp;Manipulation</strong>
</div>
<p class="date"><span class="created-date">Created:2019-09-08</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-09-11</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#intro">Introduction</a></li>
<li><a href="#example">Examples</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="intro">
<h3>Introduction</h3>
<div class="featureList">
    <h4>Common knowledge</h4>
    <ol>
        <li>
            <h4>get the right-most 1</h4>
            <pre class="brush:java">
                // no overflow problem
                int n = 0b0110;
                int rightmostOne = n & (-n); // n & (~n + 1)
                // 0b0110 & 0b1010 => 0b0010;
            </pre>
        </li>
        <li>
            <h4>set the right-most 1 to 0.</h4>
            <pre class="brush:java">
                int n = 0b0110;
                int setZero = n & (n-1);
                // 0b0110 & 0b0101 => 0b0100;
            </pre>
            <p>Where to apply? count #1 in an integer (inc 1 by setting rightmost to 0 until it = 0). e.g. 191. Number of 1 Bits</p>
        </li>
        <li>
            <h4>get the left-most 0</h4>
            <pre class="brush:java">
                // combine the above two, we can get the left-most 0
                while(number != (number & (~number + 1))){ // set the right-most 1 to 0 until we reach only a single one left.
                    number = number & (number -1);
                }
            </pre>
        </li>
    </ol>
</div>
</div>
</li>
<li>
<div class="content" id="reference">
<h3>Examples</h3>
<div class="featureList">
    <h4>Where to apply?</h4>
    <ol>
        <li>
            <h4>Directly maniuplate number (most using XOR)</h4>
        </li>
        <li>
            <h4>Convert string/collections to integer, and then apply bit property.</h4>
            <p>e.g. find common character with AND</p>
        </li>
    </ol>
    <h4>Example</h4>
    <ol>
        <li>
            <p class="algorithm-problem-title">136. Single Number</p>
            <p class="algorithm-problem-title">389. Find the Difference</p>
            <p class="algorithm-problem-title">* 268. Missing Number (tricky)</p>
            <p class="algorithm-problem-title">260. Single Number III</p>
            <p class="algorithm-problem-title">137. Single Number II</p>
            <p>Desc:<br>
                #136. given an array of integers that each value appears twice except one value only appear once. find the unique number.<br> 
                #389. given two string s and t (only lowercase). t is generated by shuffling s and add one more char. find the added char in t.<br>
                #268. given an array of integers with length = n, and it contains n distinct numbers in range [0, n] there must miss one number, find the missing number. <br>
                #138. given an array of integers that each value appears twice except two values appear once. find the two unique numbers.<br>
                #137. given an array of integers that each value appears three times except one value only appear once. find the unique number.
                
            </p>
            <p>Sol: #136. Bit-manipulation.
                <p style="color:red">How to consider questions of bit-manipulation?</p>
                <p>Don't consider a number, instead think about <span style="color:red">bit collections</span> that constructs by bit on same position of each number.</p>
                <pre class="brush:java">
                    [1,3,3,2,2] => [01, 11, 11, 10, 10]
                    => [
                        [0,1,1,1,1], // bit at second position
                        [1,1,1,0,0], // bit at first position.
                        ]
                </pre>
                <p>For #136. if the unique number's bit on a position is 1, then it must cause this bit collection has odd number of 1.</p>
                <p style="color:red">What is XOR operation?</p>
                <p>XOR doesn't treat a number as a whole, instead, it operate/update according to <span style="color:red">bit collection</span>.<br>
                XOR (starting with 0), it will repeat +1 and -1 when encountering the next one in a bit collection. (or say it will return 1 if the # of 1 in a bit collection is odd, otherwise 0).
                </p>
                <pre class="brush:java">
                    [
                        [0,1,1,1,1] => return 0.
                        [1,1,1,0,0] => return 1. // 01 construct 1. 1 is the unique number.
                    ]
                    // moreover, XOR doesn't care about the order of the 1 and 0 is a bit collection.
                </pre>
            </p>
            <p>
                #389. if you concatenate the two string, then it's same as #136.<br>
                <span style="color:red">second solution: </span>because we know only lowercase, we can use an array (hasmap) to count each char. 
            </p>
            <p>
                #268. missing number. <span style="color:red">Math solution</span>: [0..n] sum = n * n + 1) / 2 - sum of the array<br>
                index = 0 ... n-1, element = 0...n missing one. we add one index value = n. then it becomes [0..n-1, 0..n (missing one), n] => find unique number. 
            </p>
            <p>
                #138. applying the #136's solution gives the XOR of the two unique number. The xor result is the difference between the two unique numbers.
                <pre class="brush:java">
                    int xor = 0b110; // first bit are same, second and third bits are different. 
                    We can use this number to divide the original array into two groups. e.g. One group with the second bit = 1, another group with the second bit = 0. With this, we know that two unique numbers must belong to different group.
                    And then we can apply the XOR trick again.
                </pre>
            </p>
            <p>
                #137. if the unique number's bit on a position is 1, then its bit collection must have 3n + 1 1s, otherwise 3n 1s.<br>
                <pre class="brush:java">
                        int [] count = new int[32];
                        for(int num: nums){
                            for(int i = 0; i &lt; 32; i++){
                                count[i] += (num >> i) & 1; // get (32-i)-th position 1.
                            }
                        }
                        int result = 0;
                        for(int i = 0; i &lt; 32; i++){
                            if(count[i] % 3 != 0){
                                result |= 1 &lt;&lt; i;
                            }
                        }
                        return result;
                </pre>
                <p>space optimization with two flags</p>
                <pre class="brush:java">
                        int bit1 = 0;
                        int bit2 = 0;
                        private void increment(int position){
                            int bit2_ = (bit2 >>> position) & 1;
                            int bit1_ = (bit1 >>> position) & 1;
                            if(bit2_ == 0 && bit1_ == 0){ // 0->1
                                bit1 |= 1 &lt;&lt; position;
                            }else if(bit2_ == 0 && bit1_ == 1){ // 1->2
                                bit2 |= 1 &lt;&lt; position;
                                bit1 &= ~(1 &lt;&lt; position);
                            }else if(bit2_ == 1 && bit1_ == 1){ // 2->0
                                bit2 &= ~(1 &lt;&lt; position);
                            }
                        }
                        public int singleNumber(int[] nums) {
                            for(int num: nums){
                                for(int i = 0; i &lt; 32; i++){
                                    if(((num >>> i) & 1) == 1){
                                        increment(i);
                                    }
                                }
                            }
                            return bit1;
                        }
                </pre>
                <p>Runtime optimization with state machine</p>
                <pre class="brush:java">
                    // state machine
                    we need to keep track of the number of 1 in each bit collection. like above, we do 0->1->2->0->1->2.
                    However, we have to iterate every bit in a number to do that, and it involves shift operations.
                    we acutally can handle all the 32 bits at one operation with state machine.

                    we still use 2 integers (bit1, bit2) represent the state. now only think about the i-th bit of the bit1, bit2 and the given number.
                </pre>
                <p>Here is the state machine and truth table of bit2.</p>
                <p>
                    <img src="./img/state-machine.png" width="400" height="140">
                </p>
                <p>We can found the only two cases make bit2 be 1. and we can express using ~ & |. So we will the solution below. <span style="color:red">
                    When thinking about a bit collection, we will not be able to change the bit's position, in other words, we cannot use shift operation.</span></p>
                <pre class="brush:java">
                        int bit1 = 0, bit2 = 0;
                        for(int input: nums){
                            int oldbit1 = bit1;
                            int oldbit2 = bit2;
                            bit1 = (~oldbit2 & ~oldbit1 & input) | (~oldbit2 & oldbit1 & ~input);
                            bit2 = (oldbit2 & ~input) | (~oldbit2 & oldbit1 & input);
                        }
                        return bit1;
                </pre>
            </p>
        </li>
        <li>
            <p class="algorithm-problem-title">201. Bitwise AND of Numbers Range</p>
        </li>
        <hr>
        <li>
            <p class="algorithm-problem-title">318. Maximum Product of Word Lengths</p>
        </li>
    </ol>
    <hr>
    <h4>Easy</h4>
    <p>231. Power of Two (get the right-most 1 == original number)</p>
    <p>190. Reverse Bits (given an integer as unsigned [ignored MSB], reverse it).</p>
    <p>191. Number of 1 Bits.</p>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
