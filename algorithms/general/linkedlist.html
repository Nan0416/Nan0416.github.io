<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<title>General&nbsp;LinkedList</title>
<meta charset="utf-8">
<meta name="date" content="2019-02-03">
<meta name="keywords" content="">
<meta name="keywords" content="">
<meta name="keywords" content="">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>

</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>General&nbsp;-&nbsp;LinkedList</strong>
</div>
<p class="date"><span class="created-date">Created:2019-02-03</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-08-16 @ Rockford, IL</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#intro">Introduction</a></li>
<li><a href="#example">Examples</a></li>
<li><a href="#problem">Problems</a></li>
<li><a href="#reference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="intro">
<h3>Introduction</h3>
<p>LinkedList的问题很直接，直接说明要怎么样一个linkedlist, e.g. deep copy. 主要考编程能力而不是算法。</p>
<p>LinkedList的问题有时需要用到HashMap辅助，但一般这种题都有更tricky/smart的solution不用HashMap。</p>
<p>Tips: dummyHead node. Create a dummy node as the new head when the original head may be updated or removed.</p>
<p>Using recursion can also make problems easier.</p>
</div>
</li>
<li>
    <div class="content" id="example">
        <h3>Examples</h3>
        <div class="featureList">
            <ol>
                <li>
                    <h4>138. Copy List with Random Pointer</h4>
                    <p>Approach 1. using hashmap: copy the linkedlist without considering the random pointer. During the process, create a mapping between old nodes and new nodes. Then use the mapping to build random pointers.</p>
                    <p>Approach 2. Create the new list upon old list without using extra space.</p>
                </li>
                <li>
                    <h4>Floyd Cycle detection algorithm</h4>
                    <p>With different step</p>
                </li>
            </ol>
        </div>
    </div>
</li>
<li>
    <div class="content" id="problem">
        <h3>Problems</h3>
        <div class="featureList">
            <ol>
                <li>
                    <h4>2. Add Two Numbers</h4>
                    <p>Desc: 2 non-empty linked lists (not Java LinkedList) in reverse order, each node represents a digit. Add the 2 lists as adding two integer, return the integer result.</p>
                    <p>Sol: too easy to have a solution.</p>
                </li>
                <li>
                    <h4>* 19. Remove Nth Node From End of List</h4>
                    <p>Desc: Given a linked list, remove the n-th node from the end of list and return its head.</p>
                    <p>
                        Sol: A trivial solution is to first go through the list to find its length, and then in the second pass find the target node. <br>
                        <span style="color:red">But we can reduce it to one pass by using two pointers, one pointer ahead of another pointer by n steps.</span>
                    </p>
                    <p>
                        Corner case: 1). n = list's length (remove the 1st), 2). n = 0 (remove nothing)
                    </p>
                </li>
                <li>
                    <h4>24. Swap Nodes in Pairs</h4>
                    <p>Desc: given a linkedlist, swap nodes in pairs e.g. 1->2->3->4->5, 2->1->4->3->5.</p>
                    <p>Sol: a easier solution is to use recursion. in this case, we don't need the dummyhead even through the original head is modified.</p>
                </li>
                <li>
                    <h4>* 61. Rotate List</h4>
                    <p>Desc: given a linkedlist and a number k, rotate the linked list k times.  1->2->3->4->5->NULL, k = 2, return 4->5->1->2->3->NULL</p>
                    <p>Sol: (the k may > len). 1. find the length 2. find k = k % len. 3. find the new head at len - k. 4 connect end to front.<br>
                    <span style="color:red"> another solution is switch step 3 and step 4. first construct a ring.</span>
                    </p>
                </li>
                <li>
                    <h4>92. Reverse Linked List II</h4>
                    <p>Desc: given a linkedlist and two number n,m (1 &lt;= n &lt;= m &lt;= len). e.g. 1->2->3->4->5->NULL, m = 2, n = 4, return 1->4->3->2->5->NULL</p>
                    <p>Sol: using dummyhead since the original head may change.</p>
                </li>
                <li>
                    <h4>86. Partition List</h4>
                    <p>Desc: given a linkedlist and a target number, put node at front if node.val &lt; target, otherwise put at the end. Moreover, preserve the original relative order. e.g. 1->4->3->2->5->2, x = 3, return 1->2->2->4->3->5</p>
                    <p>Sol: two dummyhead smalllist, biglist and then put the biglist at the end of smallist. <span style="color:red">Bug: do not forget to terminate the last element of biglist.</span></p>
                </li>
                <li>
                    <p class="algorithm-problem-title">* 82. Remove Duplicates from Sorted List II</p>
                    <p class="algorithm-problem-title">83. Remove Duplicates from Sorted List</p>
                    <p>
                        Desc:<br>
                        #82. given a sorted linkedlist, remove all nodes that have duplicates. 1->2->3->3->4->4->5->null, return 1->2->5->null.<br>
                        #83. given a sorted linkedlist, remove duplicate node to make each number only appears once.
                    </p>
                    <p>Sol:<br>
                        #83 is easy, create a removeNext function, if the next node is same the current node, remove the next node; otherwise, we move to next node.<br>
                        #82. <span style="color:red">Using dummyhead since the original head may be deleted.</span>
                    </p>
                </li>
                <li>
                    <p class="algorithm-problem-title">21. Merge Two Sorted Lists</p>
                    <p class="algorithm-problem-title">* 23. Merge k Sorted Lists</p>
                    <p>
                        Desc: <br>
                        #21. 2 sorted linked list (not Java LinkedList). Merge them in sorted order.<br>
                        #23. Same as #21 but this merge an array of linkedlist.
                    </p>
                    <p>Sol: multiple solutions existed.<br>
                        1). With #21 solution, we can merge linked list one by one.
                        <pre class="brush:java">
                            // O(m * N), m is array.length, N is total numbers of nodes.
                            for(head: linkedlists){
                                result = mergeTwo(result, head);
                            }
                        </pre>
                        2). With priority queue N * 2 * lgm: the queue's size is m, each node has a enqueue and dequeue operation. So O(N 2 lgm) = O(Nlgm)<br>
                        3). With binary merge <span style="color:red">Fastest</span>
                        <pre class="brush:java">
                            // O(Nlgm)
                            queue;
                            while(queue.size() > 1){
                                ListNode first = queue.poll();
                                ListNode second = queue.poll();
                                queue.offer(mergeTwoLists(first, second));
                            }
                            return queue.poll();
                        </pre>
                    </p>
                </li>
            </ol>
        </div>
    </div>
</li>
</ol>
</div>
    
</body>
</html>
