<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<title>LeetCode&nbsp;Two Pointers</title>
<meta charset="utf-8">
<meta name="date" content="2019-02-03">
<meta name="keywords" content="two pointers">
<meta name="keywords" content="array">
<meta name="keywords" content="string">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>

</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>LeetCode&nbsp;-&nbsp;Two Pointers</strong>
</div>
<p class="date"><span class="created-date">Created:2019-02-03 都他妈的过年了，可我却在做leetcode，操蛋！！！</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-07-09 @2月3号秦楠，还好找到了Kabbage的Intern</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#intro">Introduction</a></li>
<li><a href="#example">Examples</a></li>
<li><a href="#reference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
    <div class="content" id="intro">
    <h3>Introduction</h3>
    <p>Two pointers questions' goal is to find an optimal solution, e.g. "best time to buy & sell stock", "biggest volume of containers". This kind of questions is based on the form of array or string. So we need to iterate throught an array or char[], which usually take O(n) runtime.</p>
    <p>We would need <span class="inline-code">left_index</span>, <span class="inline-code">right_index</span>, <span class="inline-code">result</span> e.g. max, and <span class="inline-code">attemp</span></p>
    <p>For <span class="inline-code">left_index</span> and <span class="inline-code">right_index</span>, we need figure out how to move them (direction and moving condition); and the formula for calculating <span class="inline-code">attemp</span>, it is most likely very simple.</p>
</p>
    </div>
</li>
<li>
    <div class="content" id="example">
        <h3>Examples</h3>
        <div class="featureList">
            <ol>
                <li>
                    <h4><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Best time to buy and sell stock</a></h4>
                    <pre class="brush:java">
/* attemp always tries to use the next value, so the attemp's value may go down or go up. But once attemp gets a change to become bigger than the global max, then we assign 
update global max to record this attemp. 
*/
class Solution {
    public int maxProfit(int[] prices) {
        if(prices == null){
            return 0;
        }
        int max = 0, attemp =0, left_index = 0;
        for(int right_index = 1; right_index &lt; prices.length; right_index++){
            if(prices[right_index] &lt; prices[left_index]){
                left_index = right_index;
                continue;
            }
            attemp = prices[right_index] - prices[left_index];
            max = Math.max(max, attemp);
        }
        return max;
    }
}
                    </pre>
                    <h4>Algorithm generation</h4>
                    <p><span class="inline-code">right_index, max, attemp</span> are updated during each iteration. So the algorithm is generated by primarly thinking when to update the <span class="inline-code">left_index</span>. <span style="color:red">In the above example, <span class="inline-code">left_index</span> is updated when it is meaningless to update <span class="inline-code">attemp</span>.</p>
                    <h4>Verify solution</h4>
                    <p>...</p>
                </li>
                
                <li>
                    <h4><a href="https://leetcode.com/problems/container-with-most-water/">Container With most water</a></h4>
                    <pre class="brush:java">
// attemp = min(height[left_index], height[right_index]) * (right_index - left_index)
class Solution {
    public int maxArea(int[] height) {
        int max = 0, attemp = 0, left_index = 0, right_index = height.length - 1;
        while(left_index &lt; right_index){
            attemp = Math.min(height[left_index], height[right_index]) * (right_index - left_index);
            max = max > attemp? max : attemp;
            if(height[left_index] &lt; height[right_index]){
                left_index++;
            }else{
                right_index--;
            }
        }
        return max;
    }
}
                    </pre>
                    <p>This question still involved the 4 variables. But the direction of moving poiner is different than the above question. This question moving <span class="inline-code">left_index</span> and <span class="inline-code">right_index</span> towards each others.</p>
                    <p>In this question, the not moved index should have a bigger height since it could potentially result in a bigger volume.</p>
                </li>
                <li>
                    <h4><a href="https://leetcode.com/problems/trapping-rain-water/">Trapping rain water</a></h4>
                    <pre class="brush:java">
/**
* two pointer, moving with restriction and greedy
* restriction: only the min height side can be used.
* greedy: as long as it can be counted to the volume, we add it.
*/

class Solution {
    
    public int trap(int[] height) {
        if(height == null || height.length == 0) return 0;
        int leftmax = height[0], rightmax = height[height.length - 1];
        int leftpointer = 0, rightpointer = height.length - 1;
        int volume = 0;
        while(leftpointer &lt; rightpointer){
            if(leftmax &lt; rightmax){
                // moving left
                if(leftmax > height[leftpointer + 1]){
                    volume += leftmax - height[leftpointer + 1];
                }else{
                    leftmax = height[leftpointer + 1];
                }
                leftpointer++;
            }else{
                // moving right
                if(rightmax > height[rightpointer - 1]){
                    volume += rightmax - height[rightpointer - 1];
                }else{
                    rightmax = height[rightpointer - 1];
                }
                rightpointer--;
            }
        }
        return volume;
    }
}
                    </pre>
                </li>
                <li>
                    <h4><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters</a></h4>
                    <pre class="brush:java">
/**
* My mistake: using a set to record visited characters. When get a duplicated char,
* start from 0. This is not correct e.g. "dvdef", when encountering the second "d", * we don't have to start from 0, instead we start from 1 with counting 'v'.
*
* This problem can be solved with sliding windows (two pointers).
*
* Using a map to record each visited char's index. A left pointer and a rigth 
* pointer, when encounting a duplicated, mvoing the left pointer by 1.
*
* substring length is represent as rightIndex - leftIndex + 1, both side inclusive.
* both side inclusive required string length >= 1.

left side inclusive, right side exclusive: right - left = length;
*/

class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s == null) return 0;
        Map&lt;Character, Integer> hm = new HashMap&lt;Character, Integer>();
        int leftPointer = 0, rightPointer = 0, max = 0;
        for(; rightPointer &lt; s.length(); rightPointer++){
            if(hm.containsKey(s.charAt(rightPointer))){
                //update leftPointer to the non-duplicated one
                /*
                * Using math.max to guarantee leftPointer only goes left.
                */
                leftPointer = 
                    Math.max(hm.get(s.charAt(rightPointer)) + 1, leftPointer);
            }
            max = Math.max(max, rightPointer + 1 - leftPointer);
            hm.put(s.charAt(rightPointer), rightPointer);
        }
        return max;
        
    }
}
                    </pre>
                </li>
            </ol>
        </div>
    </div>
</li>
<li>
<div class="content" id="reference">
<h3>References</h3>
<div class="featureList">
    <ol>
        <li></li>
    </ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
