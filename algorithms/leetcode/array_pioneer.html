<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<title>LeetCode&nbsp;Array</title>
<meta charset="utf-8">
<meta name="date" content="2019-02-03">
<meta name="keywords" content="">
<meta name="keywords" content="">
<meta name="keywords" content="">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>

</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>LeetCode&nbsp;-&nbsp;Array Pioneer (Two Pointers)</strong>
</div>
<p class="date"><span class="created-date">Created:2019-02-03 都他妈的过年了，可我却在做leetcode，操蛋！！！</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-02-04</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#intro">Introduction</a></li>
<li><a href="#example">Examples</a></li>
<li><a href="#reference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
    <div class="content" id="intro">
    <h3>Introduction</h3>
<p>Array的题先去想能不能用sort的方式解决。如何和index有关系，（e.g. 2sum 让返回index, container水的体积），那么有可能会用hashmap去记录&lt;value, index></p>
<p>Array还有一种tricky的是用two pointers (container水的体积): 有一个max，还有两个pointers在尝试 
    <br>
    Sometimes, two pointers comes from the optimization of the brute force solution.
</p>
    </div>
</li>
<li>
    <div class="content" id="example">
        <h3>Examples</h3>
        <div class="featureList">
            <ol>
                <li>
                    <h4><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Best time to buy and sell stock</a></h4>
                    <pre class="brush:java">
/* pionner always tries to use the next value, so the poinner's value may go down or 
go up. But once pioneer gets a change to bigger than the global max, then we assign 
pioneer to global max. 
When pionner becomes less than 0, we ignore all the pervious value and reset pioneer to 0, because having a negative value always makes the pioneer samll.
*/
class Solution {
    public int maxProfit(int[] prices) {
        if(prices == null || prices.length &lt; 2){
            return 0;
        }
        int max = 0;
        int pioneer = 0;
        for(int i = 1; i &lt; prices.length; i++){
            pioneer += prices[i] - prices[i-1];
            if(pioneer > max){
                max = pioneer;
            }
            if(pioneer &lt; 0){
                pioneer = 0;
            }
        }
        return max;
        
    }
}
                    </pre>
                </li>
                <li>
                    <h4><a href="https://leetcode.com/problems/majority-element/">Majority element</a></h4>
                    <p>The numebr of majority element is larger than n/2</p>
                    <pre class="brush:java">
/**
The majority variable can be modified during this process. But eventually, the real 
majority element will win.
*/
class Solution {
    public int majorityElement(int[] nums) {
        if(nums == null) return 0;
        
        int count = 0;
        int majority = nums[0];
        for(int i = 1; i &lt; nums.length; i++){
            if(majority == nums[i]){
                count++;
            }else{
                count--;
            }
            if(count &lt; 0){
                count = 0;
                majority = nums[i];
            }
        }
        return majority;
    }
}
                    </pre>
                </li>
                <li>
                    <h4><a href="https://leetcode.com/problems/container-with-most-water/">Container With most water</a></h4>
                    <pre class="brush:java">
// Two pointers
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int max = 0; 
        while(right > left){
            int temp = (right - left) * Math.min(height[left], height[right]);
            if(temp > max){
                max = temp;
            }
            if(height[left] &lt; height[right]){
                left++;
            }else if(height[left] == height[right]){
                if(height[left+1] > height[right-1]){
                    left++;
                }else{
                    right--;
                }
            }else{
                right--;
            }
        }
        return max;
    }
}
                    </pre>
                </li>
                <li>
                    <h4><a href="https://leetcode.com/problems/trapping-rain-water/">Trapping rain water</a></h4>
                    <pre class="brush:java">
/**
* two pointer, moving with restriction and greedy
* restriction: only the min height side can be used.
* greedy: as long as it can be counted to the volume, we add it.
*/

class Solution {
    
    public int trap(int[] height) {
        if(height == null || height.length == 0) return 0;
        int leftmax = height[0], rightmax = height[height.length - 1];
        int leftpointer = 0, rightpointer = height.length - 1;
        int volume = 0;
        while(leftpointer &lt; rightpointer){
            if(leftmax &lt; rightmax){
                // moving left
                if(leftmax > height[leftpointer + 1]){
                    volume += leftmax - height[leftpointer + 1];
                }else{
                    leftmax = height[leftpointer + 1];
                }
                leftpointer++;
            }else{
                // moving right
                if(rightmax > height[rightpointer - 1]){
                    volume += rightmax - height[rightpointer - 1];
                }else{
                    rightmax = height[rightpointer - 1];
                }
                rightpointer--;
            }
        }
        return volume;
    }
}
                    </pre>
                </li>
                <li>
                    <h4><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters</a></h4>
                    <pre class="brush:java">
/**
* My mistake: using a set to record visited characters. When get a duplicated char,
* start from 0. This is not correct e.g. "dvdef", when encountering the second "d", * we don't have to start from 0, instead we start from 1 with counting 'v'.
*
* This problem can be solved with sliding windows (two pointers).
*
* Using a map to record each visited char's index. A left pointer and a rigth 
* pointer, when encounting a duplicated, mvoing the left pointer by 1.
*
* substring length is represent as rightIndex - leftIndex + 1, both side inclusive.
* both side inclusive required string length >= 1.

left side inclusive, right side exclusive: right - left = length;
*/

class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s == null) return 0;
        Map&lt;Character, Integer> hm = new HashMap&lt;Character, Integer>();
        int leftPointer = 0, rightPointer = 0, max = 0;
        for(; rightPointer &lt; s.length(); rightPointer++){
            if(hm.containsKey(s.charAt(rightPointer))){
                //update leftPointer to the non-duplicated one
                /*
                * Using math.max to guarantee leftPointer only goes left.
                */
                leftPointer = 
                    Math.max(hm.get(s.charAt(rightPointer)) + 1, leftPointer);
            }
            max = Math.max(max, rightPointer + 1 - leftPointer);
            hm.put(s.charAt(rightPointer), rightPointer);
        }
        return max;
        
    }
}
                    </pre>
                </li>
            </ol>
        </div>
    </div>
</li>
<li>
<div class="content" id="reference">
<h3>References</h3>
<div class="featureList">
    <ol>
        <li></li>
    </ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
