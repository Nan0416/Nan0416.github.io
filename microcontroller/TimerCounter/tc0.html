<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>TC0</title>
<meta charset="utf-8">
<meta name="date" content="2018-02-04">
<meta name="keywords" content="timer">
<meta name="keywords" content="atmega328p">
<meta name="keywords" content="counter">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>TC0</strong></center>
</div>
<p class="date"><span class="created-date">Created:2018-02-04</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2018-02-04</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#tcIntro">Introduction</a></li>
<li><a href="#tcOperatingMode">Operating Modes</a></li>
<li><a href="#tcSummary">Summary</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="tcIntro">
<h3>Introduction</h3>
<p>Timer/Counter 0 in atmega328p has an 8-bit counter register that is inc/dec in each clkTn. The clkTn is controlled by the clock selection unit.</p>
<p>Interrupt and PWM output pins behavior are independent. For example, even if all interrupts are disabled but if the OC0A (PD6 for generating PWM) is configured properly, this pin still has output.</p>
<div class="featureList">
<h4>Clock selection unit</h4>
<p>Configured by the TCCR0B.CS[2:0]</p>
<p><img src="./img/timer.png" width="700" height="250"></p>
<ol>
<li>TO pin is the PD4</li>
<li>A slower speed of arduino nano. Arduino nano default using the 16MHz external oscillator. By setting the CLKPR system clock prescaler, the speed can be 62500Hz.
Using the CS bits, the timer/counter speed could be 61.035Hz. <span style="color:red">Then the counter register overflow would need 256 / 61.035 = 4.194s</span>
</li>
</ol>
</div>
<div class="featureList">
<h4>Register bits and their functions</h4>
<ol>
<li>WGM0: select mode</li>
<li>CS0: select clock source and frequency</li>
<li>COM0A: select OC0A (PD6) pin behaviors (PWM configuration)</li>
<li>COM0B: select OC0B (PD5) pin behaviors (PWM configuration)</li>
<li>TIMSK: enable interrupts (interrupt configuration)</li>
<li>TCNT0: TC0 counter value</li>
<li>OCR0A: output compare register A</li>
<li>OCR0B: output compare register B</li>
</ol>
</div>

<div class="featureList">
<h4>Operation modes</h4>
<ol>
<li>Normal mode, top = 0xff</li>
<li>CTC mode, top = ocr0A</li>
<li>fast PWM, top = 0xff or top = ocr0A</li>
<li>Phase correct PWM, top = 0xff or top = ocr0A</li>
</ol>
<div class="termnology">
<h4>Terms</h4>
<ul>
<li>Duty cycle: the fraction of one period in which a signal or system is active</li>
</ul>
</div>

</div>

</div>
</li>
<li>
<div class="content" id="tcOperatingMode">
<h3>Operating Modes</h3>
<div class="featureList">
<ol>
<li>
<h4>Normal mode</h4>
<p>In this case, ocr0A/B only affects interrupts but not the behavior of oc0A/B</p>
<h4>TCNT0</h4>
<p>TCNT0 increment from 0x00 to 0xff, and reset to 0x00</p>
<div class="featureList">
<h4>OC0A/OC0B</h4>
<ol>
<li>COM0A/B = 0x01: toggle oc0A/B when tcnt0 is cleared (immediate after overflow)</li>
<li>COM0A/B = 0x10: clear oc0A/B when tcnt0 is cleared</li>
<li>COM0A/B = 0x11: set oc0A/B when tcnt0 is cleared</li>
</ol>
<p class="starMark">* The Compare Match in the datasheet means tcnt0 = 0xff</p>
</div>
<div class="featureList">
<h4>Interrupts</h4>
<ol>
<li>OVF: the flag bit is set after the cycle that tcnt = 0xff. (It is like the 9th bit of the 8-bit tcnt register but it is not set)</li>
<li>COMPA: when tcnt0 = ocr0A</li>
<li>COMPB: when tcnt0 = ocr0B</li>
</ol>
</div>
<h4>Examples</h4>
<pre class="brush: cpp">
#define F_CPU 62500UL
#include &lt;avr/interrupt.h>
#include &lt;avr/io.h>
#include &lt;util/delay.h>
#include &lt;stdint.h>
// the PB5 and PD6(OC0A) set at different time, which means the compare match of ocr0A cannot toggle the OC0A
void blink(){
    //blink the built-in led PB5
    DDRB |= 0x20;
    PORTB |= 0x20;
    _delay_ms(50);
    PORTB &amp;= ~0x20;
    _delay_ms(50);
}
ISR(TIMER0_OVF_vect){
    blink();
}
ISR(TIMER0_COMPA_vect){
    blink();
}
ISR(TIMER0_COMPB_vect){
    blink();
}
void init(){
    DDRD |= 0x40; // set PD6 as output, connect to a led
    TCNT0 = 0x00; //clear the counter
    TCCR0A = 0x40; //set as normal mode, oc0A is toggle
    TIMSK0 = 0x01; //open compare match ocr0A interrupt
    TCCR0B = 0x04; //set as normal mode, select clock frequency
    OCR0A = 0x20; // set ocr0A
}
int main(){
    cli();
    CLKPR = 0x80;
    CLKPR = 0x08;
    sei();
    init();
    while(1);
    return 0;

}
</pre>
<h4>Timing analysis</h4>
<div class="featureList">
<ol>
<li>OC0A/B changes at every 256 / Ftcnt(seconds) <span style="color:green">(Ftcnt = F system/timer prescale)</span></li>
<li>3 interrupts happens at every 256 / Ftcnt</li>
</ol>
</div>

</li>
<li>
<h4>CTC (Clear timer on Compare Match) Mode</h4>
<p class="starMark">* The compare match for OC0A means tcnt = ocr0A; the compare match for OC0B means tcnt = ocr0B</p>
<h4>TCNT0</h4>
<p>tcnt0 start from 0x00 to ocr0A, and then clear to be 0x00</p>
<div class="featureList">
<h4>OC0A/OC0B</h4>
<p><span style="color:red">Controlled by ocr0A and ocr0B. COM0A and COM0B's action are independent</span></p>
<ol>
<li>COM0A/B = 0x01: toggle at compare match</li>
<li>COM0A/B = 0x10: clear oc0A/B at compare match</li>
<li>COM0A/B = 0x11: set oc0A/B at compare match</li>
</ol>

</div>
<div class="featureList">
<h4>Interrupts</h4>
<p><span style="color:red">Controlled by ocr0A and ocr0B</span></p>
<ol>
<li>OVF: This interrupt is only possible to be used when ocr0A = 0xff. Otherwise the tcnt can never overflow and this interrupt would never happen.</li>
<li>COMPA: when tcnt0 = ocr0A, it happens when tcnt0 reach the top. If ocr0A = 0xff, then the OVF and COMPA happened at the same time.</li>
<li>COMPB: when tcnt0 = ocr0B. If ocr0B &gt; ocr0A, then this interrupt would never happen.</li>
</ol>
<h4>Examples</h4>
<pre class="brush:cpp">
void initCTC(){
    TCNT0 = 0x00;
    TCCR0A = 0x52; // ctc mode, toggle OC0A and OC0B
    OCR0A = 0xfe; // the top value that is less than 0xff, which means the OVF interrupt can never happen.
    OCR0B = 0x80; // when tcnt reach half, toggle the OC0B
    TIMSK0 = 0x03; //enable compa and ovf even though ovf never happens. For verifying purpose.
    TCCR0B = 0x04; //set the frequency
}
// when PD6 led is toggled, a blinking should happen at the Nano built-in led.
</pre>
<div class="featureList">
<h4>Timing analysis</h4>
<ol>
<li>PWM: OC0A/B changes at compare match. The compare match for OC0A and OC0B may happens at different time but their period are same. P = ocr0A / Ftcnt</li>
<li>Frequency of toggling a pin: <span style="color:red">Ftcnt/2(1+ocr0A)</span></li>
</ol>
</div>
<h4>Note</h4>
<p>Modify ocr0A to a value below current tcnt0 would allows the tcnt0 reach 0xff and then overflow.</p>
<p>duty cycle is always 50%</p>
</div>
</li>
<li>
<h4>Fast PWM (Pulse Width Modulation) Mode, TOP = 0xFF</h4>
<h4>TCNT0</h4>
<p>tcnt0 increments from 0x00 to 0xff and then reset to 0x00</p>
<div class="featureList">
<h4>OC0A/B</h4>
<ol>
<li><span style="color:red">OC0A and OC0B are independent controlled by ocr0A and ocr0B.</span>Their actions happen at compare match (tcnt=orc0A or tcnt=orc0B) or when tcnt = 0xff</li>
<li>Non-inverting mode: oc0A/B clear when tcnt=ocr0A/ocr0B and set when tcnt overflows</li>
<li>Inverting mode: oc0A/B set when tcnt=ocr0A/B and clear when tcnt overflows</li>
</ol>
<p><span style="color:red">Period is fixed but duty cycle is adjustable.</span> To increasing duty cycle, a higher ocr0A/B in non-inverting mode; a lower in inverting mode.
<br>
The period is a single slope period, and it's divied in a middle place specified by the ocr0A/B
</p>
</div>
<div class="featureList">
<h4>Interrupts</h4>
<ol>
<li>OVF: the flag bit is set after the cycle that tcnt = 0xff. (It is like the 9th bit of the 8-bit tcnt register but it is not set)</li>
<li>COMPA: when tcnt0 = ocr0A</li>
<li>COMPB: when tcnt0 = ocr0B</li>
</ol>
</div>
<h4>Diagram</h4>
<p><img src="./img/FastPWMdiagram.png" width="500" height="200"></p>

</li>
<li>
<h4>Fast PWM Mode, TOP = ocr0A</h4>
<h4>TCNT0</h4>
<p>tcnt0 increments from 0x00 to ocr0A, and reset to 0x00</p>
<div class="featureList">
<h4>OC0A</h4>
<ol>
<li>toggle OC0A on compare match (when tcnt = ocr0A, namely, tcnt reach top); Period = 2 slopes. Duty cyle = 50%. Same as CTC mode</li>
<li>Non-inverting mode: oc0A clear when tcnt=ocr0A and set when tcnt is cleared <span style="color:green">Duty cycle is close to 100%</span></li>
<li>Inverting mode: oc0A set when tcnt=ocr0A and cleared when tcnt is cleared <span style="color:green">Duty cycle is close to 0</span></li>
</ol>
<p class="starMark">* Because only one cyle between tcnt=ocr0A and clearing tcnt, it is not very useful</p>
<h4>OC0B</h4>
<ol>
<li>Non-inverting mode: oc0B clear when tcnt=ocr0B and set when tcnt is cleared (after tcnt=ocr0A)</li>
<li>Inverting mode: oc0A set when tcnt=ocr0A and cleared when tcnt is cleared</li>
</ol>
<p class="starMark">* Period and duty cycle adjustable</p>
</div>
<div class="featureList">
<h4>Interrupts</h4>
<ol>
<li>OVF: the flag bit is set after the cycle that tcnt = <span style="color:red">top (no need for 0xff)</span>.</li>
<li>COMPA: when tcnt0 = ocr0A (set at the same cycle with ovf)</li>
<li>COMPB: when tcnt0 = ocr0B</li>
</ol>
</div>
<h4>Examples</h4>
<pre class="brush:cpp">
void initFastPWMorc0A(){
    TCNT0 = 0x00;
    TCCR0A = 0xa3; // non-inverting, fast PWM. oc0A is always up.
    TIMSK0 = 0x07; //enable all interrupts, ovf and compa happen at the same time
    OCR0A = 0xe0; // the top value
    OCR0B = 0x80; // interrupt and 
    TCCR0B = 0x0c; // fast PWM with top = ocr0A, set prescale
}
</pre>
</li>
<li>
<h4>Phase Correct PWM Mode, TOP = 0xFF</h4>
<h4>TCNT0</h4>
<p>tcnt0 increment from 0x00 to 0xff and decrement to 0x00</p>
<div class="featureList">
<h4>OC0A/OC0B</h4>
<p><span style="color:red">Controlled by ocr0A and ocr0B. COM0A and COM0B's action are independent</span></p>
<ol>
<li>non-inverting mode: clear on up-counting match, set on down-counting match</li>
<li>inverting mode: set on up-couting match, clear on down-counting match</li>
</ol>
</div>
</li>
<li>
<h4>Phase Correct PWM Mode, TOP = ocr0A</h4>
<h4>TCNT0</h4>
<p>tcnt0 increment from 0x00 to ocr0A and decrement to 0x00</p>
<div class="featureList">
<p><span style="color:red">Controlled by ocr0A and ocr0B. COM0A and COM0B's action are independent</span></p>
<h4>OC0A</h4>
<ol>
<li>toggle oc0A when tcnt0 = ocr0A. The PWM period is a 4 slope.</li>
<li>non-inverting mode: clear on up-counting match, set on down-counting match (duty cycle = 100%)</li>
<li>inverting mode: set on up-couting match, clear on down-counting match (duty cycle = 0)</li>
</ol>
<h4>OC0B</h4>
<ol>

<li>non-inverting mode: clear on up-counting match, set on down-counting match</li>
<li>inverting mode: set on up-couting match, clear on down-counting match</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
</li>
<li>
<div class="content" id="tcSummary">
<h3>Summary</h3>
<p></p>
<div class="generalTable">
<h4></h4>
<table>
<tr><th>Mode</th><th>Frequency</th><th>Duty Cycle</th></tr>
<tr><td>Normal</td><td>Fixed</td><td>Fixed</td></tr>
<tr><td>CTC OC0A</td><td>Variable</td><td>Fixed *</td></tr>
<tr><td>CTC OC0B</td><td>Variable</td><td>Variable</td></tr>
<tr><td>Fast PWM TOP=0xff</td><td>Fixed</td><td>Variable</td></tr>
<tr><td>Fast PWM TOP=ocr0A, OC0A</td><td>Variable</td><td>Fixed *</td></tr>
<tr><td>Fast PWM TOP=ocr0A, OC0B</td><td>Variable</td><td>Variable</td></tr>
<tr><td>Phase correct PWM TOP=0xff</td><td>Fixed</td><td>Variable</td></tr>
<tr><td>Phase correct PWM TOP=ocr0A, OC0A</td><td>Variable</td><td>Fixed *</td></tr>
<tr><td>Phase correct PWM TOP=ocr0A, OC0B</td><td>Variable</td><td>Variable</td></tr>
</table>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
