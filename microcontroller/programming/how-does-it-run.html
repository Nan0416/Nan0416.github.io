<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Programming&nbsp;How does it run?</title>
<meta charset="utf-8">
<meta name="date" content="2018-01-22">
<meta name="keywords" content="power">
<meta name="keywords" content="atmega328p">
<meta name="keywords" content="microcontroller">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>Programming&nbsp;-&nbsp;How does it run?</strong></center>
</div>
<p class="date"><span class="created-date">Created:2018-01-22</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2018-01-22</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#runIntro">Introduction</a></li>
<li><a href="#runAnalyze">Analyze</a></li>
<li><a href="#runDIY">Modify default reset behavior</a></li>
<li><a href="#powerReferences">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="runIntro">
<h3>Introduction</h3>
<p>This note discusses how would a program run in this device. avr-objdump is used to disassembly the binary code.</p>
</div>
</li>
<li>
<div class="content" id="runAnalyze">
<h3>Analyze</h3>
<p>The program analyzed is very simple, turn on an led.</p>
<p>
    <pre class="brush: cpp">
    #define F_CPU 16000000UL
    #include &lt;avr/io.h>
    void main(){
        DDRB |= 0x20;
        PORTB |= 0x20;
    }
    </pre>
</p>
<p>Compile it to a .elf binary file. Using avr-objdump to disassably the file.</p>
<p><span class="cmd">avr-objdump -S main.elf</span></p>

<div class="asm" style="margin-right:400px;">
<pre>

        main.elf:     file format elf32-avr


        Disassembly of section .text:
        
        00000000 &lt;__vectors>:
           0:	0c 94 34 00 	jmp	0x80	; 0x80 &lt;__init>
           4:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
           8:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
           c:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          10:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          14:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          18:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          1c:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          20:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          24:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          28:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          2c:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          30:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          34:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          38:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          3c:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          40:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          44:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          48:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          4c:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          50:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          54:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          58:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          5c:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          60:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          64:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
        
        00000068 &lt;__ctors_end>:
          68:	11 24       	eor	r1, r1
          6a:	1f be       	out	0x3f, r1	; 63
          6c:	cf ef       	ldi	r28, 0xFF	; 255
          6e:	d8 e0       	ldi	r29, 0x08	; 8 ;; Nan initialize SP
          70:	de bf       	out	0x3e, r29	; 62
          72:	cd bf       	out	0x3d, r28	; 61
          74:	0e 94 43 00 	call	0x86	; 0x86 &lt;main> ;; Nan call main
          78:	0c 94 48 00 	jmp	    0x90	; 0x90 &lt;_exit>
        
        0000007c &lt;__bad_interrupt>:
          7c:	0c 94 00 00 	jmp	0	; 0x0 &lt;__vectors>
        
        00000080 &lt;__init>:
          80:	84 b1       	in	r24, 0x04	; 4
          82:	84 b9       	out	0x04, r24	; 4
          84:	08 95       	ret

        00000086 &lt;main>:
          86:	25 9a       	sbi	0x04, 5	; 4
          88:	2d 9a       	sbi	0x05, 5	; 5
          8a:	80 e0       	ldi	r24, 0x00	; 0
          8c:	90 e0       	ldi	r25, 0x00	; 0
          8e:	08 95       	ret
              
        00000090 &lt;_exit>:
          90:	f8 94       	cli
              
        00000092 &lt;__stop_program>:
          92:	ff cf       	rjmp	.-2      	; 0x92 &lt;__stop_program>
        
</pre>
</div>
<p>This the code that is going to be downloaded to the flash memory at specific address. For example, the __vectors section would be placed at the starting address. This section defines the interrupt vectors.
The first vector is defined as reset vector, it has a handler that at 0x68 __ctors_end. After reset, the PC's value is reset to 0x00. This is why the reset handler is run first.
</p>
<p>The reset hanlder initialize the SP pointer, and put SP address to Y pointer. Finally, it calls the user's main function.</p>
<p>Through the __bad_interrupt handler, we know that if an interrupt hanlder is not defined but it is enabled and triggered, the program will be (software) reset. Therefore, even thought the
    hardware reset value of SP is just the top of SRAM, we still need set its initial value because the reset handler can be re-entered by non power-on action. 
</p>
<p>After the main returns, the processor jumps to _exit to call cli, which will disable all interrupt.</p>
<p>And then continue goes to rjmp .-2 in __stop_program, which again goes back to _exit. So finally the program ends with a infinite loop that disable interrupt.</p>
</div>
</li>
<li>
<div class="content" id="runDIY">
<h3>Modify default reset behavior</h3>
<p>The C program only defines the basic main function, other codes such as __bad_interrupt, _ctors_end are provided by avr toolchains and bind together by avr-ld linker. In order to use a new reset handler, either a new linker script is required or 
the provided __ctors_end has to be modified.
</p>
<p>However, the avr-ld linker leaves an opportunity to customize the default reset handler. Define a void __init() function would change the behavior of linker to use this function as the reset hanlder.</p>
<pre class="brush: cpp">
#define F_CPU 16000000UL
#include &lt;avr/io.h>
void __init(){
	DDRB|=0x00;
}
int main(){
	DDRB |= 0x20;
	PORTB |= 0x20;
	return 0;
}
</pre>
<p><span class="cmd">avr-objdump -S main.elf</span></p>

<div class="asm" style="margin-right:400px;">
<pre>

        main.elf:     file format elf32-avr


        Disassembly of section .text:
        
        00000000 &lt;__vectors>:
           0:	0c 94 34 00 	jmp	0x68	; 0x68 &lt;__ctors_end>
           4:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
           8:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
           c:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          10:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          14:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          18:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          1c:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          20:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          24:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          28:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          2c:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          30:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          34:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          38:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          3c:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          40:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          44:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          48:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          4c:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          50:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          54:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          58:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          5c:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          60:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
          64:	0c 94 3e 00 	jmp	0x7c	; 0x7c &lt;__bad_interrupt>
        
        00000068 &lt;__ctors_end>:
          68:	11 24       	eor	r1, r1
          6a:	1f be       	out	0x3f, r1	; 63
          6c:	cf ef       	ldi	r28, 0xFF	; 255
          6e:	d8 e0       	ldi	r29, 0x08	; 8 ;; Nan initialize SP
          70:	de bf       	out	0x3e, r29	; 62
          72:	cd bf       	out	0x3d, r28	; 61
          74:	0e 94 40 00 	call	0x80	; 0x80 &lt;main> ;; Nan call main
          78:	0c 94 43 00 	jmp	0x86	; 0x86 &lt;_exit>
        
        0000007c &lt;__bad_interrupt>:
          7c:	0c 94 00 00 	jmp	0	; 0x0 &lt;__vectors>
        
        00000080 &lt;main>:
          80:	25 9a       	sbi	0x04, 5	; 4
          82:	2d 9a       	sbi	0x05, 5	; 5
          84:	08 95       	ret
        
        00000086 &lt;_exit>:
          86:	f8 94       	cli
        
        00000088 &lt;__stop_program>:
          88:	ff cf       	rjmp	.-2      	; 0x88 &lt;__stop_program> ;; Nan an infinit loop
        
</pre>
<p>The _ctors_end is still there, but it uses the __init as the reset handler.</p>
</div>

</div>
</li>
<li>
<div class="content" id="runReference">
<h3>Reference</h3>
<div class="featureList">
<ol>
<li><a href="http://www.nongnu.org/avr-libc/user-manual/mem_sections.html#sec_dot_text" target="_blank">AVR reference Memory section</a></li>
</ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
