<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Interrupt&nbsp;System</title>
<meta name="date" content="2017-12-29">
<meta name="keywords" content="interrupt">
<meta name="keywords" content="atmega328p">
<meta name="keywords" content="microcontroller">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">

<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>Interrupt&nbsp;-&nbsp;Introduction</strong></center>
</div>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#interruptConcept">Interrupt concepts</a></li>
<li><a href="#interruptAtmega328p">Interrupt in Atmega328p</a></li>
<li><a href="#interruptExperiments">Experiments</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="interruptConcept">
<h3>Interrupt concepts</h3>
<p>Microcontroller's interrupts are usually hardware interrupts. The interrupt sources include external voltage change, timer/counter, peripheral ready, and reset.
The interrupt system allows to use an event-driven programming style.
</p>

<div class="featureList">
<h4>Enable/Disable</h4>
<p>To enable any interrupt, the global interrupt bit, SREG.I, must be set (SREG |= 0x80). It can only be set by software.</p>
<ol>
<li>The SEI instruction is dedicated to enable the globle interrupt. #include&lt;avr/interrupt.h&gt; sei(); in C.</li>
<li>The RETI instruction is a return instruction that is used to return from interrupt routine, it can also re-enable the interrupt.</li>
</ol>
</div>
<p>Disabling the interrupt would be done by hardware automatically, or can be achieved by software.</p>
<div class="featureList">
<ol>
<li>Software: CLI instruction is used to clear the global interrupt bit. #include&lt;avr/interrupt.h&gt; cli(); in C.</li>
<li>Hardware: this bit is automatically cleared when entering an interrupt routine. Then enabling this bit in an interrupt routine may result in the nested interrupt.</li>
</ol>
</div>

<div class="featureList">
<h4>Interrupt working flow:</h4>
<ol>
<li>when an interrupt event happens, it sets the Interrupt Flag Bit of the device specific status register.</li>
<li>Check if the Interrupt Enabled bit is also set.</li>
<li>It may generate the Interrupt Request, and do AND with the global interrupt bit.
<p><img src="./img/interruptStructure.png" width="730" height="130"></p>
<p class="starMark">* The ISR request is wired to the pre-defined interrupt vector, so software cannot modify it.</p>
</li>
<li>CPU check if an interrupt occurs in the end of every CPU cycle. If yes, it implements a series of instructions and jmp to the ISR immediately after the execution of the 
current instruction. The trap process takes at least 4 clock cycle, push PC, disable interrupt, jmp to the interrupt vector, jmp to the interrupt service routine. If the current executed instruction
is a multi-cycle instruction, the trap takes more time.
<p class="starMark">* The switching to interrupt routine does not save the status register, developers may store and recover it inside the ISR's begining and ending.</p></li>
</ol>
</div>
<div class="featureList">
<h4>Interrupt types</h4>
<ol>
<li><span style="font-weight:bold;">Trigger by events</span>: This type of interrupt is stateful, which means the interrupt occuring is remembered by the system. Even if the interrupt event
disappeared when the CPU checks it, the ISR still can be triggered. The event is record in the interrupt flag bit. (e.g. External interrupt's logic change event). <mark>Writing 1 to flag bit actually clears this bit not set.</mark></li>
<li><span style="font-weight:bold;">Trigger by interrupt conditions</span>: This type of interrupt is stateless, which means the ISR would not be executed if the interrupt event disappeared when CPU check it.
(e.g. External interrupt's low level event)</li>
<li><span style="font-weight:bold">Software interrupt</span>: External interrupt can be triggered by software when modifying the port's value. This also triggers the interrupt routine.</li>
</ol>
</div>
<div class="termnology">
<h4>Terms</h4>
<ul>
<li>Interrupt vector: An interrupt vector stores an address that points to the interrupt service routine.</li>
<li>Interrupt vector table: A table that stores interrupt vectors.</li>
<li>Interrupt service routine: A function that is executed when the corresponding interrupt happens.</li>
</ul>
</div>
</li>
<li>
<div class="content" id="interruptAtmega328p">
<h3>Interrupt in Atmega328p</h3>
<p>Atmega328p has 26 interrupt vectors. They are stored in either boot space or the application space. Both spaces are located in the 32Kbytes flash memory. The size of boot section and application section is
adjustable by changing the BOOTSZ fuse bits. The boot section occupies the high address space, and the application section occupies the low address space.
 The interrupt vectors can be placed in either sections by modifying the MCU Control Register MCUCR.IVSEL and MCUCR.IVCE. To avoid unintentionally changing the interrupt vectors, special write sequence is required.</p>
<div class="featureList">
<h4>Change interrupt vectors location</h4>
<ol>
<li>Write the Interrupt Vector Change Enable (IVCE) bit to 1. MCUCR |= 0x01</li>
<li>Within 4 cycles, write the desired value of IVSEL while writing a zero to IVCE. MCUCR |= 0b000000y0 (y=0 in the beginning of application section, =1 in the beginning of boot loader section)</li>
</ol>
<p class="starMark">* Interrupts is automatically disabled during this process and re-enable after changing the two bits. The disabling does not affect the global interrupt enable bit.</p>
</div>
<p><span style="font-weight:bold;">Reset and interrupt priorities</span>: the prority is determined by the interrupt vector's address. A lower address interrupt has higher prority, which means the lower address interrupt routine would be executed 
when two or more interrupt happened at the same time. Because Reset always has the lowest address, it always has the highest priority. Becuase the flash memory is 32KB, the address space is 15 bits long. Therefore, each address is 2 bytes. Then each interrupt
vector would occupy 2 bytes or 1 word.</p>
<div class="generalTable">
<table>
<tr><th>Vector No</th><th>Vector Address</th><th>Source</th><th>Meaning</th></tr>
<tr><td>1</td><td>0x0000</td><td>Reset</td><td>4 reset source: external pin, power-on, watchdog and BOD</td></tr>
<tr><td>2</td><td>0x0002</td><td></td><td></td></tr>
<tr><td>7</td><td>0x000C</td><td>WDT</td><td>Watchdog time-out interrupt</td></tr>
</table>
<p class="starMark">* The vector address should be added an offset, the boot section start address, if the interrupt vectors is placed in boot section.</p>
</div>

</div>
</li>
<li>
<div class="content" id="interruptExperiments">
<h3>Experiments</h3>
<div class="featureList">
<ol>
<li>
<p>Nested interrupt</p>
<p><span styple="font-weight:bold">Design</span>: Configure the external INT0 (PD2) and INT1 (PD3) as rising edge triggering. The routine of INT0 blinks the on-board LED for 30 times. Initial frequency is 6s.
 The routine of INT1 decrement the blinking duration by 1 and blinks the same led at a high speed for once.</p>

<pre class="brush: cpp">
        #define F_CPU 16000000UL
        #include &lt;avr/interrupt.h&gt;
        #include &lt;util/delay.h&gt;
        #include &lt;avr/io.h&gt;
        
        void delay_ms(int time){
            int i =0 ;
            for(; i < time; i++){
                _delay_ms(1);
            }
        }
        volatile int time = 2000;
        void on_board_led(const int time){
            PORTB |= 0x10;
            delay_ms(time);
            PORTB &= ~0x10;
            delay_ms(time);
        }
        ISR(INT0_vect, ISR_NOBLOCK){
            int i = 0;
            for(; i < 100; i++){
                on_board_led(time);
                EIFR |= 0x01;
            }
        }
        ISR(INT1_vect){
            on_board_led(50);
            on_board_led(50);
            EIFR |= 0x02;
            time = time >> 1;
            if(time < 50){
                time = 2000;
            }
        }
        int main(){
            DDRB |= 0x10;
            DDRD &= ~0x0C; // INT0/INT1 pins PD2/3 output
            EICRA |= 0x0f; // INT0 rising edge 
            EIMSK |= 0x03; // enable INT0 interrupt
            sei(); // enable global interrupt
            _delay_ms(1000); // delay 1000ms
            while(1);
        }
</pre>
<p>Connection</p>
<p><img src="./img/interrupt1.jpg" width="500" height="350"></p>
</li>
</ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
