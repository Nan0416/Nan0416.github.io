<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Power&nbsp;Management</title>
<meta name="date" content="2017-12-28">
<meta name="keywords" content="power">
<meta name="keywords" content="atmega328p">
<meta name="keywords" content="microcontroller">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>

<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>

<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>System&nbsp;-&nbsp;Power&nbsp;management</strong></center>
</div>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#powerIntro">Power management</a></li>
<li><a href="#powerOperation">Sleep and wakeup operation</a></li>
<li><a href="#powerSleepModeWakeupSource">Sleep mode and wake up source in Atmega328p</a></li>

<li><a href="#powerAVRSleepLib">AVR Sleep Library</a></li>
<li><a href="#powerReferences">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="powerIntro">
<h3>MCU power management</h3>
<p>Atmega328P-PU employees a 5 volt power input, it can also be powered by a 9V battery by using a voltage regulator. A 1200 mAh 9 volt battery even cannot support an Arduino Uno for one day because
it uses about 45 mA current [1]. </p>
</div>
</li>
<li>
<div class="content" id="powerOperation">
<h3>Sleep and wakeup operation</h3>
<p>Sleep modes can disable unused modules in the MCU to save power. Differen sleep modes disable different modules. The Atmega328p provides
6 sleeps mode. The control flow that involves sleep mode is normal mode -> (sleep) -> sleep mode -> (wake up) -> normal mode. To make a MCU enter sleep mode, </p>
<div class="featureList">
<ol>
<li>select the sleep mode by using SM[2:0]</li>
<li>SMCR |= 0x80: set the Sleep Mode Control Register (SMCR)'s Sleep enable to 1</li>
<li>call a SLEEP instruction to make the MCU go to sleep. #include &lt;avr/sleep.h&gt; sleep_cpu();</li>
</ol>
</div>
<p>To wake up a sleep, an interrupt or reset is required. When the interrupt comes in, the MCU goes to the interrupt routine and returns to the immediately after the SLEEP instruction that cause the MCU sleep.
The waking up process takes 4 cycles + star-up time (set by SUT fuse bits) + executes the interrupt routine to go back.
</p>
<p>The wake up condition is usually set before writing SMCR. Wake up sources can be external interrupts, timers, Watch dog and so on. The 
following picture shows different sleep modes and wake-up sources.[2]
</p>
<p><img src="./img/sleepMode.png" width="780" height="180"></p>

</div>
</li>
<li>
<div class="content" id="powerSleepModeWakeupSource">
<h3>Sleep mode</h3>
<div class="featureList">
<h4>Sleep mode</h4>
<ol>
<li>
<p>Power down: All clock is halted, which means CPU core and all periheral devices that require the clock signal cannot work. Only the external interrupt can work. So the external interrupt, 
external reset, BOD reset, watchdog reset, watchdog interrupt and TWI address match can wake up the MCU.
</p>
<p class="starMark">* Because clock sources stop working, <mark>only the low level interrupt</mark> is allowed to use.</p>
<p class="starMark">* When using a low level triggered external interrupt, the low level must hold for a while until the MCU completely waked up.</p>
</li>
<li>Stanby mode: can be enabled if the clock source is an external crystal/resonator clock. This mode is same as power down except the clk-sys (the external clock) is still working. This allowed a fast wakeup process (6 clock cycles).</li>
<li><p>Power save:Same as power down, but the Timer/Counter2 keeps running if it is enabled. Because timer/counter2 can use either synchronous clock or asynchronous clock (TOSC1), one of these clock source should keep working 
when selected.</p></li>
<li>Extended stanby mode: can be enabled if the clock source is an external crystal/resonator clock. This mode is same as power save except the clk-sys (the external clock) is still working. This allowed a fast wakeup process (6 clock cycles).</li>
<li>ADC Noise reduction: CPU, memory, peripheral devices that require clock sources except ADC stop working. In other words, clk-cpu, clk-flash, clk-io is halted. ADC and asynchoronus timer/counter2 can continue to work.</li>
<li>idle: Only CPU core and memory stop working. All other peripheral devices keep working. Optionally, the analog comparator (clk-adc) can be stopped.</li>
</ol>
</div>
<div class="featureList">
<h4>Futher exploring</h4>
<p>Modules run in all sleep mode: BOD, ADC, Watchdog timer and on-chip debug system. To stop some of them in sleep mode, it would save power. The Power Reduction Register (PRR) provides a method to stop the clock to individual peripherals. Usually, the individual periheral device
should be disable before shutting down the clock.
</p>
<ol>
<li>
<p>BOD disable: BOD can be software disabled during sleep if it is enabled by fuse bit. Set MCUCR.BODS = 1 will disable it immediately after entering the sleep mode. It will automatically re-enable after wakeup.
If BOD is disabled, the wakeup take an extra approximate 60us to ensure the BOD is working correctly (e.g. like the time-out delay).</p>
<p class="starMark">* This feature is only avaliable for atmega328p.</p>
</li>
<li>ADC disable:....</li>
<li>Watchdog timer disable: ....</li>
<li>On-chip debug system: fuse bit....</li>
</ol>
</div>
<p>The following picture show the PRR register.[2]</p>
<p><img src="./img/PRR.png" width="750" height="700"></p>
</div>
</li>
<li>
<div class="content" id="powerAVRSleepLib">
<h3>AVR Sleep Library</h3>
<p>AVR sleep library #include &lt;avr/sleep.h&gt; defines a set of macros used to control the AVR microcontroller's sleep mode. This library is compatible with all 
AVR microcontrollers, but only Atmega328p related sleep functions are introduced in this section.
</p>
<div class="featureList">
<p><a href="./sleep.h">Source code.</a></p>
<ol>
<li><p>Set sleep mode</p>
<pre class="brush: cpp">
    //#include &lt;avr/sleep.h&gt;
    #define _SLEEP_CONTROL_REG  SMCR
    #define _SLEEP_ENABLE_MASK  _BV(SE)
    #define set_sleep_mode(mode) \
    do { \
        _SLEEP_CONTROL_REG = ((_SLEEP_CONTROL_REG & ~(_BV(SM0) | _BV(SM1) | _BV(SM2))) | (mode)); \
    } while(0)

    //#include &lt;avr/io.h&gt;
    #define SLEEP_MODE_IDLE (0x00<<1)
    #define SLEEP_MODE_ADC (0x01<<1)
    #define SLEEP_MODE_PWR_DOWN (0x02<<1)
    #define SLEEP_MODE_PWR_SAVE (0x03<<1)
    #define SLEEP_MODE_STANDBY (0x06<<1)
    #define SLEEP_MODE_EXT_STANDBY (0x07<<1)        
</pre>
</li>
<li>
<p>Sleep enable</p>
<pre class="brush: cpp">
    // Set the SMCR.SE = 1
    #define sleep_enable()             \
    do {                               \
        _SLEEP_CONTROL_REG |= (uint8_t)_SLEEP_ENABLE_MASK;   \
    } while(0)
</pre>
</li>
<li>
<p>Sleep disable</p>
<pre class="brush: cpp">
    // Set the SMCR.SE = 0
    #define sleep_enable()             \
    do {                               \
        _SLEEP_CONTROL_REG |= (uint8_t)_SLEEP_ENABLE_MASK;   \
    } while(0)
</pre>
</li>
<li>
<p>Call Sleep instruction</p>
<pre class="brush: cpp">
    // call sleep instruction, go to sleep
    #define sleep_cpu()                              \
    do {                                             \
        __asm__ __volatile__ ( "sleep" "\n\t" :: );    \
    } while(0)
</pre>
</li>
<li>
<p>Disable BOD during sleep</p>
<pre class="brush: cpp">
    #define BOD_CONTROL_REG MCUCR
    #define sleep_bod_disable() \
    do { \
      uint8_t tempreg; \
      __asm__ __volatile__("in %[tempreg], %[mcucr]" "\n\t" \
                           "ori %[tempreg], %[bods_bodse]" "\n\t" \
                           "out %[mcucr], %[tempreg]" "\n\t" \
                           "andi %[tempreg], %[not_bodse]" "\n\t" \
                           "out %[mcucr], %[tempreg]" \
                            : [tempreg] "=&d" (tempreg) \
                            : [mcucr] "I" _SFR_IO_ADDR(BOD_CONTROL_REG), \
                             [bods_bodse] "i" (_BV(BODS) | _BV(BODSE)), \
                             [not_bodse] "i" (~_BV(BODSE))); \
    } while (0)    
</pre>
</li>
</li>
<li>
<p>Sleep helper function</p>
<pre class="brush: cpp">
    #define sleep_mode() \
    do {                 \
        sleep_enable();  \
        sleep_cpu();     \
        sleep_disable(); \
    } while (0)
</pre>
</li>

</ol>
<p>The following C code show an example of power down mode that is woken up by the external interrupt 0. <a href="./powerDownExample.c">Source code</a></p>
<pre class="brush: cpp">
    #define F_CPU 16000000UL
    #include &lt;avr/interrupt.h>
    #include &lt;util/delay.h>
    #include &lt;avr/io.h>
    #include &lt;avr/sleep.h>

    void powerDown(void)
    {
        set_sleep_mode(SLEEP_MODE_PWR_DOWN);
        sleep_mode();
    }
    void on_board_led(){
        PORTB |= 0x20;
        _delay_ms(1000);
        PORTB &= ~0x20;
        
    }
    ISR(INT0_vect){
        
    }
    int main(){
        
        DDRB |= 0x20;
        DDRD &= ~0x04; // INT0 pins PD2 output
        EICRA &= ~0x03; // INT0 level low trigger
        EIMSK |= 0x01; // enable INT0 interrupt
        sei(); // enable global interrupt
        while(1){
            powerDown();
            on_board_led();
        }
    }

</pre>
</div>
</div>
</li>
<li>
<div class="content" id="powerReferences">
<h3>References</h3>
<div class="featureList">
<ol>
<li><a href="http://www.home-automation-community.com/arduino-low-power-how-to-run-atmega328p-for-a-year-on-coin-cell-battery/" target="_blank">Arduino mini pro saving power case study</a></li>
<li>Atmega328p datasheet page 62 and page 71.</li>
<li><a href="https://github.com/vancegroup-mirrors/avr-libc/blob/master/avr-libc/include/avr/sleep.h" target="_blank">AVR Sleep library.</a></li>
</ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
