<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Watchdog</title>
<meta charset="utf-8">
<meta name="date" content="2017-12-31">
<meta name="keywords" content="watchdog">
<meta name="keywords" content="atmega328p">
<meta name="keywords" content="microcontroller">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>


<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>System&nbsp;-&nbsp;Watchdog</strong></center>
</div>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#watchdogIntro">Introduction to watchdog</a></li>
<li><a href="#watchdogWorkingMode">Watchdog working mode</a></li>
<li><a href="#watchdogRegister">System registers description</a></li>
<li><a href="#watchdogExamples">Watchdog examples</a></li>
<li><a href="#watchdogReferences">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="watchdogIntro">
<h3>Introduction to watchdog</h3>
<p>Watchdog is an independent timer module that uses an independent clock source. It can reset or interrupt the MCU. The watchdog is useful to avoid unknown bugs. Suppose the program goes to an infinite loop, it can clear the 
watchdog's timer value, then the system can be reset. 
</p>
<p>The watchdog in Atmega328p can works in 3 different mode, interrupt, system reset, interrupt and system reset. It is clocked by the internal 128KHz oscillator. If the watchdog timer is enabled, it would work in all sleep mode, and 
consume a significant part of power. So disabling this module when it is unnecessary. The working mode and en/disable is controlled by a fuse bit (High fuse bit.WDTON) and the Watchdog Timer Control Register (WDTCSR). The following picture shows 
the selection of different modes [1].
</p>
<p><img src="./img/watchdogWorkingMode.png" width="680" height="180"></p>

</div>
</li>
<li>
<div class="content" id="watchdogWorkingMode">
<h3>Watchdog working mode</h3>
<div class="featureList">
<ol>
<li>
<p><span style="font-weight:bold">Watchdog interrupt</span>: When the WDTON fuse bit is 1 (unprogrammed), WDE = 0 and WDIE = 1, the watchdog timer interrupt is enabled. The timer interrupt can be used to wakeup the MCU from sleep mode. The
timer uses the internal 128KHz oscillator, and the overflow value is 2^11 = 2K. Each cycle takes 1/128K. So the shortest overflow time is 2K * 1/128K = 1/64 = 0.015625ms â‰ˆ 16ms.</p>
<p>The clock source can be prescaled according to following table [2]. This is also true for other two modes.</p>
<p><img src="./img/watchdogTimer.png" width="680" height="450"></p>
</li>
<p><span style="font-weight:bold">Watchdog reset</span>: Watchdog timer expiration will reset the MCU. Go to the reset handler </p>
</ol>
</div>
</div>
</li>
<li>
<div class="content" id="watchdogRegister">
<h3>Relavent registers and fuse bits</h3>
<div class="register">
<h4>High fuse byte</h4>
<table>
<tr><th>No.</th><th>Name</th><th>Meaning</th><th>Default value</th></tr>
<tr><td>4</td><td>WDTON</td><td>Watchdog timer is always on and works in reset mode</td><td>1</td></tr>
</table>
</div>
<div class="register">
<h4>MCU Status Register</h4>
<table>
<tr><th>No.</th><th>Name</th><th>Meaning</th><th>Default value</th></tr>
<tr><td>3</td><td>WDRF</td><td>Watchdog System Reset Flag: This bit is set if a watchfog system reset occurs. The reset routine can use this bit to detect which reset source causes the reset.</td><td>0</td></tr>
</table>
</div>
<div class="register">

<h4>Watchdog Timer Control Register (WDTCSR)</h4>
<table>
<tr><th>No.</th><th>Name</th><th>Meaning</th><th>Default value</th></tr>
<tr><td>7</td><td>WDIF</td><td>Watchdog interrupt flag, set and clear by hardware, writing 1 to clear</td><td>0</td></tr>
<tr><td>6</td><td>WDIE</td><td>Watchdog interrupt enable</td><td>0</td></tr>
<tr><td>5</td><td>WDP3</td><td>Watchdog Timer Prescaler 3</td><td>0</td></tr>
<tr><td>4</td><td>WDCE</td><td>Watchdog change enable: set WDCE and WDE to 1 before modifying WDE and WDPn. It would be reset to 0 by hardware after 4 cycles.</td><td>0</td></tr>
<tr><td>3</td><td>WDE</td><td>Watchdog <mark>System Reset Enable</mark>:it enable the reset mode. This bit is set by hardware immediately after software set the MCUSR.WDRF.</td><td>0</td></tr>
<tr><td>2</td><td>WDP2</td><td>Watchdog Timer Prescaler 2</td><td>0</td></tr>
<tr><td>1</td><td>WDP1</td><td>Watchdog Timer Prescaler 1</td><td>0</td></tr>
<tr><td>0</td><td>WDP0</td><td>Watchdog Timer Prescaler 0: WDP[3:0] selects the prescaler according to the above figure.</td><td>0</td></tr>
</table>
<p>Modifying WDTCSR. 1). set WDE and WDCE to 1 together. 2) set WDCE = 0, and other bits <mark>together</mark> within 4 cycles.</p>
</div>
</div>
</li>
<li>
<div class="content" id="watchdogExamples">
<h3>Watchdog example</h3>
<ol>
<li>
<p>Working in interrupt mode and wake up the powerdown MCU every 8s, then blink the led. <a href="./watchdogExample.c">Source code</a></p>
<p>Arduino high fuse bytes is 0xde, so the WDTON is 1 unprogrammed. Then just modify the WDE, WDIE and WDPn bits.</p>
<pre class="brush: cpp">
#define F_CPU 16000000UL
#include &lt;avr/interrupt.h>
#include &lt;util/delay.h>
#include &lt;avr/io.h>
#include &lt;avr/sleep.h>
#include &lt;avr/wdt.h>
//#define wdt_reset() __asm__ __volatile__ ("wdr")
#define powerDown() do {\
	set_sleep_mode(SLEEP_MODE_PWR_DOWN);\
	sleep_mode();\
	}while(0);
	
void on_board_led(){
	PORTB |= 0x20;
	_delay_ms(1000);
	PORTB &= ~0x20;
	
}
ISR(WDT_vect){
	 // not necessary but safe
	 wdt_reset();
}
int main(){
	
	DDRB |= 0x20;
	uint8_t temp = (_BV(WDIE) | _BV(WDP3) | _BV(WDP0));
	
	WDTCSR |= (_BV(WDCE) | _BV(WDE)); // enable modification
	WDTCSR = temp; // enable interrupt and set prescale in one instruction
	
	if(WDTCSR == temp){
		//correct
		on_board_led();
	}
	sei(); // enable global interrupt
	while(1){
		powerDown();
		on_board_led();
	}
}
</pre>
</li>
</ol>
</div>
</li>
<li>
<div class="content" id="watchdogReferences">
<h3>References</h3>
<div class="featureList">
<ol>
<li>
Atmega328p datasheet page 80.
</li>
</ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
