<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Communication&nbsp;I2C (TWI)</title>
<meta charset="utf-8">
<meta name="date" content="2018-01-28">
<meta name="keywords" content="i2c">
<meta name="keywords" content="atmega328p">
<meta name="keywords" content="twi">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>Communication&nbsp;-&nbsp;I2C&nbsp;(TWI)</strong></center>
</div>
<p class="date"><span class="created-date">Created:2018-01-28</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2018-01-28</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#i2cIntro">Introduction</a></li>
<li><a href="#i2cAVR">I2C in Atmega328p</a></li>
<li><a href="#i2cReferences">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="i2cIntro">
<h3>Introduction</h3>
<p>i2c is 2 wire synchronous serial half-duplex master-slave comminucation protocol invented by Philips Semiconductor. TWI is a Atmel technology that compatible with i2c.</p>
<div class="termonology">
<h4>Two wires</h4>
<ul>
<li>SDA (data line): bi-directional, pull-up register</li>
<li>SCL (clock line): bi-directional, pull-up register</li>
</ul>
</div>
<p>No slave select line, slave is select based on address.<br> Tread-off: slave has to pre-configure an address, and usually this address is fixed, which means a i2c cannot support two same devices, e.g. two temperature sensors</p>
<h4>Pull-up register</h4>
<p>All of the devices are tri-state generates high. Any of the devices is low level would generates low.<br>
    SDA &amp; SCL states:  high: devices are either input or output high ;low: one of them output low.
</p>
<h4>Transfer protocol</h4>
<p>Master generates clock signal. Slave can delay SCL by pull SCL low (output 0)</p>
<div class="featureList">
<ol>
<li>start condition: change data line from high to low when clock is high.</li>
<li>Repeated start condition: change data line from high to low when clock is high after a start condition but before a stop condition.</li>
<li>stop condition: change data line from low to high when clock is high.</li>
<li>data bit: data bit should stable when clock is high ( sample not on edge, but on level)</li>
</ol>
</div>
<p>
<span style="color: red">Why data bit is set when SCL is high, instead of low or a edge?</span><br>
    This is a smart design because the SCL is open-drain, any device, including slaves, can set this SCL low. By setting SCL low, it means the communication (data transfer) is prolonged, so the slave can earn more time to processing. 
</p>
<h4>Repeated start</h4>
<p>During one transaction, a start condition is invoked. And followed by slave address and then data, finally, a stop condition. So one transaction only allowes to communicate with a single slave. But the master can directly issue a 
    new start condition and without stop condition (since stop condtion would relinquish this bus, and the master may not expect that). In this case, the bus is always considered as busy, other masters cannot use this bus. Then current master can issue a new SLA to communicate with another slave. </p>
<p>There can be several repeated start, but only one stop is needed.</p>
<h4>Address format</h4>
<p>Address format composes of 9 bits. <span style="color:orange">7 bit address (SLA) + 1 bit indicate operation (w/r)</span> + <span style="color:green">1 bit ACK</span>. The SLA and w/r are generated by master, ACK is generate by slave.</p>
<p class="starMark">* The time for one bit can be different. For example, the slave may delay ACK by pull-up the SCL. During SCL is low, the i2c's SDA is static.</p>
<p><img src="./img/i2c.png" width="600" height="180"></p>
<p>ACK 0 means agree, 1 means deny</p>
<p>0000 000 is reserved for a general call, broadcast. Only write mode is meaningful; 1111 xxx is reserved for future purpose.</p>
<h4>Data format</h4>
<p>Data format also composes of 9 bits. <span style="color:blue">8 bit data (generated by transmitter)</span> and <span style="color:brown">1 bit ack (generated by receiver)</span></p>
<h4>Lost Arbitration (失去对SDA or SCL的控制)</h4>
<p>I2C support multi-master. When master transmits data, it also listens to SDA and SCL to check whether the values on these two lines are they expect. Because low level always wins, a master lost arbitration if it can't get a certain line to go high. And it needs to back off and wait until a stop condition is seen before making another attempt to start transmitting.</p>

</div>
</li>
<li>
<div class="content" id="i2cAVR">
<h3>I2C in Atmega328p</h3>
<p>Atmega328p has one i2c (TWI) interface. Atmega328p has built-in pull-up registers (30Kohm) in each pin.</p>
<div class="featureList">
<ol>
<li>SCL: PC5 (A5 in Nano)</li>
<li>SDA: PC4 (A4 in Nano)</li>
</ol>
</div>
<p><img src="./img/i2cDiagram.png" width="500" height="500"></p>
<p>It only has 6 registers to control these units.</p>
<h4>Programming model</h4>
<p>In low level, AVR's I2C is suitable for the interrupt driven programming. Events that can trigger an interrupt includes</p>
<div class="featureList">
<ol>
<li>sent the start condition (master) (0x08)</li>
<li>sent the repeated start condition (master) (0x10)</li>
<li>sent the SLA + W and recevied ACK (master) (0x18)</li>
<li>sent the SLA + R and recevied ACK (master) (0x40)</li>
<li>sent the SLA + W and recevied NACK (master) (0x20)</li>
<li>sent the SLA + R and recevied NACK (master) (0x48)</li>
<li>Arbitration lost in SLA + W or data bytes (master transmitter) (0x38)</li>
<li>sent data and recevied ACK (master transmitter) (0x28)</li>
<li>sent data and recevied NACK (master transmitter) (0x30)</li>
<li>received data and returned ACK (master receiver) (0x50)</li>
<li>received data and returned NACK (master receiver) (0x58)</li>
<li>Arbitration lost in SLA + R or NACK (master transmitter) (0x38) // NACK is 1</li>
<li>address matched, master W and return ACK (slave receiver) (0x60)</li>
<li>address matched, master R and return ACK (slave transmitter) (0xA8)</li>

</ol>
<p>In the interrupt handlers, using switch to deal with each state.</p>
</div>
<h4>Dealing with arbitration</h4>
<p>Arbitration can only be lost when transmitting a 1 (high)</p>
<p>After a master lost arbitration, it can either go to wait until the bus is free and retransmit a start condition (set TWSTA), or go to slave mode to listen calling (clear TWSTA).</p>
<div class="featureList">
<h4>Code</h4>
<p style="color:red">Because this is an interrupt driven programming, don't forget enable global interrupt. sei();</p>
<ol>
<li>
<p>Pin configuration</p>
<pre class="brush: cpp">
// enable built-in pull-up register
DDRC &amp;= ~(_BV(PC5) | _BV(PC4)); 
PORTC |= _BV(PC5) | _BV(PC4);
</pre>
</li>
</ol>
</div>
</div>

</li>
</ol>
</div>
    
</body>
</html>
