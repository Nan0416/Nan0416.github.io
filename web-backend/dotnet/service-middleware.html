<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<title>ASP.NET Core&nbsp;-&nbsp;Service & Middleware</title>
<meta charset="utf-8">
<meta name="date" content="2019-04-01">
<meta name="keywords" content="asp.net">
<meta name="keywords" content="service">
<meta name="keywords" content="middleware">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJava.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushJScript.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushBash.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />

<script src="https://d3js.org/d3.v4.min.js"></script>

</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<strong>ASP.NET Core&nbsp;-&nbsp;Service & Middleware</strong>
</div>
<p class="date"><span class="created-date">Created:2019-04-01</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2019-04-01</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#service">Services & Dependency Injection</a></li>

<li><a href="#middleware">Middleware</a></li>
<li><a href="#lifetime">Service lifetime</a></li>
<li><a href="#reference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="service">
<h3>Services & Dependency Injection</h3>
<p>Logger, Configuration are services.</p>
<p>When initializing the default host, it creates a default service container called IServiceProvider and registers several framework-provided services.</p>
<h4>Service Abstraction</h4>
<p>A service is abstracted as an interface, and interface name is given to class's constructors.<br>
<span style="color:red">A service = (interface + service providers); concrete implementation of a service = a service provider.</span></p>

<div class="featureList">
    <h4><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2#framework-provided-services" target="_blank">Framework-provided services</a></h4>
    <p>including ILogger&lt;T>, IHostEnvironment, IConfiguration ...</p>
    <ol>
        <li>When creating the default host "CreateDefaultBuilder(args)", it includes three Logging providers, Console, Debug and EventSource.<br>
            Developer defines a Startup class that either follow's convention or implement the IStartup interface.<br>
            1). IStartup: If asp.net detected the implementation of IStartup, it will register the (IStartup, Startup) pair to the service container.<br>
            2). <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup?view=aspnetcore-2.2#the-startup-class" target="_blank">Convention</a>: Startup is not registered. But inside its member functions,
             e.g. ConfigureServices and Configure, their parameters can include any registered services, not restricted by the interface.
            
        </li>
        <li>Dependency chain<br>
            A service can use another service, which results in a dependency chain.
        </li>
    </ol>
</div>

<div class="featureList">
    <h4>Registering/Injecting Services</h4>
    <ol>
        <li>Where to register services<br>
            IStartup interface defines a method called 
                <pre class="brush:cpp">
                        public IServiceProvider ConfigureServices(IServiceCollection services)
                </pre>
                IServiceCollection is used to register services. After registering services,
                <pre class="brush:cpp">
                        IServiceProvider container = services.BuildServiceProvider();
                </pre>
                can build the container (provider).<br><br>
        </li>
        <li>How to register services<br>
            <br>
            <br>
            <p>A service is reusable code. Reusble code should have interface. => A service should have interface.<br>
               A service is registered with its peer interface. Then dependency injection can use the interface name to resovle a concrete service instance.<br>
            But dependency injection also allows to use concrete class to register and resolve. 
            </p>
            <br>
            <br>
            IServiceCollection provides a set of method to register services
            1). Let framework to create the instance of concrete implementation
            <pre class="brush:cpp">
                services.AddTransient&lt;IOperationTransient, Operation>();
                services.AddScoped&lt;IOperationScoped, Operation>();
                services.AddSingleton&lt;IOperationSingleton, Operation>();
            </pre>
            2). Let framework to use factory to create the instance of concrete implementation<br>
            3). Developer specifies the instance
            <pre class="brush:cpp">
                services.AddSingleton&lt;IService>(new ConcreteService());
            </pre>
            <br>
            Hints: how to customize the initialization of a service? A developer can create the service by himself, but a service 
            usually depends on other services, which means developer has to resolve the dependency chain. So a better way to customize
            the initialization of a service is through IConfiguration. Give the IConfiguration to a service's constructor. 
            <br>
            4). Add a well-defined service by using extension methods, such as
            <pre class="brush:cpp">
                services.AddMvc();
                services.AddDbContext&lt;ApplicationDbContext>(options =>
                        options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
            </pre>
        </li>
        <li>How to obtain injected code?<br>
            Two types of code: service with interface, another without interface.<br>
            obtain in two ways: actively requiring, passive injected (constructor or method)<br>
        </li>
    </ol>    
</div>


</div>
</li>
<li>
    <div class="content" id="middleware">
        <h3>Middleware & Pipeline</h3>
        <p>It is same concept as Node.js Express. Pipeline is configured via Startup.Configure(IApplicationBuilder).</p>
        <div class="featureList">
            <h4>IApplicationBuilder's Extension methods</h4>
            <ol>
                <li>.Run(RequestDelegate handler): the terminal of the pipeline<br>
                <pre class="brush:cpp">
                    // public delegate Task RequestDelegate(HttpContext context);
                    
                    // using statement lambda supported C# 3.0 and later.
                    app.Run(async context =>
                    {
                        await context.Response.WriteAsync("Hello, World!");
                    });
                </pre>
                </li>
                <li>.Map(Func&lt;HttpContext, Func&lt;Task>, Task> middleware)<br>
                <pre class="brush:cpp">
                    // Func&lt;HttpContext, Func&lt;Task>, Task>
                    // The first Func generic delegate
                    // public delegate TResult Func&lt;in T1,in T2,out TResult>(T1 arg1, T2 arg2); 
                    // The second Func generic delegate
                    // public delegate TResult Func&lt;out TResult>();

                    // => Task delegate_type(HttpContext, inner_delegate)
                    // => Task inner_delegate()

                    app.Use(async (context, next) =>
                    {
                        // Do work that doesn't write to the Response.
                        await next.Invoke();
                        // Do logging or other work that doesn't write to the Response.
                    });

                </pre>
                </li>
            </ol>
        </div>
    </div>
</li>
<li>
    <div class="content" id="lifetime">
        <h3>Service lifetime</h3>
        <p>Longer lifetime services cannot use shorter lifetime services.</p>
    </div>
</li>
<li>
<div class="content" id="reference">
<h3>References</h3>
<div class="featureList">
    <ol>
        <li><a href="https://www.strathweb.com/2017/06/resolving-asp-net-core-startup-class-from-the-di-container/" target="_blank">Resolving ASP.NET Core Startup Class from the DI container.</a></li>
    </ol>
</div>
</div>
</li>
</ol>
</div>
    
</body>
</html>
