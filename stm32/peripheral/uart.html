<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Peripheral&nbsp;UART</title>
<meta charset="utf-8">
<meta name="date" content="2018-02-18">
<meta name="keywords" content="uart">
<meta name="keywords" content="stm32f103">
<meta name="keywords" content="microcontroller">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>Peripherals&nbsp;-&nbsp;UART</strong></center>
</div>
<p class="date"><span class="created-date">Created:2018-02-18</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2018-02-18</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#uartIntro">Introduction</a></li>
<li><a href="#uartPolling">Polling</a></li>
<li><a href="#uartReference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="uartIntro">
<h3>Introduction</h3>
<h4>Generalization of the communication peripheral</h4>
<p>UART, SPI, I2C are built-in peripherals that use i/o pins, and internal data bus. They also have corresponding interrupts</p>
<div class="featureList">
<h4>Ways to get data</h4>
<ol>
<li>Polling</li>
<li>Interrupt</li>
<li>DMA</li>
</ol>
</div>
<div class="featureList">
<h4>Question need to be considered</h4>
<ol>
<li>In APB1 or APB2?</li>
<li>GPIO alternative function configuration</li>
<li>Define the corresponding HAL_xxx_MspInit
</li>
<li>Corresponding DMA channel.</li>
<li></li>
<li></li>
</ol>
</div>
<h4>UART modules</h4>
<p>UART serial communication is one of the function provided by the USART module. Besides UART, the USART module also provides functions such as IrDA, modem control</p>
<p>The STM32 F103RB consists three independent USART modules</p>
<div class="generalTable">
<h4>USART1 (APB2)</h4>
<table>
<tr><th>Function name</th><th>Default pins</th><th>Remap pins 1</th><th>Remap pins2</th></tr>
<tr><td>RX</td><td>PA10</td><td>PB7</td><td></td></tr>
<tr><td>TX</td><td>PA9</td><td>PB6</td><td></td></tr>
<tr><td>CK</td><td>PA8</td><td></td><td></td></tr>
<tr><td>CTS</td><td>PA11</td><td></td><td></td></tr>
<tr><td>RTS</td><td>PA12</td><td></td><td></td></tr>
</table>
<h4>USART2 (APB1)</h4>
<p><span style="color:red">In nucleo, the usart2's rx/tx is hard wired to the st-link virtual COM.</span></p>
<table>
<tr><th>Function name</th><th>Default pins</th><th>Remap pins 1</th><th>Remap pins2</th></tr>
<tr><td>RX</td><td>PA3</td><td>PD6</td><td></td></tr>
<tr><td>TX</td><td>PA2</td><td>PD5</td><td></td></tr>
<tr><td>CK</td><td>PA4</td><td>PD7</td><td></td></tr>
<tr><td>CTS</td><td>PA0</td><td>PD3</td><td></td></tr>
<tr><td>RTS</td><td>PA1</td><td>PD4</td><td></td></tr>
</table>
<h4>USART3 (APB1)</h4>
<table>
<tr><th>Function name</th><th>Default pins</th><th>Remap pins 1</th><th>Remap pins2</th></tr>
<tr><td>RX</td><td>PB11</td><td>PD9</td><td>PC11</td></tr>
<tr><td>TX</td><td>PB10</td><td>PD8</td><td>PC10</td></tr>
<tr><td>CK</td><td>PB12</td><td>PD10</td><td>PC12</td></tr>
<tr><td>CTS</td><td>PB13</td><td>PD11</td><td></td></tr>
<tr><td>RTS</td><td>PB14</td><td>PD12</td><td></td></tr>
</table>
</div>
<h4>Struct</h4>

</div>
</li>
<li>
<div class="content" id="uartPolling">
<h3>Polling</h3>

</div>
</li>
<li>
<div class="content" id="uartDMA">
<h3>DMA</h3>
<h4>Configuration</h4>
<p>Every data channel needs a DMA channel. RX, TX are independent, so they needs to use 2 DMA channel. UART_RX -> DMA1_channel16; UART_TX -> DMA1_channel17</p>
<p>The <span style="color:red">developer</span>defines two functions in the main</p>
<div class="featureList">
<ol>
<li>DMA_init(): <br>
    i. enable DMA1 clock<br>
    ii. set channels' priorities and enable interrupt.
    <pre class="brush:cpp">
static void MX_DMA_Init(void) 
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Channel6_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel6_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA1_Channel6_IRQn);
  /* DMA1_Channel7_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel7_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA1_Channel7_IRQn);

}
    </pre>
</li>
<li>
UART_Init():<br>
    i. set the huart2.Init (UART_InitTypeDef) such as baudrate, #bits, parity<br>
    ii. invoke HAL_UART_Init().
    <pre class="brush:cpp">
    /* USART2 init function */
static void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&amp;huart2) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

}
    </pre>
</li>
</ol>
</div>
<p>Inside <span style="color:red">HAL_xxx_Init</span>:</p>
<div class="featureList">
<ol>
<li>Call the weak function HAL_UART_MspInit(); // developer should override this function</li>
<li>Using *.Init to set *.Instance's registers</li>
</ol>
</div>
<p>The <span style="color:red">developer</span> should override HAL_xxx_MspInit():</p>
<p class="starMark">* Define in the stm32f1xx_hal_msp.c file</p>
<div class="featureList">
<ol>
<li>1. check if the instance is the desire instance. Because all UART1, UART2 and UART3 are going to use this function.
    <pre class="brush:cpp">
        if(huart->Instance == USART2){
    </pre>
</li>

<li>Enable corresponding GPIO clock, and peripheral clock
<pre class="brush:cpp">
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_USART2_CLK_ENABLE();
</pre>
</li>
<li>Configure GPIO
<pre class="brush:cpp">
    GPIO_InitStruct.Pin = GPIO_PIN_2;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; // alternative function推免
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);
</pre>
</li>
<li>Configure DMA channels
<pre class="brush:cpp">
    /* USART2 DMA Init */
    /* USART2_RX Init */
    hdma_usart2_rx.Instance = DMA1_Channel6;
    hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart2_rx.Init.Mode = DMA_NORMAL;
    hdma_usart2_rx.Init.Priority = DMA_PRIORITY_LOW;
    if (HAL_DMA_Init(&amp;hdma_usart2_rx) != HAL_OK)
    {
      _Error_Handler(__FILE__, __LINE__);
    }

    __HAL_LINKDMA(huart,hdmarx,hdma_usart2_rx); 
    // bind the huart's RX DMA channel to this DMA
    // bind DMA parent to the huart

    /* USART2_TX Init */
    hdma_usart2_tx.Instance = DMA1_Channel7;
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
    hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
    if (HAL_DMA_Init(&amp;hdma_usart2_tx) != HAL_OK)
    {
      _Error_Handler(__FILE__, __LINE__);
    }

    __HAL_LINKDMA(huart,hdmatx,hdma_usart2_tx);
</pre>
</li>
<li>Enable UART interrupt
<pre class="brush:cpp">
    /* USART2 interrupt Init */
    HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(USART2_IRQn);
</pre>
</li>
</ol>
</div>
<h4>Tranfer data in DMA mode</h4>
<div class="featureList">
<ol>
<li>
<p><i><strong>HAL_UART_Transmit_DMA()</strong></i></p>
<p>A non-blocking function. Return HAL_OK or HAL_BUSY</p>
<pre class="brush:cpp">
// two successive call to the function, the second may be ignored.
HAL_UART_Transmit_DMA(&amp;huart1, data, 5 );
HAL_UART_Transmit_DMA(&amp;huart1, data2, 6); // the second would be ignore if the first is not completed.
// !!!!design a queue that send the following in the uart complete callback.

//This function bind the pre-defined handler to the DMA TX channel, and start DMA transmit
</pre>
</li>
<li>
<p><i><strong>HAL_UART_Receive_DMA()</strong></i></p>
<p>A non-blocking function. Return HAL_OK or HAL_BUSY</p>
<pre class="brush:cpp">
// The DMA will block in the background if no data is coming.
</pre>
</li>
<li>
<p><i><strong>user defined callback functions</strong></i></p>

<pre class="brush:cpp">
void HAL_UART_TxCpltCallback(UART_HandleTypeDef * huart);
void HAL_UART_RxCpltCallback(UART_HandleTypeDef * huart);
void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef * huart);
void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef * huart);
void HAL_UART_ErrorCallback(UART_HandleTypeDef * huart);
//....
</pre>
</li>
</ol>
</div>
<h4>Interrupt relations</h4>
<p>Three type of interrupts are involved in this app.</p>
<div class="featureList">
<p>Code in the stm32f1xx_it. This wrapper provides an argument to the core handler via software C "extern" keyword.</p>
<ol>
<li>
<pre class="brush:cpp">
void DMA1_Channel6_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&amp;hdma_usart2_rx); // defined in the "stm32f1xx_hal_dma.c"
}
</pre>
</li>
<li>
<pre class="brush:cpp">
void DMA1_Channel7_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&amp;hdma_usart2_tx);
}
</pre>
</li>
<li>
<pre class="brush:cpp">
void USART2_IRQHandler(void)
{
  HAL_UART_IRQHandler(&amp;huart2);
}
</pre>
</li>
</ol>
</div>
<h4><i>DMA interrupt [HAL_DMA_IRQHandler]</i></h4>
<p>Three source can trigger DMA interrupt, half complete, full complete and error. Inside the HAL_DMA_IRQHandler, it <span style="color:red">polling</span> the three conditions and invoke the 
    callback method defined in the DMA_HandlerTypeDef
</p>
<p>The callback functions are defined by the HAL uart library in the stm32f1xx_hal_uart.c. They will bind to the DMA handler when calling to transmit/receive data.</p>
<div class="featureList">
<ol>
<li>
<p><i><strong>UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)</strong></i></p>
<pre class="brush:cpp">
//This function is defined in the stm32f1xx_hal_uart.c
//It invokes after the DMA transmit completes, therefore, both rx/tx will invoke this function
//During normal mode, it enable the uart transmit complete interrupt. Becuase the transmit is complete, so the transmit complete function would be invoked immediately.

//The UART complete handler will just clear the the busy state of this uart.
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  /* DMA Normal mode*/
  if((hdma->Instance->CCR &amp; DMA_CCR_CIRC) == 0U)
  {
    huart->TxXferCount = 0U;

    /* Disable the DMA transfer for transmit request by setting the DMAT bit
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);

    /* Enable the UART Transmit Complete Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);

  }
  /* DMA Circular mode */
  else
  {
    HAL_UART_TxCpltCallback(huart);
  }
}
</pre>
<pre class="brush:cpp">
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  /* DMA Normal mode*/
  if((hdma->Instance->CCR &amp; DMA_CCR_CIRC) == 0U)
  {
    huart->RxXferCount = 0U;
  
    /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
    
    /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);

    /* At end of Rx process, restore huart->RxState to Ready */
    huart->RxState = HAL_UART_STATE_READY;
  }
  HAL_UART_RxCpltCallback(huart);
}
</pre>
</li>
<li>
<p>When transmitting data, the transmit function will bind the tx DMA channel's interrupt to the following handlers.</p>
<p><i><strong>UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)</strong></i></p>
<pre class="brush:cpp">
//ask the developer's action via the weak function HAL_UART_TxHalfCpltCallback
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;

  HAL_UART_TxHalfCpltCallback(huart); // By default, it does nothing
}
</pre>
<pre class="brush:cpp">
static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
  HAL_UART_RxHalfCpltCallback(huart); 
}
</pre>
</li>
<li>
<p><i><strong>UART_DMAError(DMA_HandleTypeDef *hdma)</strong></i></p>
<pre class="brush:cpp">
</pre>
</li>
</ol>
</div>
<h4><i>UART Interrupt[HAL_UART_IRQHandler]</i></h4>
<p>UART interrupt handler defined in the stm32_hal_uart.c. It pulls the source that cause the interrupt. 
</p>
<pre class="brush:cpp">
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
   uint32_t isrflags   = READ_REG(huart->Instance->SR);
   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
   uint32_t cr3its     = READ_REG(huart->Instance->CR3);
   uint32_t errorflags = 0x00U;
   uint32_t dmarequest = 0x00U;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  if(errorflags == RESET)
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
    {
      UART_Receive_IT(huart);
      return;
    }
  }
 //////// not entire code are shown here. ///////
  
  /* UART in mode Transmitter ------------------------------------------------*/
  if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
  {
    UART_Transmit_IT(huart);
    return;
  }
  
  /* UART in mode Transmitter end --------------------------------------------*/
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
  {
    UART_EndTransmit_IT(huart);
    return;
  }
}
</pre>
</div>
</li>
</ol>
</div>
    
</body>
</html>
