<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_151) on Sun Oct 08 22:41:36 PDT 2017 -->
<title>Driver&nbsp;Concepts</title>
<meta charset="utf-8">
<meta name="date" content="2018-02-07">
<meta name="keywords" content="driver">
<meta name="keywords" content="linux">
<meta name="keywords" content="microcontroller">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/XRegExp.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shCore.js"></script>
<script type="text/javascript" src="../../syntaxHighlight_js_c/shBrushCpp.js"></script>
<link href="../../syntaxHighlight_css_c/shCore.css" rel="stylesheet" type="text/css" />
<link href="../../syntaxHighlight_css_c/shThemeDefault.css" rel="stylesheet" type="text/css" />



</head>
<body>
<script>
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['pad-line-numbers'] = false;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all()
</script>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="bar">
<center><strong>Driver&nbsp;Concepts</strong></center>
</div>
<p class="date"><span class="created-date">Created:2018-02-07</span>&nbsp;&nbsp;<span class="last-modified">Last modified:2018-02-07</span></p>
<div class="catalog">
<ul class="catalogItems">
<li><a href="#conceptsIntro">Introduction</a></li>
<li><a href="#powerReference">References</a></li>
</ul>
</div>
<hr>
<div class="contentContainer">
<ol>
<li>
<div class="content" id="conceptsIntro">
<h3>Introduction</h3>
<p>Linux driver is a kind of module.</p>
<div class="termnology">
<h4>Terms</h4>
<ul>
<li>Module: a piece of code that can be added to the kernel at runtime (by a tool called insmod, insert module to kernel)</li>
<li>Linux driver: linux driver is a kind of module, which is located between the hardware devices and the kernel (OS)</li>
<li>Version numbering: every software package has a release number. To run a specific versiono of a package would need a particular version of another package.</li>
</ul>
<p class="starMark">* Kernel 2.2 can disable the function of dynamic loading module at runtime.</p>
</div>
<div class="featureList">
<h4>Q&amp;A</h4>
<ol>
<li><i>How does module code is insert to kernel?</i>
<br>
The module code is compiled into a linkable object file instead of executable. And the "insmod" can link (register) this file to kernel at the runtime.
</li>
<li>
<i>Architecture of linux driver</i>
<br>
Application -> kernel -> linux driver -> hardware devices
</li>
<li>
<i>How does the driver code work?</i>
<br>
<div class="featureList">
<ol>
<li>The driver code needs to implement a few pre-defined function API (e.g. module_init) and define the value of pre-defined data structure.</li>
<li>When using insmod to load this driver (module), the pre-defined function, module_init, is invoked. (* inside the module_init, developers initialize global data and register the device)</li>
<li>OS maps the registered driver's functions to the general system calls, such as write, read, open (* because a linux device is represented as a file, the mapped functions are just the system calls that manuiplate files.</li>
</ol>
</div>
</li>
<li><i>Driver types</i>
<br>
Accroding to different type of devices, device driver is also divided into 3 categories.
<span style="color:red">Each device driver has its own data structure.</span>
<div class="featureList">
<ol>
<li>char device: e.g. lcd, uart; mapped to file system, /dev/ttyS0, /dev/console; data structure "struct cdev"; user api, open, write, read, close</li>
<li>block device: e.g. disk, sd card; mapped to file system ; data structure has a block size, which is determined by the hardware, software cannot modify them</li>
<li>network device: e.g. ethernet; not mapped to file system ;user api, socket</li>
</ol>
</div>
</li>
<li>
<i>Virtualization of hardware</i>
<li>Some hardware that users can find in the system are software virtualized, such as loopback interface (network device), tty (a terminal)</li>
</li>
<li>
<i>an UART connect to USB, an mouse connect to USB</i>
<br>
USB is a bus device, a UART/mouse connects to the USB is working with an additional layer of kernel support functions.<br>
user application -> kernel -> usb bus -> UART<br>
user application -> kernel -> usb bus -> mouse<br>
(* usb is directly connect to the cpu bus)<br>
(* but the device is directly shown as a char device of UART or mouse. In this case, the UART/mouse driver would need to invoke the USB function)

</li>
<li>
<i>How does linux eliminates the complexity of device driver</i>
<br>
The implementations of device drivers for different devices are different from each other, but the provided user's API (e.g. open, write, read, close) are same.
</li>

</ol>
</div>
</div>
</li>
<li>
<div class="content" id="analysis">
<h3>Analysis of the UART driver</h3>
</div>
</li>

</ol>
</div>
    
</body>
</html>
